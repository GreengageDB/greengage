-- from http://www.depesz.com/index.php/2010/04/19/getting-unique-elements/
-- Enable logs that allow to show GPORCA failed to produce a plan
SET optimizer_trace_fallback = on;
CREATE TEMP TABLE articles (
    id int CONSTRAINT articles_pkey PRIMARY KEY,
    keywords text,
    -- GPDB doesn't support having a PRIMARY KEY and UNIQUE constraints on the
    -- same table. Hence leave out the UNIQUE constraints.
    title text /* UNIQUE */ NOT NULL,
    body text /* UNIQUE */,
    created date
);
CREATE TEMP TABLE articles_in_category (
    article_id int,
    category_id int,
    changed date,
    PRIMARY KEY (article_id, category_id)
);
-- test functional dependencies based on primary keys/unique constraints
-- base tables
-- group by primary key (OK)
SELECT id, keywords, title, body, created
FROM articles
GROUP BY id;
 id | keywords | title | body | created 
----+----------+-------+------+---------
(0 rows)

-- group by unique not null (fail/todo)
SELECT id, keywords, title, body, created
FROM articles
GROUP BY title;
ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: SELECT id, keywords, title, body, created
               ^
-- group by unique nullable (fail)
SELECT id, keywords, title, body, created
FROM articles
GROUP BY body;
ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: SELECT id, keywords, title, body, created
               ^
-- group by something else (fail)
SELECT id, keywords, title, body, created
FROM articles
GROUP BY keywords;
ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: SELECT id, keywords, title, body, created
               ^
-- multiple tables
-- group by primary key (OK)
SELECT a.id, a.keywords, a.title, a.body, a.created
FROM articles AS a, articles_in_category AS aic
WHERE a.id = aic.article_id AND aic.category_id in (14,62,70,53,138)
GROUP BY a.id;
 id | keywords | title | body | created 
----+----------+-------+------+---------
(0 rows)

-- group by something else (fail)
SELECT a.id, a.keywords, a.title, a.body, a.created
FROM articles AS a, articles_in_category AS aic
WHERE a.id = aic.article_id AND aic.category_id in (14,62,70,53,138)
GROUP BY aic.article_id, aic.category_id;
ERROR:  column "a.id" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: SELECT a.id, a.keywords, a.title, a.body, a.created
               ^
-- JOIN syntax
-- group by left table's primary key (OK)
SELECT a.id, a.keywords, a.title, a.body, a.created
FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
WHERE aic.category_id in (14,62,70,53,138)
GROUP BY a.id;
 id | keywords | title | body | created 
----+----------+-------+------+---------
(0 rows)

-- group by something else (fail)
SELECT a.id, a.keywords, a.title, a.body, a.created
FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
WHERE aic.category_id in (14,62,70,53,138)
GROUP BY aic.article_id, aic.category_id;
ERROR:  column "a.id" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: SELECT a.id, a.keywords, a.title, a.body, a.created
               ^
-- group by right table's (composite) primary key (OK)
SELECT aic.changed
FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
WHERE aic.category_id in (14,62,70,53,138)
GROUP BY aic.category_id, aic.article_id;
 changed 
---------
(0 rows)

-- group by right table's partial primary key (fail)
SELECT aic.changed
FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
WHERE aic.category_id in (14,62,70,53,138)
GROUP BY aic.article_id;
ERROR:  column "aic.changed" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: SELECT aic.changed
               ^
-- example from documentation
CREATE TEMP TABLE products (product_id int, name text, price numeric);
CREATE TEMP TABLE sales (product_id int, units int);
-- OK
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;
 product_id | name | sales 
------------+------+-------
(0 rows)

-- fail
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id;
ERROR:  column "p.name" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
                           ^
ALTER TABLE products ADD PRIMARY KEY (product_id);
-- OK now
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id;
 product_id | name | sales 
------------+------+-------
(0 rows)

-- OK, test GPDB case
set enable_groupagg = off;
set gp_eager_two_phase_agg = on;
SELECT count(distinct name), price FROM products GROUP BY product_id;
 count | price 
-------+-------
(0 rows)

create table funcdep1(a int primary key, b int, c int, d int);
create table funcdep2(a int, b int, c int, d int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into funcdep1 values(1,1,1,1);
insert into funcdep1 values(2,1,1,1);
insert into funcdep1 values(3,1,1,1);
insert into funcdep2 values(1,1,1,1);
explain (costs off) select sum(t2.a), t1.a, t1.b, t1.c from funcdep1 t1 join funcdep2 t2 on t1.b = t2.b group by t1.a;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice4; segments: 3)
   ->  HashAggregate
         Group Key: t1.a, t1.b, t1.c
         ->  Redistribute Motion 3:3  (slice3; segments: 3)
               Hash Key: t1.a, t1.b, t1.c
               ->  HashAggregate
                     Group Key: t1.a, t1.b, t1.c
                     ->  Hash Join
                           Hash Cond: (t1.b = t2.b)
                           ->  Redistribute Motion 3:3  (slice1; segments: 3)
                                 Hash Key: t1.b
                                 ->  Seq Scan on funcdep1 t1
                           ->  Hash
                                 ->  Redistribute Motion 3:3  (slice2; segments: 3)
                                       Hash Key: t2.b
                                       ->  Seq Scan on funcdep2 t2
 Optimizer: Postgres query optimizer
(17 rows)

select sum(t2.a), t1.a, t1.b, t1.c from funcdep1 t1 join funcdep2 t2 on t1.b = t2.b group by t1.a;
 sum | a | b | c 
-----+---+---+---
   1 | 3 | 1 | 1
   1 | 2 | 1 | 1
   1 | 1 | 1 | 1
(3 rows)

explain (costs off) select sum(b), c, d, grouping(a) from funcdep1 group by grouping sets((a), ());
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)
   ->  GroupAggregate
         Group Key: "rollup".prelim_aggref_1, "rollup"."grouping", "rollup"."group_id"
         ->  Subquery Scan on "rollup"
               ->  Sort
                     Sort Key: rollup_1.prelim_aggref_1, (Grouping), (group_id())
                     ->  Redistribute Motion 3:3  (slice1; segments: 3)
                           Hash Key: rollup_1.prelim_aggref_1, (Grouping), group_id()
                           ->  GroupAggregate
                                 Group Key: rollup_1."grouping", rollup_1."group_id", rollup_1.prelim_aggref_1
                                 ->  Subquery Scan on rollup_1
                                       ->  GroupAggregate
                                             Group Key: funcdep1.a
                                             ->  Sort
                                                   Sort Key: funcdep1.a
                                                   ->  Seq Scan on funcdep1
 Optimizer: Postgres query optimizer
(17 rows)

select sum(b), c, d, grouping(a) from funcdep1 group by grouping sets((a), ());
 sum | c | d | grouping 
-----+---+---+----------
   1 | 1 | 1 |        0
   1 | 1 | 1 |        0
   1 | 1 | 1 |        0
   3 | 1 | 1 |        1
(4 rows)

explain (costs off) select sum(b), c, d, grouping(a) from funcdep1 group by rollup(a);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)
   ->  GroupAggregate
         Group Key: "rollup".prelim_aggref_1, "rollup"."grouping", "rollup"."group_id"
         ->  Subquery Scan on "rollup"
               ->  Sort
                     Sort Key: rollup_1.prelim_aggref_1, (Grouping), (group_id())
                     ->  Redistribute Motion 3:3  (slice1; segments: 3)
                           Hash Key: rollup_1.prelim_aggref_1, (Grouping), group_id()
                           ->  GroupAggregate
                                 Group Key: rollup_1."grouping", rollup_1."group_id", rollup_1.prelim_aggref_1
                                 ->  Subquery Scan on rollup_1
                                       ->  GroupAggregate
                                             Group Key: funcdep1.a
                                             ->  Sort
                                                   Sort Key: funcdep1.a
                                                   ->  Seq Scan on funcdep1
 Optimizer: Postgres query optimizer
(17 rows)

select sum(b), c, d, grouping(a) from funcdep1 group by rollup(a);
 sum | c | d | grouping 
-----+---+---+----------
   1 | 1 | 1 |        0
   1 | 1 | 1 |        0
   1 | 1 | 1 |        0
   3 | 1 | 1 |        1
(4 rows)

explain (costs off) select sum(b), c, d, grouping(a) from funcdep1 group by cube(a);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)
   ->  GroupAggregate
         Group Key: "rollup".prelim_aggref_1, "rollup"."grouping", "rollup"."group_id"
         ->  Subquery Scan on "rollup"
               ->  Sort
                     Sort Key: rollup_1.prelim_aggref_1, (Grouping), (group_id())
                     ->  Redistribute Motion 3:3  (slice1; segments: 3)
                           Hash Key: rollup_1.prelim_aggref_1, (Grouping), group_id()
                           ->  GroupAggregate
                                 Group Key: rollup_1."grouping", rollup_1."group_id", rollup_1.prelim_aggref_1
                                 ->  Subquery Scan on rollup_1
                                       ->  GroupAggregate
                                             Group Key: funcdep1.a
                                             ->  Sort
                                                   Sort Key: funcdep1.a
                                                   ->  Seq Scan on funcdep1
 Optimizer: Postgres query optimizer
(17 rows)

select sum(b), c, d, grouping(a) from funcdep1 group by cube(a);
 sum | c | d | grouping 
-----+---+---+----------
   1 | 1 | 1 |        0
   1 | 1 | 1 |        0
   1 | 1 | 1 |        0
   3 | 1 | 1 |        1
(4 rows)

explain (costs off) select count(distinct b), c, d from funcdep1 group by a;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: funcdep1.a, funcdep1.b, funcdep1.c, funcdep1.d
         ->  HashAggregate
               Group Key: funcdep1.a, funcdep1.b, funcdep1.c, funcdep1.d, funcdep1.b
               ->  HashAggregate
                     Group Key: funcdep1.a, funcdep1.b, funcdep1.c, funcdep1.d, funcdep1.b
                     ->  Seq Scan on funcdep1
 Optimizer: Postgres query optimizer
(9 rows)

select count(distinct b), c, d from funcdep1 group by a;
 count | c | d 
-------+---+---
     1 | 1 | 1
     1 | 1 | 1
     1 | 1 | 1
(3 rows)

explain (costs off) select count(distinct b), sum(b), c from funcdep1 group by a;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: funcdep1.a, funcdep1.b, funcdep1.c
         ->  HashAggregate
               Group Key: funcdep1.a, funcdep1.b, funcdep1.c, funcdep1.b
               ->  HashAggregate
                     Group Key: funcdep1.a, funcdep1.b, funcdep1.c, funcdep1.b
                     ->  Seq Scan on funcdep1
 Optimizer: Postgres query optimizer
(9 rows)

select count(distinct b), sum(b), c from funcdep1 group by a;
 count | sum | c 
-------+-----+---
     1 |   1 | 1
     1 |   1 | 1
     1 |   1 | 1
(3 rows)

explain (costs off) select count(distinct b), count(distinct c) from funcdep1 group by a;
                                                                                         QUERY PLAN                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice3; segments: 3)
   ->  Hash Join
         Hash Cond: ((NOT (share0_ref2.a IS DISTINCT FROM share0_ref1.a)) AND (NOT (share0_ref2.b IS DISTINCT FROM share0_ref1.b)) AND (NOT (share0_ref2.c IS DISTINCT FROM share0_ref1.c)))
         ->  Redistribute Motion 3:3  (slice1; segments: 3)
               Hash Key: share0_ref2.a, share0_ref2.b, share0_ref2.b
               ->  HashAggregate
                     Group Key: share0_ref2.a, share0_ref2.b, share0_ref2.c
                     ->  HashAggregate
                           Group Key: share0_ref2.a, share0_ref2.b, share0_ref2.c, share0_ref2.b
                           ->  HashAggregate
                                 Group Key: share0_ref2.a, share0_ref2.b, share0_ref2.c, share0_ref2.b
                                 ->  Shared Scan (share slice:id 1:0)
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: share0_ref1.a, share0_ref1.b, share0_ref1.b
                     ->  HashAggregate
                           Group Key: share0_ref1.a, share0_ref1.b, share0_ref1.c
                           ->  HashAggregate
                                 Group Key: share0_ref1.a, share0_ref1.b, share0_ref1.c, share0_ref1.c
                                 ->  HashAggregate
                                       Group Key: share0_ref1.a, share0_ref1.b, share0_ref1.c, share0_ref1.c
                                       ->  Shared Scan (share slice:id 2:0)
                                             ->  Materialize
                                                   ->  Seq Scan on funcdep1
 Optimizer: Postgres query optimizer
(25 rows)

select count(distinct b), count(distinct c) from funcdep1 group by a;
 count | count 
-------+-------
     1 |     1
     1 |     1
     1 |     1
(3 rows)

-- test multi primary key in group by clause
create table mfuncdep1(a int, b int, c int, d int, e int, primary key (a, b));
create table mfuncdep2(a2 int, b2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into mfuncdep1 select i, i, i, i, i from generate_series(1, 10) i;
insert into mfuncdep2 select i, i from generate_series(1, 10000) i;
analyze mfuncdep1;
analyze mfuncdep2;
explain (verbose on, costs off) select a, b , sum(c + d), e from mfuncdep1 join mfuncdep2 on c = b2 group by a,b order by 1;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice3; segments: 3)
   Output: mfuncdep1.a, mfuncdep1.b, (pg_catalog.sum((sum((mfuncdep1.c + mfuncdep1.d))))), mfuncdep1.e
   Merge Key: mfuncdep1.a
   ->  Sort
         Output: mfuncdep1.a, mfuncdep1.b, (pg_catalog.sum((sum((mfuncdep1.c + mfuncdep1.d))))), mfuncdep1.e
         Sort Key: mfuncdep1.a
         ->  HashAggregate
               Output: mfuncdep1.a, mfuncdep1.b, pg_catalog.sum((sum((mfuncdep1.c + mfuncdep1.d)))), mfuncdep1.e
               Group Key: mfuncdep1.a, mfuncdep1.b, mfuncdep1.c, mfuncdep1.d, mfuncdep1.e
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Output: mfuncdep1.a, mfuncdep1.b, mfuncdep1.c, mfuncdep1.d, mfuncdep1.e, (sum((mfuncdep1.c + mfuncdep1.d)))
                     Hash Key: mfuncdep1.a, mfuncdep1.b, mfuncdep1.c, mfuncdep1.d, mfuncdep1.e
                     ->  HashAggregate
                           Output: mfuncdep1.a, mfuncdep1.b, mfuncdep1.c, mfuncdep1.d, mfuncdep1.e, sum((mfuncdep1.c + mfuncdep1.d))
                           Group Key: mfuncdep1.a, mfuncdep1.b, mfuncdep1.c, mfuncdep1.d, mfuncdep1.e
                           ->  Hash Join
                                 Output: mfuncdep1.a, mfuncdep1.b, mfuncdep1.c, mfuncdep1.d, mfuncdep1.e
                                 Hash Cond: (mfuncdep2.b2 = mfuncdep1.c)
                                 ->  Seq Scan on public.mfuncdep2
                                       Output: mfuncdep2.b2, mfuncdep2.a2
                                 ->  Hash
                                       Output: mfuncdep1.a, mfuncdep1.b, mfuncdep1.c, mfuncdep1.d, mfuncdep1.e
                                       ->  Broadcast Motion 3:3  (slice1; segments: 3)
                                             Output: mfuncdep1.a, mfuncdep1.b, mfuncdep1.c, mfuncdep1.d, mfuncdep1.e
                                             ->  Seq Scan on public.mfuncdep1
                                                   Output: mfuncdep1.a, mfuncdep1.b, mfuncdep1.c, mfuncdep1.d, mfuncdep1.e
 Optimizer: Postgres query optimizer
 Settings: enable_groupagg=off
(28 rows)

select a, b , sum(c + d), e from mfuncdep1 join mfuncdep2 on c = b2 group by a,b order by 1;
 a  | b  | sum | e  
----+----+-----+----
  1 |  1 |   2 |  1
  2 |  2 |   4 |  2
  3 |  3 |   6 |  3
  4 |  4 |   8 |  4
  5 |  5 |  10 |  5
  6 |  6 |  12 |  6
  7 |  7 |  14 |  7
  8 |  8 |  16 |  8
  9 |  9 |  18 |  9
 10 | 10 |  20 | 10
(10 rows)

reset enable_groupagg;
reset gp_eager_two_phase_agg;
drop table funcdep1;
drop table funcdep2;
drop table mfuncdep1;
drop table mfuncdep2;
-- Drupal example, http://drupal.org/node/555530
CREATE TEMP TABLE node (
    nid SERIAL,
    vid integer NOT NULL default '0',
    type varchar(32) NOT NULL default '',
    title varchar(128) NOT NULL default '',
    uid integer NOT NULL default '0',
    status integer NOT NULL default '1',
    created integer NOT NULL default '0',
    -- snip
    PRIMARY KEY (nid, vid)
);
CREATE TEMP TABLE users (
    uid integer NOT NULL default '0',
    name varchar(60) NOT NULL default '',
    pass varchar(32) NOT NULL default '',
    -- snip
    PRIMARY KEY (uid)
    /* , UNIQUE (name) */
);
-- OK
SELECT u.uid, u.name FROM node n
INNER JOIN users u ON u.uid = n.uid
WHERE n.type = 'blog' AND n.status = 1
GROUP BY u.uid, u.name;
 uid | name 
-----+------
(0 rows)

-- OK
SELECT u.uid, u.name FROM node n
INNER JOIN users u ON u.uid = n.uid
WHERE n.type = 'blog' AND n.status = 1
GROUP BY u.uid;
 uid | name 
-----+------
(0 rows)

-- Check views and dependencies
-- fail
CREATE TEMP VIEW fdv1 AS
SELECT id, keywords, title, body, created
FROM articles
GROUP BY body;
ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function
LINE 2: SELECT id, keywords, title, body, created
               ^
-- OK
CREATE TEMP VIEW fdv1 AS
SELECT id, keywords, title, body, created
FROM articles
GROUP BY id;
-- fail
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
DETAIL:  view fdv1 depends on constraint articles_pkey on table articles
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
DROP VIEW fdv1;
-- multiple dependencies
CREATE TEMP VIEW fdv2 AS
SELECT a.id, a.keywords, a.title, aic.category_id, aic.changed
FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
WHERE aic.category_id in (14,62,70,53,138)
GROUP BY a.id, aic.category_id, aic.article_id;
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT; -- fail
ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
DETAIL:  view fdv2 depends on constraint articles_pkey on table articles
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
ALTER TABLE articles_in_category DROP CONSTRAINT articles_in_category_pkey RESTRICT; --fail
ERROR:  cannot drop constraint articles_in_category_pkey on table articles_in_category because other objects depend on it
DETAIL:  view fdv2 depends on constraint articles_in_category_pkey on table articles_in_category
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
DROP VIEW fdv2;
-- nested queries
CREATE TEMP VIEW fdv3 AS
SELECT id, keywords, title, body, created
FROM articles
GROUP BY id
UNION
SELECT id, keywords, title, body, created
FROM articles
GROUP BY id;
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT; -- fail
ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
DETAIL:  view fdv3 depends on constraint articles_pkey on table articles
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
DROP VIEW fdv3;
CREATE TEMP VIEW fdv4 AS
SELECT * FROM articles WHERE title IN (SELECT title FROM articles GROUP BY id);
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT; -- fail
ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
DETAIL:  view fdv4 depends on constraint articles_pkey on table articles
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
DROP VIEW fdv4;
-- prepared query plans: this results in failure on reuse
PREPARE foo AS
  SELECT id, keywords, title, body, created
  FROM articles
  GROUP BY id;
EXECUTE foo;
 id | keywords | title | body | created 
----+----------+-------+------+---------
(0 rows)

ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
EXECUTE foo;  -- fail
ERROR:  column "articles.keywords" must appear in the GROUP BY clause or be used in an aggregate function
-- Known issue - in case there is a column in the target list that is not
-- explicitly listed in the GROUP BY clause but has a functional dependency on
-- another column in the GROUP BY clause, Postgres planner might output column
-- values in grouped rows, that actually cannot be uniquely identified. As it
-- can introduce instability in the tests, all the queries below are
-- temporarily tested only with GPORCA.
-- TODO: remove the hard-coded optimizer option below once this issue is fixed.
SET optimizer = on;
CREATE TABLE test_table1 (a int PRIMARY KEY, b text, c int);
INSERT INTO test_table1 VALUES
(1, 'text1', 0),
(2, 'text2', 1),
(3, 'text3', 0),
(4, 'text4', 1),
(5, 'text0', 0),
(6, 'text1', 1),
(7, 'text2', 0),
(8, 'text3', 1),
(9, 'text4', 0),
(10, 'text0', 1),
(11, 'text1', 0),
(12, 'text2', 1),
(13, 'text3', 0),
(14, 'text4', 1),
(15, 'text0', 0),
(16, 'text1', 1),
(17, 'text2', 0),
(18, 'text3', 1),
(19, 'text4', 0),
(20, 'text0', 1),
(21, 'text1', 0),
(22, 'text2', 1),
(23, 'text3', 0),
(24, 'text4', 1),
(25, 'text0', 0);
CREATE TABLE test_table2 (a int, b text, c int, CONSTRAINT id_t2 PRIMARY KEY(a,c));
INSERT INTO test_table2 VALUES
(1, 'text|1|-1|', -1),
(1, 'text|1|1|',   1),
(2, 'text|2|-1|', -1),
(2, 'text|2|1|',   1),
(3, 'text|3|-1|', -1),
(3, 'text|3|1|',   1),
(4, 'text|4|-1|', -1),
(4, 'text|4|1|',   1),
(5, 'text|5|-1|', -1),
(5, 'text|5|1|',   1);
CREATE TABLE test_table3 (a int PRIMARY KEY, b text, c int);
INSERT INTO test_table3 VALUES
(1, 't3-text1', 0),
(2, 't3-text2', 1),
(3, 't3-text3', 0),
(4, 't3-text4', 1),
(5, 't3-text0', 0),
(6, 't3-text1', 1),
(7, 't3-text2', 0),
(8, 't3-text3', 1),
(9, 't3-text4', 0),
(10, 't3-text0', 1);
-- Check simple group by clause
SELECT a, b FROM test_table1 GROUP BY a ORDER BY a;
 a  |   b   
----+-------
  1 | text1
  2 | text2
  3 | text3
  4 | text4
  5 | text0
  6 | text1
  7 | text2
  8 | text3
  9 | text4
 10 | text0
 11 | text1
 12 | text2
 13 | text3
 14 | text4
 15 | text0
 16 | text1
 17 | text2
 18 | text3
 19 | text4
 20 | text0
 21 | text1
 22 | text2
 23 | text3
 24 | text4
 25 | text0
(25 rows)

SELECT a, b, c FROM test_table1 GROUP BY a, a > 1 ORDER BY a;
 a  |   b   | c 
----+-------+---
  1 | text1 | 0
  2 | text2 | 1
  3 | text3 | 0
  4 | text4 | 1
  5 | text0 | 0
  6 | text1 | 1
  7 | text2 | 0
  8 | text3 | 1
  9 | text4 | 0
 10 | text0 | 1
 11 | text1 | 0
 12 | text2 | 1
 13 | text3 | 0
 14 | text4 | 1
 15 | text0 | 0
 16 | text1 | 1
 17 | text2 | 0
 18 | text3 | 1
 19 | text4 | 0
 20 | text0 | 1
 21 | text1 | 0
 22 | text2 | 1
 23 | text3 | 0
 24 | text4 | 1
 25 | text0 | 0
(25 rows)

SELECT a, b, c FROM test_table1 GROUP BY a, b ORDER BY a;
 a  |   b   | c 
----+-------+---
  1 | text1 | 0
  2 | text2 | 1
  3 | text3 | 0
  4 | text4 | 1
  5 | text0 | 0
  6 | text1 | 1
  7 | text2 | 0
  8 | text3 | 1
  9 | text4 | 0
 10 | text0 | 1
 11 | text1 | 0
 12 | text2 | 1
 13 | text3 | 0
 14 | text4 | 1
 15 | text0 | 0
 16 | text1 | 1
 17 | text2 | 0
 18 | text3 | 1
 19 | text4 | 0
 20 | text0 | 1
 21 | text1 | 0
 22 | text2 | 1
 23 | text3 | 0
 24 | text4 | 1
 25 | text0 | 0
(25 rows)

-- Check grouping sets
SELECT a, b FROM test_table1 GROUP BY GROUPING SETS ((a)) ORDER BY a;
 a  |   b   
----+-------
  1 | text1
  2 | text2
  3 | text3
  4 | text4
  5 | text0
  6 | text1
  7 | text2
  8 | text3
  9 | text4
 10 | text0
 11 | text1
 12 | text2
 13 | text3
 14 | text4
 15 | text0
 16 | text1
 17 | text2
 18 | text3
 19 | text4
 20 | text0
 21 | text1
 22 | text2
 23 | text3
 24 | text4
 25 | text0
(25 rows)

SELECT a, b FROM test_table1 GROUP BY GROUPING SETS ((a), (a)) ORDER BY a;
 a  |   b   
----+-------
  1 | text1
  1 | text1
  2 | text2
  2 | text2
  3 | text3
  3 | text3
  4 | text4
  4 | text4
  5 | text0
  5 | text0
  6 | text1
  6 | text1
  7 | text2
  7 | text2
  8 | text3
  8 | text3
  9 | text4
  9 | text4
 10 | text0
 10 | text0
 11 | text1
 11 | text1
 12 | text2
 12 | text2
 13 | text3
 13 | text3
 14 | text4
 14 | text4
 15 | text0
 15 | text0
 16 | text1
 16 | text1
 17 | text2
 17 | text2
 18 | text3
 18 | text3
 19 | text4
 19 | text4
 20 | text0
 20 | text0
 21 | text1
 21 | text1
 22 | text2
 22 | text2
 23 | text3
 23 | text3
 24 | text4
 24 | text4
 25 | text0
 25 | text0
(50 rows)

SELECT a, b, c FROM test_table1 GROUP BY GROUPING SETS ((a)) ORDER BY a, b;
 a  |   b   | c 
----+-------+---
  1 | text1 | 0
  2 | text2 | 1
  3 | text3 | 0
  4 | text4 | 1
  5 | text0 | 0
  6 | text1 | 1
  7 | text2 | 0
  8 | text3 | 1
  9 | text4 | 0
 10 | text0 | 1
 11 | text1 | 0
 12 | text2 | 1
 13 | text3 | 0
 14 | text4 | 1
 15 | text0 | 0
 16 | text1 | 1
 17 | text2 | 0
 18 | text3 | 1
 19 | text4 | 0
 20 | text0 | 1
 21 | text1 | 0
 22 | text2 | 1
 23 | text3 | 0
 24 | text4 | 1
 25 | text0 | 0
(25 rows)

SELECT a, b, c FROM test_table1 GROUP BY GROUPING SETS ((a), ()) ORDER BY a, b, c;
 a  |   b   | c 
----+-------+---
  1 | text1 | 0
  2 | text2 | 1
  3 | text3 | 0
  4 | text4 | 1
  5 | text0 | 0
  6 | text1 | 1
  7 | text2 | 0
  8 | text3 | 1
  9 | text4 | 0
 10 | text0 | 1
 11 | text1 | 0
 12 | text2 | 1
 13 | text3 | 0
 14 | text4 | 1
 15 | text0 | 0
 16 | text1 | 1
 17 | text2 | 0
 18 | text3 | 1
 19 | text4 | 0
 20 | text0 | 1
 21 | text1 | 0
 22 | text2 | 1
 23 | text3 | 0
 24 | text4 | 1
 25 | text0 | 0
    |       |  
(26 rows)

SELECT a, b, c FROM test_table1 GROUP BY GROUPING SETS ((a), (b)) ORDER BY a, b;
 a  |   b   | c 
----+-------+---
  1 |       | 0
  2 |       | 1
  3 |       | 0
  4 |       | 1
  5 |       | 0
  6 |       | 1
  7 |       | 0
  8 |       | 1
  9 |       | 0
 10 |       | 1
 11 |       | 0
 12 |       | 1
 13 |       | 0
 14 |       | 1
 15 |       | 0
 16 |       | 1
 17 |       | 0
 18 |       | 1
 19 |       | 0
 20 |       | 1
 21 |       | 0
 22 |       | 1
 23 |       | 0
 24 |       | 1
 25 |       | 0
    | text0 |  
    | text1 |  
    | text2 |  
    | text3 |  
    | text4 |  
(30 rows)

SELECT a, b, c FROM test_table1 GROUP BY GROUPING SETS ((a, b)) ORDER BY a, b;
 a  |   b   | c 
----+-------+---
  1 | text1 | 0
  2 | text2 | 1
  3 | text3 | 0
  4 | text4 | 1
  5 | text0 | 0
  6 | text1 | 1
  7 | text2 | 0
  8 | text3 | 1
  9 | text4 | 0
 10 | text0 | 1
 11 | text1 | 0
 12 | text2 | 1
 13 | text3 | 0
 14 | text4 | 1
 15 | text0 | 0
 16 | text1 | 1
 17 | text2 | 0
 18 | text3 | 1
 19 | text4 | 0
 20 | text0 | 1
 21 | text1 | 0
 22 | text2 | 1
 23 | text3 | 0
 24 | text4 | 1
 25 | text0 | 0
(25 rows)

SELECT a, b, c FROM test_table1 GROUP BY GROUPING SETS ((a, b), (a), ()) ORDER BY a, b, c;
 a  |   b   | c 
----+-------+---
  1 | text1 | 0
  1 |       | 0
  2 | text2 | 1
  2 |       | 1
  3 | text3 | 0
  3 |       | 0
  4 | text4 | 1
  4 |       | 1
  5 | text0 | 0
  5 |       | 0
  6 | text1 | 1
  6 |       | 1
  7 | text2 | 0
  7 |       | 0
  8 | text3 | 1
  8 |       | 1
  9 | text4 | 0
  9 |       | 0
 10 | text0 | 1
 10 |       | 1
 11 | text1 | 0
 11 |       | 0
 12 | text2 | 1
 12 |       | 1
 13 | text3 | 0
 13 |       | 0
 14 | text4 | 1
 14 |       | 1
 15 | text0 | 0
 15 |       | 0
 16 | text1 | 1
 16 |       | 1
 17 | text2 | 0
 17 |       | 0
 18 | text3 | 1
 18 |       | 1
 19 | text4 | 0
 19 |       | 0
 20 | text0 | 1
 20 |       | 1
 21 | text1 | 0
 21 |       | 0
 22 | text2 | 1
 22 |       | 1
 23 | text3 | 0
 23 |       | 0
 24 | text4 | 1
 24 |       | 1
 25 | text0 | 0
 25 |       | 0
    |       |  
(51 rows)

SELECT a, b, c FROM test_table1 GROUP BY GROUPING SETS ((a, a), ()) ORDER BY a, b, c;
 a  |   b   | c 
----+-------+---
  1 | text1 | 0
  2 | text2 | 1
  3 | text3 | 0
  4 | text4 | 1
  5 | text0 | 0
  6 | text1 | 1
  7 | text2 | 0
  8 | text3 | 1
  9 | text4 | 0
 10 | text0 | 1
 11 | text1 | 0
 12 | text2 | 1
 13 | text3 | 0
 14 | text4 | 1
 15 | text0 | 0
 16 | text1 | 1
 17 | text2 | 0
 18 | text3 | 1
 19 | text4 | 0
 20 | text0 | 1
 21 | text1 | 0
 22 | text2 | 1
 23 | text3 | 0
 24 | text4 | 1
 25 | text0 | 0
    |       |  
(26 rows)

-- Check rollup
SELECT a, b, c FROM test_table1 GROUP BY ROLLUP (a) ORDER BY a, b, c;
 a  |   b   | c 
----+-------+---
  1 | text1 | 0
  2 | text2 | 1
  3 | text3 | 0
  4 | text4 | 1
  5 | text0 | 0
  6 | text1 | 1
  7 | text2 | 0
  8 | text3 | 1
  9 | text4 | 0
 10 | text0 | 1
 11 | text1 | 0
 12 | text2 | 1
 13 | text3 | 0
 14 | text4 | 1
 15 | text0 | 0
 16 | text1 | 1
 17 | text2 | 0
 18 | text3 | 1
 19 | text4 | 0
 20 | text0 | 1
 21 | text1 | 0
 22 | text2 | 1
 23 | text3 | 0
 24 | text4 | 1
 25 | text0 | 0
    |       |  
(26 rows)

SELECT a, b, c FROM test_table1 GROUP BY ROLLUP (a, b) ORDER BY a, b, c;
 a  |   b   | c 
----+-------+---
  1 | text1 | 0
  1 |       | 0
  2 | text2 | 1
  2 |       | 1
  3 | text3 | 0
  3 |       | 0
  4 | text4 | 1
  4 |       | 1
  5 | text0 | 0
  5 |       | 0
  6 | text1 | 1
  6 |       | 1
  7 | text2 | 0
  7 |       | 0
  8 | text3 | 1
  8 |       | 1
  9 | text4 | 0
  9 |       | 0
 10 | text0 | 1
 10 |       | 1
 11 | text1 | 0
 11 |       | 0
 12 | text2 | 1
 12 |       | 1
 13 | text3 | 0
 13 |       | 0
 14 | text4 | 1
 14 |       | 1
 15 | text0 | 0
 15 |       | 0
 16 | text1 | 1
 16 |       | 1
 17 | text2 | 0
 17 |       | 0
 18 | text3 | 1
 18 |       | 1
 19 | text4 | 0
 19 |       | 0
 20 | text0 | 1
 20 |       | 1
 21 | text1 | 0
 21 |       | 0
 22 | text2 | 1
 22 |       | 1
 23 | text3 | 0
 23 |       | 0
 24 | text4 | 1
 24 |       | 1
 25 | text0 | 0
 25 |       | 0
    |       |  
(51 rows)

-- Check expressions in target list
SELECT a, b, c, 1+(a+c)*2 AS exp_ac FROM test_table1 GROUP BY a ORDER BY a, b, c, exp_ac;
 a  |   b   | c | exp_ac 
----+-------+---+--------
  1 | text1 | 0 |      3
  2 | text2 | 1 |      7
  3 | text3 | 0 |      7
  4 | text4 | 1 |     11
  5 | text0 | 0 |     11
  6 | text1 | 1 |     15
  7 | text2 | 0 |     15
  8 | text3 | 1 |     19
  9 | text4 | 0 |     19
 10 | text0 | 1 |     23
 11 | text1 | 0 |     23
 12 | text2 | 1 |     27
 13 | text3 | 0 |     27
 14 | text4 | 1 |     31
 15 | text0 | 0 |     31
 16 | text1 | 1 |     35
 17 | text2 | 0 |     35
 18 | text3 | 1 |     39
 19 | text4 | 0 |     39
 20 | text0 | 1 |     43
 21 | text1 | 0 |     43
 22 | text2 | 1 |     47
 23 | text3 | 0 |     47
 24 | text4 | 1 |     51
 25 | text0 | 0 |     51
(25 rows)

SELECT 1+(a+c)*2 AS exp_ac, a FROM test_table1 GROUP BY a ORDER BY a;
 exp_ac | a  
--------+----
      3 |  1
      7 |  2
      7 |  3
     11 |  4
     11 |  5
     15 |  6
     15 |  7
     19 |  8
     19 |  9
     23 | 10
     23 | 11
     27 | 12
     27 | 13
     31 | 14
     31 | 15
     35 | 16
     35 | 17
     39 | 18
     39 | 19
     43 | 20
     43 | 21
     47 | 22
     47 | 23
     51 | 24
     51 | 25
(25 rows)

SELECT 1+(a+c)*2 AS exp_ac_1, 100+(a+c)*2 AS exp_ac_2 FROM test_table1 GROUP BY a ORDER BY exp_ac_1;
 exp_ac_1 | exp_ac_2 
----------+----------
        3 |      102
        7 |      106
        7 |      106
       11 |      110
       11 |      110
       15 |      114
       15 |      114
       19 |      118
       19 |      118
       23 |      122
       23 |      122
       27 |      126
       27 |      126
       31 |      130
       31 |      130
       35 |      134
       35 |      134
       39 |      138
       39 |      138
       43 |      142
       43 |      142
       47 |      146
       47 |      146
       51 |      150
       51 |      150
(25 rows)

SELECT 1+(a+c)*2 AS exp_ac, a FROM test_table1 GROUP BY GROUPING SETS ((a), ()) ORDER BY a;
 exp_ac | a  
--------+----
      3 |  1
      7 |  2
      7 |  3
     11 |  4
     11 |  5
     15 |  6
     15 |  7
     19 |  8
     19 |  9
     23 | 10
     23 | 11
     27 | 12
     27 | 13
     31 | 14
     31 | 15
     35 | 16
     35 | 17
     39 | 18
     39 | 19
     43 | 20
     43 | 21
     47 | 22
     47 | 23
     51 | 24
     51 | 25
        |   
(26 rows)

-- Check together with aggregate functions in target list
SELECT count(*) AS cnt, 1+(a+c)*2 AS exp_ac, a FROM test_table1 GROUP BY GROUPING SETS ((a), ()) ORDER BY a;
 cnt | exp_ac | a  
-----+--------+----
   1 |      3 |  1
   1 |      7 |  2
   1 |      7 |  3
   1 |     11 |  4
   1 |     11 |  5
   1 |     15 |  6
   1 |     15 |  7
   1 |     19 |  8
   1 |     19 |  9
   1 |     23 | 10
   1 |     23 | 11
   1 |     27 | 12
   1 |     27 | 13
   1 |     31 | 14
   1 |     31 | 15
   1 |     35 | 16
   1 |     35 | 17
   1 |     39 | 18
   1 |     39 | 19
   1 |     43 | 20
   1 |     43 | 21
   1 |     47 | 22
   1 |     47 | 23
   1 |     51 | 24
   1 |     51 | 25
  25 |        |   
(26 rows)

SELECT avg(c) AS avg_c, c FROM test_table1 GROUP BY GROUPING SETS ((a), (b), ()) ORDER BY avg_c, c;
         avg_c          | c 
------------------------+---
 0.00000000000000000000 | 0
 0.00000000000000000000 | 0
 0.00000000000000000000 | 0
 0.00000000000000000000 | 0
 0.00000000000000000000 | 0
 0.00000000000000000000 | 0
 0.00000000000000000000 | 0
 0.00000000000000000000 | 0
 0.00000000000000000000 | 0
 0.00000000000000000000 | 0
 0.00000000000000000000 | 0
 0.00000000000000000000 | 0
 0.00000000000000000000 | 0
 0.40000000000000000000 |  
 0.40000000000000000000 |  
 0.40000000000000000000 |  
 0.48000000000000000000 |  
 0.60000000000000000000 |  
 0.60000000000000000000 |  
 1.00000000000000000000 | 1
 1.00000000000000000000 | 1
 1.00000000000000000000 | 1
 1.00000000000000000000 | 1
 1.00000000000000000000 | 1
 1.00000000000000000000 | 1
 1.00000000000000000000 | 1
 1.00000000000000000000 | 1
 1.00000000000000000000 | 1
 1.00000000000000000000 | 1
 1.00000000000000000000 | 1
 1.00000000000000000000 | 1
(31 rows)

-- Check with grouping function in target list
SELECT grouping(a) AS g_a, a, b FROM test_table1 GROUP BY GROUPING SETS ((a)) ORDER BY a;
 g_a | a  |   b   
-----+----+-------
   0 |  1 | text1
   0 |  2 | text2
   0 |  3 | text3
   0 |  4 | text4
   0 |  5 | text0
   0 |  6 | text1
   0 |  7 | text2
   0 |  8 | text3
   0 |  9 | text4
   0 | 10 | text0
   0 | 11 | text1
   0 | 12 | text2
   0 | 13 | text3
   0 | 14 | text4
   0 | 15 | text0
   0 | 16 | text1
   0 | 17 | text2
   0 | 18 | text3
   0 | 19 | text4
   0 | 20 | text0
   0 | 21 | text1
   0 | 22 | text2
   0 | 23 | text3
   0 | 24 | text4
   0 | 25 | text0
(25 rows)

SELECT grouping(a) AS g_a, grouping(b) AS g_b, avg(c) AS avg_c FROM test_table1 GROUP BY GROUPING SETS ((a), (b), ()) ORDER BY avg_c, c;
 g_a | g_b |         avg_c          
-----+-----+------------------------
   0 |   1 | 0.00000000000000000000
   0 |   1 | 0.00000000000000000000
   0 |   1 | 0.00000000000000000000
   0 |   1 | 0.00000000000000000000
   0 |   1 | 0.00000000000000000000
   0 |   1 | 0.00000000000000000000
   0 |   1 | 0.00000000000000000000
   0 |   1 | 0.00000000000000000000
   0 |   1 | 0.00000000000000000000
   0 |   1 | 0.00000000000000000000
   0 |   1 | 0.00000000000000000000
   0 |   1 | 0.00000000000000000000
   0 |   1 | 0.00000000000000000000
   1 |   0 | 0.40000000000000000000
   1 |   0 | 0.40000000000000000000
   1 |   0 | 0.40000000000000000000
   1 |   1 | 0.48000000000000000000
   1 |   0 | 0.60000000000000000000
   1 |   0 | 0.60000000000000000000
   0 |   1 | 1.00000000000000000000
   0 |   1 | 1.00000000000000000000
   0 |   1 | 1.00000000000000000000
   0 |   1 | 1.00000000000000000000
   0 |   1 | 1.00000000000000000000
   0 |   1 | 1.00000000000000000000
   0 |   1 | 1.00000000000000000000
   0 |   1 | 1.00000000000000000000
   0 |   1 | 1.00000000000000000000
   0 |   1 | 1.00000000000000000000
   0 |   1 | 1.00000000000000000000
   0 |   1 | 1.00000000000000000000
(31 rows)

SELECT grouping(a) AS g_a, grouping(b) AS g_b, avg(c) AS avg_c, c FROM test_table1 GROUP BY GROUPING SETS ((a), (b), ()) ORDER BY avg_c, c;
 g_a | g_b |         avg_c          | c 
-----+-----+------------------------+---
   0 |   1 | 0.00000000000000000000 | 0
   0 |   1 | 0.00000000000000000000 | 0
   0 |   1 | 0.00000000000000000000 | 0
   0 |   1 | 0.00000000000000000000 | 0
   0 |   1 | 0.00000000000000000000 | 0
   0 |   1 | 0.00000000000000000000 | 0
   0 |   1 | 0.00000000000000000000 | 0
   0 |   1 | 0.00000000000000000000 | 0
   0 |   1 | 0.00000000000000000000 | 0
   0 |   1 | 0.00000000000000000000 | 0
   0 |   1 | 0.00000000000000000000 | 0
   0 |   1 | 0.00000000000000000000 | 0
   0 |   1 | 0.00000000000000000000 | 0
   1 |   0 | 0.40000000000000000000 |  
   1 |   0 | 0.40000000000000000000 |  
   1 |   0 | 0.40000000000000000000 |  
   1 |   1 | 0.48000000000000000000 |  
   1 |   0 | 0.60000000000000000000 |  
   1 |   0 | 0.60000000000000000000 |  
   0 |   1 | 1.00000000000000000000 | 1
   0 |   1 | 1.00000000000000000000 | 1
   0 |   1 | 1.00000000000000000000 | 1
   0 |   1 | 1.00000000000000000000 | 1
   0 |   1 | 1.00000000000000000000 | 1
   0 |   1 | 1.00000000000000000000 | 1
   0 |   1 | 1.00000000000000000000 | 1
   0 |   1 | 1.00000000000000000000 | 1
   0 |   1 | 1.00000000000000000000 | 1
   0 |   1 | 1.00000000000000000000 | 1
   0 |   1 | 1.00000000000000000000 | 1
   0 |   1 | 1.00000000000000000000 | 1
(31 rows)

-- Check aggregate functions in ORDER BY clause
SELECT a, b FROM test_table1 GROUP BY GROUPING SETS ((a), ()) ORDER BY avg(c), a, b;
 a  |   b   
----+-------
  1 | text1
  3 | text3
  5 | text0
  7 | text2
  9 | text4
 11 | text1
 13 | text3
 15 | text0
 17 | text2
 19 | text4
 21 | text1
 23 | text3
 25 | text0
    | 
  2 | text2
  4 | text4
  6 | text1
  8 | text3
 10 | text0
 12 | text2
 14 | text4
 16 | text1
 18 | text3
 20 | text0
 22 | text2
 24 | text4
(26 rows)

-- Check aggregate functions in HAVING clause
SELECT a, b FROM test_table1 GROUP BY GROUPING SETS ((a), ()) HAVING avg(c) > 0 ORDER BY avg(c), a, b;
 a  |   b   
----+-------
    | 
  2 | text2
  4 | text4
  6 | text1
  8 | text3
 10 | text0
 12 | text2
 14 | text4
 16 | text1
 18 | text3
 20 | text0
 22 | text2
 24 | text4
(13 rows)

-- Check grouping functions in HAVING clause
SELECT grouping(a) AS g_a, a, b, c FROM test_table1 GROUP BY ROLLUP (a) HAVING grouping(a) = 0 ORDER BY a, b, c;
 g_a | a  |   b   | c 
-----+----+-------+---
   0 |  1 | text1 | 0
   0 |  2 | text2 | 1
   0 |  3 | text3 | 0
   0 |  4 | text4 | 1
   0 |  5 | text0 | 0
   0 |  6 | text1 | 1
   0 |  7 | text2 | 0
   0 |  8 | text3 | 1
   0 |  9 | text4 | 0
   0 | 10 | text0 | 1
   0 | 11 | text1 | 0
   0 | 12 | text2 | 1
   0 | 13 | text3 | 0
   0 | 14 | text4 | 1
   0 | 15 | text0 | 0
   0 | 16 | text1 | 1
   0 | 17 | text2 | 0
   0 | 18 | text3 | 1
   0 | 19 | text4 | 0
   0 | 20 | text0 | 1
   0 | 21 | text1 | 0
   0 | 22 | text2 | 1
   0 | 23 | text3 | 0
   0 | 24 | text4 | 1
   0 | 25 | text0 | 0
(25 rows)

SELECT 1+(a+c)*2 AS exp_ac_1, b, grouping(b) AS g_b FROM test_table1 GROUP BY a, b HAVING grouping(b) = 0 ORDER BY exp_ac_1, b;
 exp_ac_1 |   b   | g_b 
----------+-------+-----
        3 | text1 |   0
        7 | text2 |   0
        7 | text3 |   0
       11 | text0 |   0
       11 | text4 |   0
       15 | text1 |   0
       15 | text2 |   0
       19 | text3 |   0
       19 | text4 |   0
       23 | text0 |   0
       23 | text1 |   0
       27 | text2 |   0
       27 | text3 |   0
       31 | text0 |   0
       31 | text4 |   0
       35 | text1 |   0
       35 | text2 |   0
       39 | text3 |   0
       39 | text4 |   0
       43 | text0 |   0
       43 | text1 |   0
       47 | text2 |   0
       47 | text3 |   0
       51 | text0 |   0
       51 | text4 |   0
(25 rows)

SELECT grouping(a) AS g_a, grouping(b) AS g_b, avg(c) AS avg_c FROM test_table1 GROUP BY GROUPING SETS ((a), (b), ())
	HAVING  grouping(a) = 1 AND grouping(b) = 1 ORDER BY avg_c, c;
 g_a | g_b |         avg_c          
-----+-----+------------------------
   1 |   1 | 0.48000000000000000000
(1 row)

-- Check sub-query
SELECT * FROM (SELECT a, b, c FROM test_table1 GROUP BY GROUPING SETS ((a), ()) ORDER BY a) AS sub_t;
 a  |   b   | c 
----+-------+---
  1 | text1 | 0
  2 | text2 | 1
  3 | text3 | 0
  4 | text4 | 1
  5 | text0 | 0
  6 | text1 | 1
  7 | text2 | 0
  8 | text3 | 1
  9 | text4 | 0
 10 | text0 | 1
 11 | text1 | 0
 12 | text2 | 1
 13 | text3 | 0
 14 | text4 | 1
 15 | text0 | 0
 16 | text1 | 1
 17 | text2 | 0
 18 | text3 | 1
 19 | text4 | 0
 20 | text0 | 1
 21 | text1 | 0
 22 | text2 | 1
 23 | text3 | 0
 24 | text4 | 1
 25 | text0 | 0
    |       |  
(26 rows)

SELECT sub_t.a, sub_t.b, sub_t.c FROM (SELECT a, b, c FROM test_table1 GROUP BY GROUPING SETS ((a), ()) ORDER BY a) AS sub_t 
GROUP BY GROUPING SETS ((sub_t.a, sub_t.b, sub_t.c), ()) ORDER BY sub_t.a;
 a  |   b   | c 
----+-------+---
  1 | text1 | 0
  2 | text2 | 1
  3 | text3 | 0
  4 | text4 | 1
  5 | text0 | 0
  6 | text1 | 1
  7 | text2 | 0
  8 | text3 | 1
  9 | text4 | 0
 10 | text0 | 1
 11 | text1 | 0
 12 | text2 | 1
 13 | text3 | 0
 14 | text4 | 1
 15 | text0 | 0
 16 | text1 | 1
 17 | text2 | 0
 18 | text3 | 1
 19 | text4 | 0
 20 | text0 | 1
 21 | text1 | 0
 22 | text2 | 1
 23 | text3 | 0
 24 | text4 | 1
 25 | text0 | 0
    |       |  
    |       |  
(27 rows)

SELECT (SELECT c) FROM test_table1 GROUP BY a ORDER BY a;
 c 
---
 0
 1
 0
 1
 0
 1
 0
 1
 0
 1
 0
 1
 0
 1
 0
 1
 0
 1
 0
 1
 0
 1
 0
 1
 0
(25 rows)

SELECT b, (SELECT c FROM (SELECT c) AS alias_test_table1) FROM test_table1 GROUP BY a ORDER BY a;
   b   | c 
-------+---
 text1 | 0
 text2 | 1
 text3 | 0
 text4 | 1
 text0 | 0
 text1 | 1
 text2 | 0
 text3 | 1
 text4 | 0
 text0 | 1
 text1 | 0
 text2 | 1
 text3 | 0
 text4 | 1
 text0 | 0
 text1 | 1
 text2 | 0
 text3 | 1
 text4 | 0
 text0 | 1
 text1 | 0
 text2 | 1
 text3 | 0
 text4 | 1
 text0 | 0
(25 rows)

-- Check cases with primary key consisting of more than 1 column
SELECT a, b, c FROM test_table2 GROUP BY a, c ORDER BY a, c;
 a |     b      | c  
---+------------+----
 1 | text|1|-1| | -1
 1 | text|1|1|  |  1
 2 | text|2|-1| | -1
 2 | text|2|1|  |  1
 3 | text|3|-1| | -1
 3 | text|3|1|  |  1
 4 | text|4|-1| | -1
 4 | text|4|1|  |  1
 5 | text|5|-1| | -1
 5 | text|5|1|  |  1
(10 rows)

SELECT a, b, c FROM test_table2 GROUP BY GROUPING SETS ((a, c), (a)) ORDER BY a, c;
 a |     b      | c  
---+------------+----
 1 | text|1|-1| | -1
 1 | text|1|1|  |  1
 1 |            |   
 2 | text|2|-1| | -1
 2 | text|2|1|  |  1
 2 |            |   
 3 | text|3|-1| | -1
 3 | text|3|1|  |  1
 3 |            |   
 4 | text|4|-1| | -1
 4 | text|4|1|  |  1
 4 |            |   
 5 | text|5|-1| | -1
 5 | text|5|1|  |  1
 5 |            |   
(15 rows)

SELECT grouping(a) AS g_a, grouping(c) AS g_c, count(*) AS cnt, a, b, c FROM test_table2 GROUP BY GROUPING SETS ((a, c), (a) ) ORDER BY a, c;
 g_a | g_c | cnt | a |     b      | c  
-----+-----+-----+---+------------+----
   0 |   0 |   1 | 1 | text|1|-1| | -1
   0 |   0 |   1 | 1 | text|1|1|  |  1
   0 |   1 |   2 | 1 |            |   
   0 |   0 |   1 | 2 | text|2|-1| | -1
   0 |   0 |   1 | 2 | text|2|1|  |  1
   0 |   1 |   2 | 2 |            |   
   0 |   0 |   1 | 3 | text|3|-1| | -1
   0 |   0 |   1 | 3 | text|3|1|  |  1
   0 |   1 |   2 | 3 |            |   
   0 |   0 |   1 | 4 | text|4|-1| | -1
   0 |   0 |   1 | 4 | text|4|1|  |  1
   0 |   1 |   2 | 4 |            |   
   0 |   0 |   1 | 5 | text|5|-1| | -1
   0 |   0 |   1 | 5 | text|5|1|  |  1
   0 |   1 |   2 | 5 |            |   
(15 rows)

SELECT grouping(a) AS g_a, grouping(c) AS g_c, a, b, c FROM test_table2 GROUP BY GROUPING SETS (a, c, (a, c) ) ORDER BY g_a, g_c, a, c;
 g_a | g_c | a |     b      | c  
-----+-----+---+------------+----
   0 |   0 | 1 | text|1|-1| | -1
   0 |   0 | 1 | text|1|1|  |  1
   0 |   0 | 2 | text|2|-1| | -1
   0 |   0 | 2 | text|2|1|  |  1
   0 |   0 | 3 | text|3|-1| | -1
   0 |   0 | 3 | text|3|1|  |  1
   0 |   0 | 4 | text|4|-1| | -1
   0 |   0 | 4 | text|4|1|  |  1
   0 |   0 | 5 | text|5|-1| | -1
   0 |   0 | 5 | text|5|1|  |  1
   0 |   1 | 1 |            |   
   0 |   1 | 2 |            |   
   0 |   1 | 3 |            |   
   0 |   1 | 4 |            |   
   0 |   1 | 5 |            |   
   1 |   0 |   |            | -1
   1 |   0 |   |            |  1
(17 rows)

SELECT grouping(a) AS g_a, grouping(c) AS g_c, a, b, c FROM test_table2 GROUP BY GROUPING SETS ((a, c) ) ORDER BY g_a, g_c, a, c;
 g_a | g_c | a |     b      | c  
-----+-----+---+------------+----
   0 |   0 | 1 | text|1|-1| | -1
   0 |   0 | 1 | text|1|1|  |  1
   0 |   0 | 2 | text|2|-1| | -1
   0 |   0 | 2 | text|2|1|  |  1
   0 |   0 | 3 | text|3|-1| | -1
   0 |   0 | 3 | text|3|1|  |  1
   0 |   0 | 4 | text|4|-1| | -1
   0 |   0 | 4 | text|4|1|  |  1
   0 |   0 | 5 | text|5|-1| | -1
   0 |   0 | 5 | text|5|1|  |  1
(10 rows)

-- Check cases with join and grouping by primary key of one of the tables
SELECT l.a, l.b, count(r.b) AS cnt FROM test_table1 AS l JOIN test_table2 AS r ON l.a=r.a GROUP BY l.a ORDER BY l.a;
 a |   b   | cnt 
---+-------+-----
 1 | text1 |   2
 2 | text2 |   2
 3 | text3 |   2
 4 | text4 |   2
 5 | text0 |   2
(5 rows)

-- Plus check expressions with aggregate functions 
SELECT l.a, l.b, count(r.b) + avg(r.a) AS agg_expr FROM test_table1 AS l JOIN test_table2 AS r ON l.a=r.a GROUP BY l.a ORDER BY l.a;
 a |   b   |        agg_expr        
---+-------+------------------------
 1 | text1 | 3.00000000000000000000
 2 | text2 |     4.0000000000000000
 3 | text3 |     5.0000000000000000
 4 | text4 |     6.0000000000000000
 5 | text0 |     7.0000000000000000
(5 rows)

SELECT l.a, l.b, count(r.b) + avg(l.a) AS agg_expr FROM test_table1 AS l JOIN test_table2 AS r ON l.a=r.a GROUP BY l.a ORDER BY l.a;
 a |   b   |        agg_expr        
---+-------+------------------------
 1 | text1 | 3.00000000000000000000
 2 | text2 |     4.0000000000000000
 3 | text3 |     5.0000000000000000
 4 | text4 |     6.0000000000000000
 5 | text0 |     7.0000000000000000
(5 rows)

SELECT l.a, l.b, count(r.b) + avg(l.c) AS agg_expr FROM test_table1 AS l JOIN test_table2 AS r ON l.a=r.a GROUP BY l.a ORDER BY l.a;
 a |   b   |        agg_expr        
---+-------+------------------------
 1 | text1 | 2.00000000000000000000
 2 | text2 | 3.00000000000000000000
 3 | text3 | 2.00000000000000000000
 4 | text4 | 3.00000000000000000000
 5 | text0 | 2.00000000000000000000
(5 rows)

SELECT l.a, l.b, count(r.b) + avg(r.a) AS agg_expr FROM test_table1 AS l JOIN test_table2 AS r ON l.a=r.a GROUP BY l.a ORDER BY l.a;
 a |   b   |        agg_expr        
---+-------+------------------------
 1 | text1 | 3.00000000000000000000
 2 | text2 |     4.0000000000000000
 3 | text3 |     5.0000000000000000
 4 | text4 |     6.0000000000000000
 5 | text0 |     7.0000000000000000
(5 rows)

-- Plus check aggregate functions with expression as parameters
SELECT l.a, l.b, avg(r.a + l.c) AS agg_expr FROM test_table1 AS l JOIN test_table2 AS r ON l.a=r.a GROUP BY l.a ORDER BY l.a;
 a |   b   |        agg_expr        
---+-------+------------------------
 1 | text1 | 1.00000000000000000000
 2 | text2 |     3.0000000000000000
 3 | text3 |     3.0000000000000000
 4 | text4 |     5.0000000000000000
 5 | text0 |     5.0000000000000000
(5 rows)

SELECT l.a, l.b, avg(r.a + r.c) AS agg_expr FROM test_table1 AS l JOIN test_table2 AS r ON l.a=r.a GROUP BY l.a ORDER BY l.a;
 a |   b   |        agg_expr        
---+-------+------------------------
 1 | text1 | 1.00000000000000000000
 2 | text2 |     2.0000000000000000
 3 | text3 |     3.0000000000000000
 4 | text4 |     4.0000000000000000
 5 | text0 |     5.0000000000000000
(5 rows)

SELECT l.a, l.b, avg(l.a + l.c) AS agg_expr FROM test_table1 AS l JOIN test_table2 AS r ON l.a=r.a GROUP BY l.a ORDER BY l.a;
 a |   b   |        agg_expr        
---+-------+------------------------
 1 | text1 | 1.00000000000000000000
 2 | text2 |     3.0000000000000000
 3 | text3 |     3.0000000000000000
 4 | text4 |     5.0000000000000000
 5 | text0 |     5.0000000000000000
(5 rows)

-- Plus check both cases above together
SELECT l.a, l.b, avg(r.a + l.c) + count(r.b) AS agg_expr FROM test_table1 AS l JOIN test_table2 AS r ON l.a=r.a GROUP BY l.a ORDER BY l.a;
 a |   b   |        agg_expr        
---+-------+------------------------
 1 | text1 | 3.00000000000000000000
 2 | text2 |     5.0000000000000000
 3 | text3 |     5.0000000000000000
 4 | text4 |     7.0000000000000000
 5 | text0 |     7.0000000000000000
(5 rows)

-- Check cases with join of 2 tables on their primary key
SELECT l.a, l.b, r.a, r.b FROM test_table1 AS l JOIN test_table3 AS r ON l.a=r.a GROUP BY l.a, r.a ORDER BY l.a;
 a  |   b   | a  |    b     
----+-------+----+----------
  1 | text1 |  1 | t3-text1
  2 | text2 |  2 | t3-text2
  3 | text3 |  3 | t3-text3
  4 | text4 |  4 | t3-text4
  5 | text0 |  5 | t3-text0
  6 | text1 |  6 | t3-text1
  7 | text2 |  7 | t3-text2
  8 | text3 |  8 | t3-text3
  9 | text4 |  9 | t3-text4
 10 | text0 | 10 | t3-text0
(10 rows)

SELECT grouping(l.a) AS g_l_a, grouping(r.a) AS g_r_a, grouping(r.c) AS g_r_c, l.a, l.b, r.a, r.b, r.c
	FROM test_table1 AS l JOIN test_table3 AS r ON l.a=r.a GROUP BY GROUPING SETS ((l.a, r.a), (r.c), ()) ORDER BY l.a, r.c;
 g_l_a | g_r_a | g_r_c | a  |   b   | a  |    b     | c 
-------+-------+-------+----+-------+----+----------+---
     0 |     0 |     1 |  1 | text1 |  1 | t3-text1 |  
     0 |     0 |     1 |  2 | text2 |  2 | t3-text2 |  
     0 |     0 |     1 |  3 | text3 |  3 | t3-text3 |  
     0 |     0 |     1 |  4 | text4 |  4 | t3-text4 |  
     0 |     0 |     1 |  5 | text0 |  5 | t3-text0 |  
     0 |     0 |     1 |  6 | text1 |  6 | t3-text1 |  
     0 |     0 |     1 |  7 | text2 |  7 | t3-text2 |  
     0 |     0 |     1 |  8 | text3 |  8 | t3-text3 |  
     0 |     0 |     1 |  9 | text4 |  9 | t3-text4 |  
     0 |     0 |     1 | 10 | text0 | 10 | t3-text0 |  
     1 |     1 |     0 |    |       |    |          | 0
     1 |     1 |     0 |    |       |    |          | 1
     1 |     1 |     1 |    |       |    |          |  
(13 rows)

DROP TABLE test_table1;
DROP TABLE test_table2;
DROP TABLE test_table3;
RESET optimizer_trace_fallback;
RESET optimizer;
