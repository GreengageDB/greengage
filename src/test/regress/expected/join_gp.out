-- Extra GPDB tests for joins.
-- Ignore "workfile compresssion is not supported by this build" (see
-- 'zlib' test):
--
-- start_matchignore
-- m/ERROR:  workfile compresssion is not supported by this build/
-- end_matchignore
--
-- test numeric hash join
--
set enable_hashjoin to on;
set enable_mergejoin to off;
set enable_nestloop to off;
create table nhtest (i numeric(10, 2)) distributed by (i);
insert into nhtest values(100000.22);
insert into nhtest values(300000.19);
explain select * from nhtest a join nhtest b using (i);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=1.02..2.07 rows=2 width=11)
   ->  Hash Join  (cost=1.02..2.07 rows=2 width=11)
         Hash Cond: (a.i = b.i)
         ->  Seq Scan on nhtest a  (cost=0.00..1.01 rows=1 width=11)
         ->  Hash  (cost=1.01..1.01 rows=1 width=11)
               ->  Seq Scan on nhtest b  (cost=0.00..1.01 rows=1 width=11)
 Settings:  enable_hashjoin=on; enable_mergejoin=off; enable_nestloop=off
(7 rows)

select * from nhtest a join nhtest b using (i);
     i     
-----------
 300000.19
 100000.22
(2 rows)

create temp table l(a int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into l values (1), (1), (2);
select * from l l1 join l l2 on l1.a = l2.a left join l l3 on l1.a = l3.a and l1.a = 2 order by 1,2,3;
 a | a | a 
---+---+---
 1 | 1 |  
 1 | 1 |  
 1 | 1 |  
 1 | 1 |  
 2 | 2 | 2
(5 rows)

--
-- test hash join
--
create table hjtest (i int, j int) distributed by (i,j);
insert into hjtest values(3, 4);
select count(*) from hjtest a1, hjtest a2 where a2.i = least (a1.i,4) and a2.j = 4;
 count 
-------
     1
(1 row)

drop table hjtest;
--
-- Test for correct behavior when there is a Merge Join on top of Materialize
-- on top of a Motion :
-- 1. Use FULL OUTER JOIN to induce a Merge Join
-- 2. Use a large tuple size to induce a Materialize
-- 3. Use gp_dist_random() to induce a Redistribute
--
set enable_hashjoin to off;
set enable_mergejoin to on;
set enable_nestloop to off;
DROP TABLE IF EXISTS alpha;
DROP TABLE IF EXISTS theta;
CREATE TABLE alpha (i int, j int) distributed by (i);
CREATE TABLE theta (i int, j char(10000000)) distributed by (i);
INSERT INTO alpha values (1, 1), (2, 2);
INSERT INTO theta values (1, 'f'), (2, 'g');
SELECT *
FROM gp_dist_random('alpha') FULL OUTER JOIN gp_dist_random('theta')
  ON (alpha.i = theta.i)
WHERE (alpha.j IS NULL or theta.j IS NULL);
 i | j | i | j 
---+---+---+---
(0 rows)

reset enable_hashjoin;
reset enable_mergejoin;
reset enable_nestloop;
--
-- Predicate propagation over equality conditions
--
drop schema if exists pred;
NOTICE:  schema "pred" does not exist, skipping
create schema pred;
set search_path=pred;
create table t1 (x int, y int, z int) distributed by (y);
create table t2 (x int, y int, z int) distributed by (x);
insert into t1 select i, i, i from generate_series(1,100) i;
insert into t2 select * from t1;
analyze t1;
analyze t2;
--
-- infer over equalities
--
explain select count(*) from t1,t2 where t1.x = 100 and t1.x = t2.x;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Aggregate  (cost=6.60..6.61 rows=1 width=8)
   ->  Gather Motion 3:1  (slice2; segments: 3)  (cost=6.54..6.58 rows=1 width=8)
         ->  Aggregate  (cost=6.54..6.55 rows=1 width=8)
               ->  Nested Loop  (cost=0.00..6.53 rows=2 width=0)
                     ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..3.27 rows=1 width=4)
                           Hash Key: t1.x
                           ->  Seq Scan on t1  (cost=0.00..3.25 rows=1 width=4)
                                 Filter: (x = 100)
                     ->  Seq Scan on t2  (cost=0.00..3.25 rows=1 width=4)
                           Filter: (x = 100)
 Settings:  enable_hashjoin=on; enable_mergejoin=off; enable_nestloop=off
(11 rows)

select count(*) from t1,t2 where t1.x = 100 and t1.x = t2.x;
 count 
-------
     1
(1 row)

--
-- infer over >=
--
explain select * from t1,t2 where t1.x = 100 and t2.x >= t1.x;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=3.28..6.58 rows=2 width=24)
   ->  Nested Loop  (cost=3.28..6.58 rows=2 width=24)
         Join Filter: (t2.x >= t1.x)
         ->  Seq Scan on t1  (cost=0.00..3.25 rows=1 width=12)
               Filter: (x = 100)
         ->  Materialize  (cost=3.28..3.30 rows=1 width=12)
               ->  Broadcast Motion 3:3  (slice1; segments: 3)  (cost=0.00..3.28 rows=1 width=12)
                     ->  Seq Scan on t2  (cost=0.00..3.25 rows=1 width=12)
                           Filter: (x >= 100)
 Settings:  enable_hashjoin=on; enable_mergejoin=off; enable_nestloop=off
(10 rows)

select * from t1,t2 where t1.x = 100 and t2.x >= t1.x;
  x  |  y  |  z  |  x  |  y  |  z  
-----+-----+-----+-----+-----+-----
 100 | 100 | 100 | 100 | 100 | 100
(1 row)

--
-- multiple inferences
--
set optimizer_segments=2;
explain select * from t1,t2 where t1.x = 100 and t1.x = t2.y and t1.x <= t2.x;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.00..9.14 rows=4 width=24)
   ->  Nested Loop  (cost=0.00..9.14 rows=2 width=24)
         Join Filter: (t1.x <= t2.x)
         ->  Seq Scan on t1  (cost=0.00..4.25 rows=1 width=12)
               Filter: x = 100
         ->  Materialize  (cost=0.00..4.85 rows=1 width=12)
               ->  Broadcast Motion 3:3  (slice1; segments: 3)  (cost=0.00..4.79 rows=1 width=12)
                     ->  Seq Scan on t2  (cost=0.00..4.75 rows=1 width=12)
                           Filter: ((100 <= x) AND (y <= x) AND (y = 100))
 Settings:  optimizer=off; optimizer_segments=2
 Optimizer status: Postgres query optimizer
(11 rows)

reset optimizer_segments;
select * from t1,t2 where t1.x = 100 and t1.x = t2.y and t1.x <= t2.x;
  x  |  y  |  z  |  x  |  y  |  z  
-----+-----+-----+-----+-----+-----
 100 | 100 | 100 | 100 | 100 | 100
(1 row)

--
-- MPP-18537: hash clause references a constant in outer child target list
--
create table hjn_test (i int, j int) distributed by (i,j);
insert into hjn_test values(3, 4);
create table int4_tbl (f1 int) distributed by (f1);
insert into int4_tbl values(123456), (-2147483647), (0), (-123456), (2147483647);
select count(*) from hjn_test, (select 3 as bar) foo where hjn_test.i = least (foo.bar,4) and hjn_test.j = 4;
 count 
-------
     1
(1 row)

select count(*) from hjn_test, (select 3 as bar) foo where hjn_test.i = least (foo.bar,(array[4])[1]) and hjn_test.j = (array[4])[1];
 count 
-------
     1
(1 row)

select count(*) from hjn_test, (select 3 as bar) foo where least (foo.bar,(array[4])[1]) = hjn_test.i and hjn_test.j = (array[4])[1];
 count 
-------
     1
(1 row)

select count(*) from hjn_test, (select 3 as bar) foo where hjn_test.i = least (foo.bar, least(4,10)) and hjn_test.j = least(4,10);
 count 
-------
     1
(1 row)

select * from int4_tbl a join int4_tbl b on (a.f1 = (select f1 from int4_tbl c where c.f1=b.f1));
     f1      |     f1      
-------------+-------------
 -2147483647 | -2147483647
      123456 |      123456
     -123456 |     -123456
           0 |           0
  2147483647 |  2147483647
(5 rows)

-- Same as the last query, but with a partitioned table (which requires a
-- Result node to do projection of the hash expression, as Append is not
-- projection-capable)
create table part4_tbl (f1 int4) partition by range (f1) (start(-1000000) end (1000000) every (1000000));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'f1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "part4_tbl_1_prt_1" for table "part4_tbl"
NOTICE:  CREATE TABLE will create partition "part4_tbl_1_prt_2" for table "part4_tbl"
insert into part4_tbl values
       (-123457), (-123456), (-123455),
       (-1), (0), (1),
       (123455), (123456), (123457);
select * from part4_tbl a join part4_tbl b on (a.f1 = (select f1 from int4_tbl c where c.f1=b.f1));
   f1    |   f1    
---------+---------
  123456 |  123456
 -123456 | -123456
       0 |       0
(3 rows)

--
-- Test case where a Motion hash key is only needed for the redistribution,
-- and not returned in the final result set. There was a bug at one point where
-- tjoin.c1 was used as the hash key in a Motion node, but it was not added
-- to the sub-plans target list, causing a "variable not found in subplan
-- target list" error.
--
create table tjoin1(dk integer, id integer) distributed by (dk);
create table tjoin2(dk integer, id integer, t text) distributed by (dk);
create table tjoin3(dk integer, id integer, t text) distributed by (dk);
insert into tjoin1 values (1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3);
insert into tjoin2 values (1, 1, '1-1'), (1, 2, '1-2'), (2, 1, '2-1'), (2, 2, '2-2');
insert into tjoin3 values (1, 1, '1-1'), (2, 1, '2-1');
select tjoin1.id, tjoin2.t, tjoin3.t
from tjoin1
left outer join (tjoin2 left outer join tjoin3 on tjoin2.id=tjoin3.id) on tjoin1.id=tjoin3.id;
 id |  t  |  t  
----+-----+-----
  1 | 2-1 | 2-1
  1 | 2-1 | 1-1
  1 | 1-1 | 2-1
  1 | 1-1 | 1-1
  3 |     | 
  1 | 2-1 | 2-1
  1 | 2-1 | 1-1
  1 | 1-1 | 2-1
  1 | 1-1 | 1-1
  3 |     | 
  2 |     | 
  2 |     | 
(12 rows)

set enable_hashjoin to off;
set optimizer_enable_hashjoin = off;
select count(*) from hjn_test, (select 3 as bar) foo where hjn_test.i = least (foo.bar,4) and hjn_test.j = 4;
 count 
-------
     1
(1 row)

select count(*) from hjn_test, (select 3 as bar) foo where hjn_test.i = least (foo.bar,(array[4])[1]) and hjn_test.j = (array[4])[1];
 count 
-------
     1
(1 row)

select count(*) from hjn_test, (select 3 as bar) foo where least (foo.bar,(array[4])[1]) = hjn_test.i and hjn_test.j = (array[4])[1];
 count 
-------
     1
(1 row)

select count(*) from hjn_test, (select 3 as bar) foo where hjn_test.i = least (foo.bar, least(4,10)) and hjn_test.j = least(4,10);
 count 
-------
     1
(1 row)

select * from int4_tbl a join int4_tbl b on (a.f1 = (select f1 from int4_tbl c where c.f1=b.f1));
     f1      |     f1      
-------------+-------------
 -2147483647 | -2147483647
      123456 |      123456
     -123456 |     -123456
           0 |           0
  2147483647 |  2147483647
(5 rows)

reset enable_hashjoin;
reset optimizer_enable_hashjoin;
-- In case of Left Anti Semi Join, if the left rel is empty a dummy join
-- should be created
drop table if exists foo;
NOTICE:  table "foo" does not exist, skipping
drop table if exists bar;
NOTICE:  table "bar" does not exist, skipping
create table foo (a int, b int) distributed randomly;
create table bar (c int, d int) distributed randomly;
insert into foo select generate_series(1,10);
insert into bar select generate_series(1,10);
explain select a from foo where a<1 and a>1 and not exists (select c from bar where c=a);
                QUERY PLAN
------------------------------------------
 Result  (cost=0.00..0.01 rows=1 width=0)
   One-Time Filter: false
 Optimizer status: Postgres query optimizer
(3 rows)

select a from foo where a<1 and a>1 and not exists (select c from bar where c=a);
 a 
---
(0 rows)

-- The merge join executor code doesn't support LASJ_NOTIN joins. Make sure
-- the planner doesn't create an invalid plan with them.
create index index_foo on foo (a);
create index index_bar on bar (c);
set enable_nestloop to off;
set enable_hashjoin to off;
set enable_mergejoin to on;
select * from foo where a not in (select c from bar where c <= 5);
 a  | b 
----+---
  6 |  
  7 |  
  8 |  
  9 |  
 10 |  
(5 rows)

set enable_nestloop to off;
set enable_hashjoin to on;
set enable_mergejoin to off;
create table dept
(
	id int,
	pid int,
	name char(40)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into dept values(3, 0, 'root');
insert into dept values(4, 3, '2<-1');
insert into dept values(5, 4, '3<-2<-1');
insert into dept values(6, 4, '4<-2<-1');
insert into dept values(7, 3, '5<-1');
insert into dept values(8, 7, '5<-1');
insert into dept select i, i % 6 + 3 from generate_series(9,50) as i;
insert into dept select i, 99 from generate_series(100,15000) as i;
ANALYZE dept;
-- Test rescannable hashjoin with spilling hashtable
set statement_mem='1000kB';
set gp_workfile_compression = off;
WITH RECURSIVE subdept(id, parent_department, name) AS
(
	-- non recursive term
	SELECT * FROM dept WHERE name = 'root'
	UNION ALL
	-- recursive term
	SELECT d.* FROM dept AS d, subdept AS sd
		WHERE d.pid = sd.id
)
SELECT count(*) FROM subdept;
 count 
-------
    48
(1 row)

-- Test rescannable hashjoin with spilling hashtable, with compression
set gp_workfile_compression = on;
WITH RECURSIVE subdept(id, parent_department, name) AS
(
	-- non recursive term
	SELECT * FROM dept WHERE name = 'root'
	UNION ALL
	-- recursive term
	SELECT d.* FROM dept AS d, subdept AS sd
		WHERE d.pid = sd.id
)
SELECT count(*) FROM subdept;
 count 
-------
    48
(1 row)

-- Test rescannable hashjoin with in-memory hashtable
reset statement_mem;
WITH RECURSIVE subdept(id, parent_department, name) AS
(
	-- non recursive term
	SELECT * FROM dept WHERE name = 'root'
	UNION ALL
	-- recursive term
	SELECT d.* FROM dept AS d, subdept AS sd
		WHERE d.pid = sd.id
)
SELECT count(*) FROM subdept;
 count 
-------
    48
(1 row)

-- MPP-29458
-- When we join on a clause with two different types. If one table distribute by one type, the query plan
-- will redistribute data on another type. But the has values of two types would not be equal. The data will
-- redistribute to wrong segments.
create table test_timestamp_t1 (id  numeric(10,0) ,field_dt date) distributed by (id);
create table test_timestamp_t2 (id numeric(10,0),field_tms timestamp without time zone) distributed by (id,field_tms);
insert into test_timestamp_t1 values(10 ,'2018-1-10');
insert into test_timestamp_t1 values(11 ,'2018-1-11');
insert into test_timestamp_t2 values(10 ,'2018-1-10'::timestamp);
insert into test_timestamp_t2 values(11 ,'2018-1-11'::timestamp);
-- Test nest loop redistribute keys
set enable_nestloop to on;
set enable_hashjoin to on;
set enable_mergejoin to on;
select count(*) from test_timestamp_t1 t1 ,test_timestamp_t2 t2 where T1.id = T2.id and T1.field_dt = t2.field_tms;
 count 
-------
     2
(1 row)

-- Test hash join redistribute keys
set enable_nestloop to off;
set enable_hashjoin to on;
set enable_mergejoin to on;
select count(*) from test_timestamp_t1 t1 ,test_timestamp_t2 t2 where T1.id = T2.id and T1.field_dt = t2.field_tms;
 count 
-------
     2
(1 row)

drop table test_timestamp_t1;
drop table test_timestamp_t2;
-- Test merge join redistribute keys
create table test_timestamp_t1 (id  numeric(10,0) ,field_dt date) distributed randomly;
create table test_timestamp_t2 (id numeric(10,0),field_tms timestamp without time zone) distributed by (field_tms);
insert into test_timestamp_t1 values(10 ,'2018-1-10');
insert into test_timestamp_t1 values(11 ,'2018-1-11');
insert into test_timestamp_t2 values(10 ,'2018-1-10'::timestamp);
insert into test_timestamp_t2 values(11 ,'2018-1-11'::timestamp);
select * from test_timestamp_t1 t1 full outer join test_timestamp_t2 t2 on T1.id = T2.id and T1.field_dt = t2.field_tms;
 id |  field_dt  | id |        field_tms         
----+------------+----+--------------------------
 10 | 01-10-2018 | 10 | Wed Jan 10 00:00:00 2018
 11 | 01-11-2018 | 11 | Thu Jan 11 00:00:00 2018
(2 rows)

-- test float type
set enable_nestloop to off;
set enable_hashjoin to on;
set enable_mergejoin to on;
create table test_float1(id int, data float4)  DISTRIBUTED BY (data);
create table test_float2(id int, data float8)  DISTRIBUTED BY (data);
insert into test_float1 values(1, 10), (2, 20);
insert into test_float2 values(3, 10), (4, 20);
select t1.id, t1.data, t2.id, t2.data from test_float1 t1, test_float2 t2 where t1.data = t2.data;
 id | data | id | data 
----+------+----+------
  2 |   20 |  4 |   20
  1 |   10 |  3 |   10
(2 rows)

-- test int type
create table test_int1(id int, data int4)  DISTRIBUTED BY (data);
create table test_int2(id int, data int8)  DISTRIBUTED BY (data);
insert into test_int1 values(1, 10), (2, 20);
insert into test_int2 values(3, 10), (4, 20);
select t1.id, t1.data, t2.id, t2.data from test_int1 t1, test_int2 t2 where t1.data = t2.data;
 id | data | id | data 
----+------+----+------
  1 |   10 |  3 |   10
  2 |   20 |  4 |   20
(2 rows)

-- Test to ensure that for full outer join on varchar columns, planner is successful in finding a sort operator in the catalog
create table input_table(a varchar(30), b varchar(30)) distributed by (a);
set enable_hashjoin = off;
explain (costs off) select X.a from input_table X full join (select a from input_table) Y ON X.a = Y.a;
                        QUERY PLAN                         
-----------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Full Join
         Merge Cond: ((x.a)::text = (input_table.a)::text)
         ->  Sort
               Sort Key: x.a
               ->  Seq Scan on input_table x
         ->  Sort
               Sort Key: input_table.a
               ->  Seq Scan on input_table
 Optimizer: Postgres query optimizer
(10 rows)

-- Cleanup
reset enable_hashjoin;
set client_min_messages='warning'; -- silence drop-cascade NOTICEs
drop schema pred cascade;
reset search_path;
-- github issue 5370 cases
drop table if exists t5370;
NOTICE:  table "t5370" does not exist, skipping
drop table if exists t5370_2;
NOTICE:  table "t5370_2" does not exist, skipping
create table t5370(id int,name text) distributed by(id);
insert into t5370 select i,i from  generate_series(1,1000) i;
create table t5370_2 as select * from t5370 distributed by (id);
analyze t5370_2;
analyze t5370;
explain select * from t5370 a , t5370_2 b where a.name=b.name;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice3; segments: 3)  (cost=45.50..92.25 rows=1000 width=14)
   ->  Hash Join  (cost=45.50..92.25 rows=334 width=14)
         Hash Cond: (a.name = b.name)
         ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..33.00 rows=334 width=7)
               Hash Key: a.name
               ->  Seq Scan on t5370 a  (cost=0.00..13.00 rows=334 width=7)
         ->  Hash  (cost=33.00..33.00 rows=334 width=7)
               ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..33.00 rows=334 width=7)
                     Hash Key: b.name
                     ->  Seq Scan on t5370_2 b  (cost=0.00..13.00 rows=334 width=7)
 Optimizer: Postgres query optimizer
(11 rows)

drop table t5370;
drop table t5370_2;
-- github issue 6215 cases
-- When executing the following plan
-- ```
--  Gather Motion 1:1  (slice1; segments: 1)
--    ->  Merge Full Join
--         ->  Seq Scan on int4_tbl a
--         ->  Seq Scan on int4_tbl b
--```
-- Greenplum will raise an Assert Fail.
-- We force adding a material node for
-- merge full join on true.
drop table if exists t6215;
create table t6215(f1 int4) distributed replicated;
insert into t6215(f1) values (1), (2), (3);
set enable_material = off;
-- The plan still have Material operator
explain (costs off) select * from t6215 a full join t6215 b on true;
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Merge Full Join
         ->  Seq Scan on t6215 a
         ->  Materialize
               ->  Seq Scan on t6215 b
 Optimizer: Postgres query optimizer
(6 rows)

select * from t6215 a full join t6215 b on true;
 f1 | f1 
----+----
  1 |  1
  1 |  2
  1 |  3
  2 |  1
  2 |  2
  2 |  3
  3 |  1
  3 |  2
  3 |  3
(9 rows)

drop table t6215;
--
-- This tripped an assertion while deciding the locus for the joins.
-- The code was failing to handle join between SingleQE and Hash correctly,
-- when there were join order restricitions. (see
-- https://github.com/greenplum-db/gpdb/issues/6643
--
select a.f1, b.f1, t.thousand, t.tenthous from
  (select sum(f1) as f1 from int4_tbl i4b) b
   left outer join
     (select sum(f1)+1 as f1 from int4_tbl i4a) a ON a.f1 = b.f1
      left outer join
        tenk1 t ON b.f1 = t.thousand and (a.f1+b.f1+999) = t.tenthous;
 f1 | f1 | thousand | tenthous 
----+----+----------+----------
    |  0 |          |         
(1 row)

-- tests to ensure that join reordering of LOJs and inner joins produces the
-- correct join predicates & residual filters
drop table if exists t1, t2, t3;
CREATE TABLE t1 (a int, b int, c int);
CREATE TABLE t2 (a int, b int, c int);
CREATE TABLE t3 (a int, b int, c int);
INSERT INTO t1 SELECT i, i, i FROM generate_series(1, 1000) i;
INSERT INTO t2 SELECT i, i, i FROM generate_series(2, 1000) i; -- start from 2 so that one row from t1 doesn't match
INSERT INTO t3 VALUES (1, 2, 3), (NULL, 2, 2);
ANALYZE t1;
ANALYZE t2;
ANALYZE t3;
-- ensure plan has a filter over left outer join
explain (costs off) select * from t1 left join t2 on (t1.a = t2.a) join t3 on (t1.b = t3.b) where (t2.a IS NULL OR (t1.c = t3.c));
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)
   ->  Hash Right Join
         Hash Cond: (t2.a = t1.a)
         Filter: ((t2.a IS NULL) OR (t1.c = t3.c))
         ->  Seq Scan on t2
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t1.b = t3.b)
                     ->  Seq Scan on t1
                     ->  Hash
                           ->  Broadcast Motion 3:3  (slice1; segments: 3)
                                 ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(13 rows)

select * from t1 left join t2 on (t1.a = t2.a) join t3 on (t1.b = t3.b) where (t2.a IS NULL OR (t1.c = t3.c));
 a | b | c | a | b | c | a | b | c 
---+---+---+---+---+---+---+---+---
 2 | 2 | 2 | 2 | 2 | 2 |   | 2 | 2
(1 row)

-- ensure plan has two inner joins with the where clause & join predicates ANDed
explain (costs off) select * from t1 left join t2 on (t1.a = t2.a) join t3 on (t1.b = t3.b) where (t2.a = t3.a);
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ((t1.a = t2.a) AND (t1.b = t3.b))
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.a = t3.a)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(11 rows)

select * from t1 left join t2 on (t1.a = t2.a) join t3 on (t1.b = t3.b) where (t2.a = t3.a);
 a | b | c | a | b | c | a | b | c 
---+---+---+---+---+---+---+---+---
(0 rows)

-- ensure plan has a filter over left outer join
explain (costs off) select * from t1 left join t2 on (t1.a = t2.a) join t3 on (t1.b = t3.b) where (t2.a is distinct from t3.a);
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)
   ->  Hash Right Join
         Hash Cond: (t2.a = t1.a)
         Filter: (t2.a IS DISTINCT FROM t3.a)
         ->  Seq Scan on t2
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t1.b = t3.b)
                     ->  Seq Scan on t1
                     ->  Hash
                           ->  Broadcast Motion 3:3  (slice1; segments: 3)
                                 ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(13 rows)

select * from t1 left join t2 on (t1.a = t2.a) join t3 on (t1.b = t3.b) where (t2.a is distinct from t3.a);
 a | b | c | a | b | c | a | b | c 
---+---+---+---+---+---+---+---+---
 2 | 2 | 2 | 2 | 2 | 2 |   | 2 | 2
 2 | 2 | 2 | 2 | 2 | 2 | 1 | 2 | 3
(2 rows)

-- ensure plan has a filter over left outer join
explain select * from t3 join (select t1.a t1a, t1.b t1b, t1.c t1c, t2.a t2a, t2.b t2b, t2.c t2c from t1 left join t2 on (t1.a = t2.a)) t on (t1a = t3.a) WHERE (t2a IS NULL OR (t1c = t3.a));
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=20.27..37.13 rows=10 width=36)
   ->  Hash Right Join  (cost=20.27..37.13 rows=4 width=36)
         Hash Cond: (t2.a = t1.a)
         Filter: ((t2.a IS NULL) OR (t1.c = t3.a))
         ->  Seq Scan on t2  (cost=0.00..12.99 rows=333 width=12)
         ->  Hash  (cost=20.14..20.14 rows=4 width=24)
               ->  Hash Join  (cost=2.04..20.14 rows=4 width=24)
                     Hash Cond: (t1.a = t3.a)
                     ->  Seq Scan on t1  (cost=0.00..13.00 rows=334 width=12)
                     ->  Hash  (cost=2.02..2.02 rows=1 width=12)
                           ->  Seq Scan on t3  (cost=0.00..2.02 rows=1 width=12)
 Optimizer: Postgres query optimizer
(12 rows)

select * from t3 join (select t1.a t1a, t1.b t1b, t1.c t1c, t2.a t2a, t2.b t2b, t2.c t2c from t1 left join t2 on (t1.a = t2.a)) t on (t1a = t3.a) WHERE (t2a IS NULL OR (t1c = t3.a));
 a | b | c | t1a | t1b | t1c | t2a | t2b | t2c 
---+---+---+-----+-----+-----+-----+-----+-----
 1 | 2 | 3 |   1 |   1 |   1 |     |     |    
(1 row)

-- ensure plan has a filter over left outer join
explain select * from (select t1.a t1a, t1.b t1b, t2.a t2a, t2.b t2b from t1 left join t2 on t1.a = t2.a) tt 
  join t3 on tt.t1b = t3.b 
  join (select t1.a t1a, t1.b t1b, t2.a t2a, t2.b t2b from t1 left join t2 on t1.a = t2.a) tt1 on tt1.t1b = t3.b 
  join t3 t3_1 on tt1.t1b = t3_1.b and (tt1.t2a is NULL OR tt1.t1b = t3.b);
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice4; segments: 3)  (cost=61.48..78.25 rows=4 width=56)
   ->  Hash Right Join  (cost=61.48..78.25 rows=2 width=56)
         Hash Cond: (t2_1.a = t1_1.a)
         Filter: ((t2_1.a IS NULL) OR (t1_1.b = t3.b))
         ->  Seq Scan on t2 t2_1  (cost=0.00..12.99 rows=333 width=8)
         ->  Hash  (cost=61.43..61.43 rows=2 width=48)
               ->  Hash Join  (cost=44.65..61.43 rows=2 width=48)
                     Hash Cond: (t1_1.b = t1.b)
                     ->  Seq Scan on t1 t1_1  (cost=0.00..13.00 rows=334 width=8)
                     ->  Hash  (cost=44.53..44.53 rows=4 width=40)
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)  (cost=27.62..44.53 rows=4 width=40)
                                 ->  Hash Right Join  (cost=27.62..44.39 rows=2 width=40)
                                       Hash Cond: (t2.a = t1.a)
                                       ->  Seq Scan on t2  (cost=0.00..12.99 rows=333 width=8)
                                       ->  Hash  (cost=27.58..27.58 rows=2 width=32)
                                             ->  Hash Join  (cost=4.35..27.58 rows=2 width=32)
                                                   Hash Cond: (t1.b = t3_1.b)
                                                   ->  Hash Join  (cost=2.18..25.27 rows=4 width=20)
                                                         Hash Cond: (t1.b = t3.b)
                                                         ->  Seq Scan on t1  (cost=0.00..13.00 rows=334 width=8)
                                                         ->  Hash  (cost=2.10..2.10 rows=2 width=12)
                                                               ->  Broadcast Motion 3:3  (slice1; segments: 3)  (cost=0.00..2.10 rows=2 width=12)
                                                                     ->  Seq Scan on t3  (cost=0.00..2.02 rows=1 width=12)
                                                   ->  Hash  (cost=2.10..2.10 rows=2 width=12)
                                                         ->  Broadcast Motion 3:3  (slice2; segments: 3)  (cost=0.00..2.10 rows=2 width=12)
                                                               ->  Seq Scan on t3 t3_1  (cost=0.00..2.02 rows=1 width=12)
 Optimizer: Postgres query optimizer
(27 rows)

select * from (select t1.a t1a, t1.b t1b, t2.a t2a, t2.b t2b from t1 left join t2 on t1.a = t2.a) tt 
  join t3 on tt.t1b = t3.b 
  join (select t1.a t1a, t1.b t1b, t2.a t2a, t2.b t2b from t1 left join t2 on t1.a = t2.a) tt1 on tt1.t1b = t3.b 
  join t3 t3_1 on tt1.t1b = t3_1.b and (tt1.t2a is NULL OR tt1.t1b = t3.b);
 t1a | t1b | t2a | t2b | a | b | c | t1a | t1b | t2a | t2b | a | b | c 
-----+-----+-----+-----+---+---+---+-----+-----+-----+-----+---+---+---
   2 |   2 |   2 |   2 |   | 2 | 2 |   2 |   2 |   2 |   2 |   | 2 | 2
   2 |   2 |   2 |   2 |   | 2 | 2 |   2 |   2 |   2 |   2 | 1 | 2 | 3
   2 |   2 |   2 |   2 | 1 | 2 | 3 |   2 |   2 |   2 |   2 |   | 2 | 2
   2 |   2 |   2 |   2 | 1 | 2 | 3 |   2 |   2 |   2 |   2 | 1 | 2 | 3
(4 rows)

-- test different join order enumeration methods
set optimizer_join_order = query;
select * from t1 join t2 on t1.a = t2.a join t3 on t1.b = t3.b;
 a | b | c | a | b | c | a | b | c 
---+---+---+---+---+---+---+---+---
 2 | 2 | 2 | 2 | 2 | 2 | 1 | 2 | 3
 2 | 2 | 2 | 2 | 2 | 2 |   | 2 | 2
(2 rows)

set optimizer_join_order = greedy;
select * from t1 join t2 on t1.a = t2.a join t3 on t1.b = t3.b;
 a | b | c | a | b | c | a | b | c 
---+---+---+---+---+---+---+---+---
 2 | 2 | 2 | 2 | 2 | 2 |   | 2 | 2
 2 | 2 | 2 | 2 | 2 | 2 | 1 | 2 | 3
(2 rows)

set optimizer_join_order = exhaustive;
select * from t1 join t2 on t1.a = t2.a join t3 on t1.b = t3.b;
 a | b | c | a | b | c | a | b | c 
---+---+---+---+---+---+---+---+---
 2 | 2 | 2 | 2 | 2 | 2 | 1 | 2 | 3
 2 | 2 | 2 | 2 | 2 | 2 |   | 2 | 2
(2 rows)

set optimizer_join_order = exhaustive2;
select * from t1 join t2 on t1.a = t2.a join t3 on t1.b = t3.b;
 a | b | c | a | b | c | a | b | c 
---+---+---+---+---+---+---+---+---
 2 | 2 | 2 | 2 | 2 | 2 | 1 | 2 | 3
 2 | 2 | 2 | 2 | 2 | 2 |   | 2 | 2
(2 rows)

reset optimizer_join_order;
select * from t1 join t2 on t1.a = t2.a join t3 on t1.b = t3.b;
 a | b | c | a | b | c | a | b | c 
---+---+---+---+---+---+---+---+---
 2 | 2 | 2 | 2 | 2 | 2 | 1 | 2 | 3
 2 | 2 | 2 | 2 | 2 | 2 |   | 2 | 2
(2 rows)

drop table t1, t2, t3;
--
-- Test a bug that nestloop path previously can not generate motion above
-- index path, which sometimes is wrong (this test case is an example).
-- We now depend on parameterized path related variables to judge instead.
-- We conservatively disallow motion when there is parameter requirement
-- for either outer or inner at this moment though there could be room
-- for further improvement (e.g. referring subplan code to do broadcast
-- for base rel if needed, which needs much effort and does not seem to
-- be deserved given we will probably refactor related code for the lateral
-- support in the near future). For the query and guc settings below, Postgres
-- planner can not generate a plan.
set enable_nestloop = 1;
set enable_material = 0;
set enable_seqscan = 0;
set enable_bitmapscan = 0;
explain select tenk1.unique2 >= 0 from tenk1 left join tenk2 on true limit 1;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.32..0.38 rows=1 width=4)
   ->  Gather Motion 3:1  (slice2; segments: 3)  (cost=0.32..0.38 rows=1 width=4)
         ->  Limit  (cost=0.32..0.36 rows=1 width=4)
               ->  Nested Loop Left Join  (cost=0.32..3520104.27 rows=33333334 width=4)
                     ->  Index Only Scan using tenk1_unique2 on tenk1  (cost=0.16..1650.16 rows=3334 width=4)
                     ->  Materialize  (cost=0.16..18479.11 rows=10000 width=0)
                           ->  Broadcast Motion 3:3  (slice1; segments: 3)  (cost=0.16..18329.11 rows=10000 width=0)
                                 ->  Index Only Scan using tenk2_unique2 on tenk2  (cost=0.16..17929.11 rows=3334 width=0)
 Optimizer: Postgres query optimizer
(9 rows)

select tenk1.unique2 >= 0 from tenk1 left join tenk2 on true limit 1;
 ?column? 
----------
 t
(1 row)

reset enable_nestloop;
reset enable_material;
reset enable_seqscan;
reset enable_bitmapscan;
-- test that flow->hashExpr variables can be resolved
CREATE TABLE hexpr_t1 (c1 int, c2 character varying(16)) DISTRIBUTED BY (c1);
CREATE TABLE hexpr_t2 (c3 character varying(16)) DISTRIBUTED BY (c3);
INSERT INTO hexpr_t1 SELECT i, i::character varying FROM generate_series(1,10)i;
INSERT INTO hexpr_t2 SELECT i::character varying FROM generate_series(1,10)i;
EXPLAIN SELECT btrim(hexpr_t1.c2::text)::character varying AS foo FROM hexpr_t1 LEFT JOIN hexpr_t2
ON hexpr_t2.c3::text = btrim(hexpr_t1.c2::text);
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=3.23..6.70 rows=10 width=2)
   ->  Hash Left Join  (cost=3.23..6.70 rows=4 width=2)
         Hash Cond: (btrim((hexpr_t1.c2)::text) = (hexpr_t2.c3)::text)
         ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..3.30 rows=4 width=2)
               Hash Key: btrim((hexpr_t1.c2)::text)
               ->  Seq Scan on hexpr_t1  (cost=0.00..3.10 rows=4 width=2)
         ->  Hash  (cost=3.10..3.10 rows=4 width=2)
               ->  Seq Scan on hexpr_t2  (cost=0.00..3.10 rows=4 width=2)
 Optimizer: Postgres query optimizer
(9 rows)

EXPLAIN SELECT btrim(hexpr_t1.c2::text)::character varying AS foo FROM hexpr_t1 LEFT JOIN hexpr_t2
ON hexpr_t2.c3::text = btrim(hexpr_t1.c2::text);
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=3.23..6.70 rows=10 width=2)
   ->  Hash Left Join  (cost=3.23..6.70 rows=4 width=2)
         Hash Cond: (btrim((hexpr_t1.c2)::text) = (hexpr_t2.c3)::text)
         ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..3.30 rows=4 width=2)
               Hash Key: btrim((hexpr_t1.c2)::text)
               ->  Seq Scan on hexpr_t1  (cost=0.00..3.10 rows=4 width=2)
         ->  Hash  (cost=3.10..3.10 rows=4 width=2)
               ->  Seq Scan on hexpr_t2  (cost=0.00..3.10 rows=4 width=2)
 Optimizer: Postgres query optimizer
(9 rows)

EXPLAIN SELECT btrim(hexpr_t1.c2::text)::character varying AS foo FROM hexpr_t1 LEFT JOIN hexpr_t2
ON hexpr_t2.c3::text = btrim(hexpr_t1.c2::text);
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=3.23..6.70 rows=10 width=2)
   ->  Hash Left Join  (cost=3.23..6.70 rows=4 width=2)
         Hash Cond: (btrim((hexpr_t1.c2)::text) = (hexpr_t2.c3)::text)
         ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..3.30 rows=4 width=2)
               Hash Key: btrim((hexpr_t1.c2)::text)
               ->  Seq Scan on hexpr_t1  (cost=0.00..3.10 rows=4 width=2)
         ->  Hash  (cost=3.10..3.10 rows=4 width=2)
               ->  Seq Scan on hexpr_t2  (cost=0.00..3.10 rows=4 width=2)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT btrim(hexpr_t1.c2::text)::character varying AS foo FROM hexpr_t1 LEFT JOIN hexpr_t2
ON hexpr_t2.c3::text = btrim(hexpr_t1.c2::text);
 foo 
-----
 5
 6
 8
 2
 3
 4
 7
 9
 10
 1
(10 rows)

SELECT btrim(hexpr_t1.c2::text)::character varying AS foo FROM hexpr_t1 LEFT JOIN hexpr_t2
ON hexpr_t2.c3::text = btrim(hexpr_t1.c2::text);
 foo 
-----
 2
 3
 4
 7
 5
 6
 8
 9
 10
 1
(10 rows)

SELECT btrim(hexpr_t1.c2::text)::character varying AS foo FROM hexpr_t1 LEFT JOIN hexpr_t2
ON hexpr_t2.c3::text = btrim(hexpr_t1.c2::text);
 foo 
-----
 2
 3
 4
 7
 8
 5
 6
 1
 9
 10
(10 rows)

-- test if subquery locus is general, then
-- we should keep it general
set enable_hashjoin to on;
set enable_mergejoin to off;
set enable_nestloop to off;
create table t_randomly_dist_table(c int) distributed randomly;
-- the following plan should not contain redistributed motion (for planner)
explain
select * from (
  select a from generate_series(1, 10)a
  union all
  select a from generate_series(1, 10)a
) t_subquery_general
join t_randomly_dist_table on t_subquery_general.a = t_randomly_dist_table.c;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=65.00..27369.76 rows=192600 width=8)
   ->  Hash Join  (cost=65.00..27369.76 rows=64200 width=8)
         Hash Cond: (t_randomly_dist_table.c = a.a)
         ->  Seq Scan on t_randomly_dist_table  (cost=0.00..1063.00 rows=32100 width=4)
         ->  Hash  (cost=40.00..40.00 rows=667 width=4)
               ->  Append  (cost=0.00..20.00 rows=667 width=4)
                     ->  Function Scan on generate_series a  (cost=0.00..10.00 rows=334 width=4)
                     ->  Function Scan on generate_series a_1  (cost=0.00..10.00 rows=334 width=4)
 Optimizer: Postgres query optimizer
(9 rows)

reset enable_hashjoin;
reset enable_mergejoin;
reset enable_nestloop;
-- test lateral join inner plan contains limit
-- we cannot pass params across motion so we
-- can only generate a plan to gather all the
-- data to singleQE. Here we create a compound
-- data type as params to pass into inner plan.
-- By doing so, if we fail to pass correct params
-- into innerplan, it will throw error because
-- of nullpointer reference. If we only use int
-- type as params, the nullpointer reference error
-- may not happen because we parse null to integer 0.
create type mytype_for_lateral_test as (x int, y int);
create table t1_lateral_limit(a int, b int, c mytype_for_lateral_test);
create table t2_lateral_limit(a int, b int);
insert into t1_lateral_limit values (1, 1, '(1,1)');
insert into t1_lateral_limit values (1, 2, '(2,2)');
insert into t2_lateral_limit values (2, 2);
insert into t2_lateral_limit values (3, 3);
explain select * from t1_lateral_limit as t1 cross join lateral
(select ((c).x+t2.b) as n  from t2_lateral_limit as t2 order by n limit 1)s;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=10000000001.05..10000000002.11 rows=4 width=41)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1.03 rows=1 width=37)
         ->  Seq Scan on t1_lateral_limit t1  (cost=0.00..1.01 rows=1 width=37)
   ->  Materialize  (cost=1.05..1.07 rows=1 width=4)
         ->  Limit  (cost=1.05..1.05 rows=1 width=4)
               ->  Sort  (cost=1.05..1.05 rows=1 width=4)
                     Sort Key: (((t1.c).x + t2.b))
                     ->  Result  (cost=0.00..1.04 rows=1 width=4)
                           ->  Materialize  (cost=0.00..1.03 rows=1 width=4)
                                 ->  Gather Motion 3:1  (slice2; segments: 3)  (cost=0.00..1.03 rows=1 width=4)
                                       ->  Seq Scan on t2_lateral_limit t2  (cost=0.00..1.01 rows=1 width=4)
 Optimizer: Postgres query optimizer
(12 rows)

select * from t1_lateral_limit as t1 cross join lateral
(select ((c).x+t2.b) as n  from t2_lateral_limit as t2 order by n limit 1)s;
 a | b |   c   | n 
---+---+-------+---
 1 | 1 | (1,1) | 3
 1 | 2 | (2,2) | 4
(2 rows)

-- Continue with the above cases, if the lateral subquery contains union all
-- and in some of its appendquerys contain limit, it may also lead to bad plan.
-- The best solution may be to walk the query to and do some static analysis
-- to find out which rel has to be gathered and materialized. But it is complicated
-- to do so and this seems less efficient. I believe in future we should do big
-- refactor to make greenplum support lateral well so now, let's just make sure
-- we will not panic.
explain (costs off) select * from t1_lateral_limit as t1 cross join lateral
((select ((c).x+t2.b) as n  from t2_lateral_limit as t2 order by n limit 1) union all select 1)s;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Nested Loop
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Seq Scan on t1_lateral_limit t1
   ->  Materialize
         ->  Append
               ->  Limit
                     ->  Sort
                           Sort Key: (((t1.c).x + t2.b))
                           ->  Result
                                 ->  Materialize
                                       ->  Gather Motion 3:1  (slice2; segments: 3)
                                             ->  Seq Scan on t2_lateral_limit t2
               ->  Result
 Optimizer: Postgres query optimizer
(14 rows)

select * from t1_lateral_limit as t1 cross join lateral
((select ((c).x+t2.b) as n  from t2_lateral_limit as t2 order by n limit 1) union all select 1)s;
 a | b |   c   | n 
---+---+-------+---
 1 | 1 | (1,1) | 3
 1 | 1 | (1,1) | 1
 1 | 2 | (2,2) | 4
 1 | 2 | (2,2) | 1
(4 rows)

-- test lateral subquery contains group by (group-by is another place that
-- may add motions in the subquery's plan).
explain select * from t1_lateral_limit t1 cross join lateral
(select (c).x+t2.a, sum(t2.a+t2.b) from t2_lateral_limit t2 group by (c).x+t2.a)x;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=10000000001.06..10000000002.12 rows=4 width=49)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1.03 rows=1 width=37)
         ->  Seq Scan on t1_lateral_limit t1  (cost=0.00..1.01 rows=1 width=37)
   ->  Materialize  (cost=1.05..1.08 rows=1 width=12)
         ->  HashAggregate  (cost=1.05..1.07 rows=1 width=12)
               Group Key: ((t1.c).x + t2.a)
               ->  Result  (cost=0.00..1.05 rows=1 width=12)
                     ->  Materialize  (cost=0.00..1.03 rows=1 width=8)
                           ->  Gather Motion 3:1  (slice2; segments: 3)  (cost=0.00..1.03 rows=1 width=8)
                                 ->  Seq Scan on t2_lateral_limit t2  (cost=0.00..1.01 rows=1 width=8)
 Optimizer: Postgres query optimizer
(11 rows)

select * from t1_lateral_limit t1 cross join lateral
(select (c).x+t2.a, sum(t2.a+t2.b) from t2_lateral_limit t2 group by (c).x+t2.a)x;
 a | b |   c   | ?column? | sum 
---+---+-------+----------+-----
 1 | 1 | (1,1) |        4 |   6
 1 | 1 | (1,1) |        3 |   4
 1 | 2 | (2,2) |        5 |   6
 1 | 2 | (2,2) |        4 |   4
(4 rows)

-- The following case is from Github Issue
-- https://github.com/greenplum-db/gpdb/issues/8860
-- It is the same issue as the above test suite.
create table t_mylog_issue_8860 (myid int, log_date timestamptz );
insert into  t_mylog_issue_8860 values (1,timestamptz '2000-01-02 03:04'),(1,timestamptz '2000-01-02 03:04'-'1 hour'::interval);
insert into  t_mylog_issue_8860 values (2,timestamptz '2000-01-02 03:04'),(2,timestamptz '2000-01-02 03:04'-'2 hour'::interval);
explain select ml1.myid, log_date as first_date, ml2.next_date from t_mylog_issue_8860 ml1
inner join lateral
(select myid, log_date as next_date
 from t_mylog_issue_8860 where myid = ml1.myid and log_date > ml1.log_date order by log_date asc limit 1) ml2
on true;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=10000000001.08..10000000002.18 rows=4 width=20)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1.06 rows=2 width=12)
         ->  Seq Scan on t_mylog_issue_8860 ml1  (cost=0.00..1.02 rows=1 width=12)
   ->  Materialize  (cost=1.08..1.10 rows=1 width=8)
         ->  Subquery Scan on ml2  (cost=1.08..1.09 rows=1 width=8)
               ->  Limit  (cost=1.08..1.08 rows=1 width=12)
                     ->  Sort  (cost=1.08..1.08 rows=2 width=12)
                           Sort Key: t_mylog_issue_8860.log_date
                           ->  Result  (cost=0.00..1.07 rows=2 width=12)
                                 Filter: ((t_mylog_issue_8860.log_date > ml1.log_date) AND (t_mylog_issue_8860.myid = ml1.myid))
                                 ->  Materialize  (cost=0.00..1.07 rows=1 width=12)
                                       ->  Gather Motion 3:1  (slice2; segments: 3)  (cost=0.00..1.06 rows=2 width=12)
                                             ->  Seq Scan on t_mylog_issue_8860  (cost=0.00..1.02 rows=1 width=12)
 Optimizer: Postgres query optimizer
(14 rows)

select ml1.myid, log_date as first_date, ml2.next_date from t_mylog_issue_8860 ml1
inner join lateral
(select myid, log_date as next_date
 from t_mylog_issue_8860 where myid = ml1.myid and log_date > ml1.log_date order by log_date asc limit 1) ml2
on true;
 myid |          first_date          |          next_date           
------+------------------------------+------------------------------
    2 | Sun Jan 02 01:04:00 2000 PST | Sun Jan 02 03:04:00 2000 PST
    1 | Sun Jan 02 02:04:00 2000 PST | Sun Jan 02 03:04:00 2000 PST
(2 rows)

-- Github Issue: https://github.com/greenplum-db/gpdb/issues/9733
-- Previously in the function bring_to_outer_query and
-- bring_to_singleQE it depends on the path->param_info field
-- to determine if the path contains outerParams. This is not
-- enought. The following case would SegFault before because
-- the indexpath's orderby clause contains outerParams.
create table gist_tbl_github9733 (b box, p point, c circle);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, and no column type is suitable for a distribution key. Creating a NULL policy entry.
insert into gist_tbl_github9733
select box(point(0.05*i, 0.05*i), point(0.05*i, 0.05*i)),
       point(0.05*i, 0.05*i),
       circle(point(0.05*i, 0.05*i), 1.0)
from generate_series(0,10000) as i;
vacuum analyze gist_tbl_github9733;
create index gist_tbl_point_index_github9733 on gist_tbl_github9733 using gist (p);
set enable_seqscan=off;
set enable_bitmapscan=off;
explain (costs off)
select p from
  (values (box(point(0,0), point(0.5,0.5))),
          (box(point(0.5,0.5), point(0.75,0.75))),
          (box(point(0.8,0.8), point(1.0,1.0)))) as v(bb)
cross join lateral
  (select p from gist_tbl_github9733 where p <@ bb order by p <-> bb[0] limit 2) ss;
ERROR:  could not devise a query plan for the given query (pathnode.c:422)
reset enable_seqscan;
explain (costs off)
select p from
  (values (box(point(0,0), point(0.5,0.5))),
          (box(point(0.5,0.5), point(0.75,0.75))),
          (box(point(0.8,0.8), point(1.0,1.0)))) as v(bb)
cross join lateral
  (select p from gist_tbl_github9733 where p <@ bb order by p <-> bb[0] limit 2) ss;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Nested Loop
   ->  Values Scan on "*VALUES*"
   ->  Materialize
         ->  Subquery Scan on ss
               ->  Limit
                     ->  Sort
                           Sort Key: ((gist_tbl_github9733.p <-> ("*VALUES*".column1)[0]))
                           ->  Result
                                 Filter: (gist_tbl_github9733.p <@ "*VALUES*".column1)
                                 ->  Materialize
                                       ->  Gather Motion 3:1  (slice1; segments: 3)
                                             ->  Seq Scan on gist_tbl_github9733
 Optimizer: Postgres query optimizer
(13 rows)

select p from
  (values (box(point(0,0), point(0.5,0.5))),
          (box(point(0.5,0.5), point(0.75,0.75))),
          (box(point(0.8,0.8), point(1.0,1.0)))) as v(bb)
cross join lateral
  (select p from gist_tbl_github9733 where p <@ bb order by p <-> bb[0] limit 2) ss;
      p      
-------------
 (0.5,0.5)
 (0.45,0.45)
 (0.75,0.75)
 (0.7,0.7)
 (1,1)
 (0.95,0.95)
(6 rows)

reset enable_bitmapscan;
-- Test targetlist contains placeholder var
-- When creating a redistributed motion with hash keys,
-- Greenplum planner will invoke `cdbpullup_findEclassInTargetList`.
-- The following test case contains non-strict function `coalesce`
-- in the subquery at nullable-side of outerjoin and thus will
-- have PlaceHolderVar in targetlist. The case is to test if
-- function `cdbpullup_findEclassInTargetList` handles PlaceHolderVar
-- correct.
-- See github issue: https://github.com/greenplum-db/gpdb/issues/10315
create table t_issue_10315 ( id1 int, id2 int );
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into t_issue_10315 select i,i from generate_series(1, 2)i;
insert into t_issue_10315 select i,null from generate_series(1, 2)i;
insert into t_issue_10315 select null,i from generate_series(1, 2)i;
select *  from
( select coalesce( bq.id1 ) id1, coalesce ( bq.id2 ) id2
        from ( select r.id1, r.id2 from t_issue_10315 r group by r.id1, r.id2 ) bq  ) t
full join ( select r.id1, r.id2 from t_issue_10315 r group by r.id1, r.id2 ) bq_all
on t.id1 = bq_all.id1  and t.id2 = bq_all.id2
full join ( select r.id1, r.id2 from t_issue_10315 r group by r.id1, r.id2 ) tq_all
on (coalesce(t.id1) = tq_all.id1  and t.id2 = tq_all.id2) ;
 id1 | id2 | id1 | id2 | id1 | id2 
-----+-----+-----+-----+-----+-----
   2 |   2 |   2 |   2 |   2 |   2
   2 |     |     |     |     |    
     |   1 |     |     |     |    
     |   2 |     |     |     |    
     |     |     |   2 |     |    
     |     |     |   1 |     |    
     |     |   2 |     |     |    
     |     |   1 |     |     |    
     |     |     |     |     |   2
     |     |     |     |     |   1
     |     |     |     |   2 |    
   1 |   1 |   1 |   1 |   1 |   1
   1 |     |     |     |     |    
     |     |     |     |   1 |    
(14 rows)

drop table t_issue_10315;
--
-- test in subplan, if one side of a qual is a Param refers to system table
-- and another side refers to a replicate table, we do not create index plan
-- in the subplan though this is kind of aggressive (Defintely there exists room
-- for optimization) but let's make sure the correctness of these cases at first.
-- https://github.com/greenplum-db/gpdb/issues/8648
--
set enable_seqscan = 0;
create table rep_tbl (tablename text, explanation text) distributed replicated;
create table dis_tbl (relname text, tablename text, explanation text);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'relname' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into rep_tbl values ('pg_class', 'contains all relations');
create index on rep_tbl (tablename);
analyze rep_tbl;
--- The Var case
explain verbose select c.relname, (select explanation from rep_tbl where rep_tbl.tablename=c.relname ) from pg_class c where relname = 'pg_class';
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using pg_class_relname_nsp_index on pg_catalog.pg_class c  (cost=0.27..10000000101.31 rows=1 width=64)
   Output: c.relname, (SubPlan 1)
   Index Cond: (c.relname = 'pg_class'::name)
   SubPlan 1  (slice0)
     ->  Result  (cost=10000000000.00..10000000001.02 rows=1 width=23)
           Output: rep_tbl.explanation
           Filter: (rep_tbl.tablename = (c.relname)::text)
           ->  Materialize  (cost=10000000000.00..10000000001.02 rows=1 width=23)
                 Output: rep_tbl.explanation, rep_tbl.tablename
                 ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=10000000000.00..10000000001.01 rows=1 width=23)
                       Output: rep_tbl.explanation, rep_tbl.tablename
                       ->  Seq Scan on public.rep_tbl  (cost=10000000000.00..10000000001.01 rows=1 width=23)
                             Output: rep_tbl.explanation, rep_tbl.tablename
 Optimizer: Postgres query optimizer
 Settings: enable_seqscan=off, optimizer=off
(15 rows)

select c.relname, (select explanation from rep_tbl where rep_tbl.tablename=c.relname ) from pg_class c where relname = 'pg_class';
 relname  |      explanation       
----------+------------------------
 pg_class | contains all relations
(1 row)

explain verbose select c.relname, (select explanation from rep_tbl where rep_tbl.tablename=c.relname ) from (select oid, relname from pg_class offset 0) c where relname = 'pg_class';
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Subquery Scan on c  (cost=10000000000.00..20000000017.85 rows=1 width=64)
   Output: c.relname, (SubPlan 1)
   Filter: (c.relname = 'pg_class'::name)
   ->  Seq Scan on pg_catalog.pg_class  (cost=10000000000.00..10000000011.37 rows=437 width=68)
         Output: pg_class.oid, pg_class.relname
   SubPlan 1  (slice0)
     ->  Result  (cost=10000000000.00..10000000001.02 rows=1 width=23)
           Output: rep_tbl.explanation
           Filter: (rep_tbl.tablename = (c.relname)::text)
           ->  Materialize  (cost=10000000000.00..10000000001.02 rows=1 width=23)
                 Output: rep_tbl.explanation, rep_tbl.tablename
                 ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=10000000000.00..10000000001.01 rows=1 width=23)
                       Output: rep_tbl.explanation, rep_tbl.tablename
                       ->  Seq Scan on public.rep_tbl  (cost=10000000000.00..10000000001.01 rows=1 width=23)
                             Output: rep_tbl.explanation, rep_tbl.tablename
 Optimizer: Postgres query optimizer
 Settings: enable_seqscan=off, optimizer=off
(17 rows)

select c.relname, (select explanation from rep_tbl where rep_tbl.tablename=c.relname ) from (select oid, relname from pg_class offset 0) c where relname = 'pg_class';
 relname  |      explanation       
----------+------------------------
 pg_class | contains all relations
(1 row)

--- The PlaceholderVar case
explain verbose select t1.relname, ss.x from
  pg_class t1 left join (select relisshared as x, coalesce(t2.relname, 'dummy') y from pg_class t2) ss
  on t1.relname = ss.y
  where 1 = (select 1 from rep_tbl t3 where ss.y = t3.tablename limit 1);
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Hash Left Join  (cost=10000000934.17..30600000005364.92 rows=12 width=65)
   Output: t1.relname, t2.relisshared
   Hash Cond: (t1.relname = COALESCE(t2.relname, 'dummy'::name))
   Filter: (1 = (SubPlan 1))
   ->  Bitmap Heap Scan on pg_catalog.pg_class t1  (cost=816.34..895.93 rows=3059 width=64)
         Output: t1.relname
         ->  Bitmap Index Scan on pg_class_relname_nsp_index  (cost=0.00..815.57 rows=3059 width=0)
   ->  Hash  (cost=10000000079.59..10000000079.59 rows=1020 width=129)
         Output: t2.relisshared, t2.relname, (COALESCE(t2.relname, 'dummy'::name))
         ->  Seq Scan on pg_catalog.pg_class t2  (cost=10000000000.00..10000000079.59 rows=3059 width=129)
               Output: t2.relisshared, t2.relname, COALESCE(t2.relname, 'dummy'::name)
   SubPlan 1  (slice0)
     ->  Limit  (cost=10000000000.00..10000000001.03 rows=1 width=0)
           Output: "outer".?column?
           ->  Result  (cost=10000000000.00..10000000001.02 rows=1 width=0)
                 Output: 1
                 Filter: (((COALESCE(t2.relname, 'dummy'::name)))::text = t3.tablename)
                 ->  Materialize  (cost=10000000000.00..10000000001.02 rows=1 width=0)
                       Output: t3.tablename
                       ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=10000000000.00..10000000001.01 rows=1 width=0)
                             Output: t3.tablename
                             ->  Seq Scan on public.rep_tbl t3  (cost=10000000000.00..10000000001.01 rows=1 width=0)
                                   Output: t3.tablename
 Optimizer: Postgres query optimizer
 Settings: enable_seqscan=off, optimizer=off
(25 rows)

select t1.relname, ss.x from
  pg_class t1 left join (select relisshared as x, coalesce(t2.relname, 'dummy') y from pg_class t2) ss
  on t1.relname = ss.y
  where 1 = (select 1 from rep_tbl t3 where ss.y = t3.tablename limit 1);
 relname  | x 
----------+---
 pg_class | f
(1 row)

drop table rep_tbl;
drop table dis_tbl;
reset enable_seqscan;
-- test for indexonly scan with dedup semi join
create table t1_dedupsemi_indexonly(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table t2_dedupsemi_indexonly(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into t1_dedupsemi_indexonly select i,i from generate_series(1, 100)i;
insert into t2_dedupsemi_indexonly select i,i from generate_series(1, 4)i;
insert into t2_dedupsemi_indexonly select i,i from generate_series(1, 4)i;
create unique index idx on t1_dedupsemi_indexonly(a);
analyze t1_dedupsemi_indexonly;
analyze t2_dedupsemi_indexonly;
-- if ever seen indexonly scan path, planner will not to use
-- unique rowid path method to implement the SEMI join. The
-- following case will lead to a SEMI join plan to give the
-- correct answer.
explain (costs off)
select * from
(
  select a from t1_dedupsemi_indexonly where a < 3 -- index only scan
) x (a)
where x.a + 1 in (select distinct b from t2_dedupsemi_indexonly);
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Gather Motion 3:1  (slice3; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_dedupsemi_indexonly.a + 1) = t2_dedupsemi_indexonly.b)
         ->  Redistribute Motion 3:3  (slice1; segments: 3)
               Hash Key: (t1_dedupsemi_indexonly.a + 1)
               ->  Seq Scan on t1_dedupsemi_indexonly
                     Filter: (a < 3)
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: t2_dedupsemi_indexonly.b
                     ->  Seq Scan on t2_dedupsemi_indexonly
 Optimizer: Postgres query optimizer
(12 rows)

select * from
(
  select a from t1_dedupsemi_indexonly where a < 3 -- index only scan
) x (a)
where x.a + 1 in (select distinct b from t2_dedupsemi_indexonly);
 a 
---
 1
 2
(2 rows)

explain (costs off)
select * from
(
  select a from t1_dedupsemi_indexonly where a < 3 -- index only scan
) x (a)
where x.a + 1 in (select b from t2_dedupsemi_indexonly);
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Gather Motion 3:1  (slice3; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_dedupsemi_indexonly.a + 1) = t2_dedupsemi_indexonly.b)
         ->  Redistribute Motion 3:3  (slice1; segments: 3)
               Hash Key: (t1_dedupsemi_indexonly.a + 1)
               ->  Seq Scan on t1_dedupsemi_indexonly
                     Filter: (a < 3)
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: t2_dedupsemi_indexonly.b
                     ->  Seq Scan on t2_dedupsemi_indexonly
 Optimizer: Postgres query optimizer
(12 rows)

select * from
(
  select a from t1_dedupsemi_indexonly where a < 3 -- index only scan
) x (a)
where x.a + 1 in (select b from t2_dedupsemi_indexonly);
 a 
---
 2
 1
(2 rows)

drop table t1_dedupsemi_indexonly;
drop table t2_dedupsemi_indexonly;
create table foo_varchar (a varchar(5)) distributed by (a);
create table bar_char (p char(5)) distributed by (p);
create table random_dis_varchar (x varchar(5)) distributed randomly;
create table random_dis_char (y char(5)) distributed randomly;
insert into foo_varchar values ('1 '),('2  '),('3   ');
insert into bar_char values ('1 '),('2  '),('3   ');
insert into random_dis_varchar values ('1 '),('2  '),('3   ');
insert into random_dis_char values ('1 '),('2  '),('3   ');
set optimizer_enable_hashjoin to off;
set enable_hashjoin to off;
set enable_nestloop to on;
-- check motion is added when performing a NL Left Outer Join between relations
-- when the join condition columns belong to different opfamily and both are
-- distribution keys
explain select * from foo_varchar left join bar_char on foo_varchar.a=bar_char.p;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.00..4.26 rows=4 width=10)
   ->  Nested Loop Left Join  (cost=0.00..4.26 rows=2 width=10)
         Join Filter: ((foo_varchar.a)::bpchar = bar_char.p)
         ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..2.09 rows=1 width=4)
               Hash Key: foo_varchar.a
               ->  Seq Scan on foo_varchar  (cost=0.00..2.03 rows=1 width=4)
         ->  Materialize  (cost=0.00..2.04 rows=1 width=6)
               ->  Seq Scan on bar_char  (cost=0.00..2.03 rows=1 width=6)
 Optimizer: Postgres query optimizer
(9 rows)

select * from foo_varchar left join bar_char on foo_varchar.a=bar_char.p;
  a   |   p   
------+-------
 1    | 1    
 2    | 2    
 3    | 3    
(3 rows)

-- There is a plan change (from redistribution to broadcast) because a NULL
-- matching distribution is returned when there is opfamily mismatch between join
-- columns.
explain select * from foo_varchar left join random_dis_char on foo_varchar.a=random_dis_char.y;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice3; segments: 3)  (cost=0.00..4.32 rows=4 width=10)
   ->  Nested Loop Left Join  (cost=0.00..4.32 rows=2 width=10)
         Join Filter: ((foo_varchar.a)::bpchar = random_dis_char.y)
         ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..2.09 rows=1 width=4)
               Hash Key: foo_varchar.a
               ->  Seq Scan on foo_varchar  (cost=0.00..2.03 rows=1 width=4)
         ->  Materialize  (cost=0.00..2.10 rows=1 width=6)
               ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..2.09 rows=1 width=6)
                     Hash Key: random_dis_char.y
                     ->  Seq Scan on random_dis_char  (cost=0.00..2.03 rows=1 width=6)
 Optimizer: Postgres query optimizer
(11 rows)

select * from foo_varchar left join random_dis_char on foo_varchar.a=random_dis_char.y;
  a   |   y   
------+-------
 1    | 1    
 2    | 2    
 3    | 3    
(3 rows)

explain select * from bar_char left join random_dis_varchar on bar_char.p=random_dis_varchar.x;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.00..4.26 rows=4 width=10)
   ->  Nested Loop Left Join  (cost=0.00..4.26 rows=2 width=10)
         Join Filter: (bar_char.p = (random_dis_varchar.x)::bpchar)
         ->  Seq Scan on bar_char  (cost=0.00..2.03 rows=1 width=6)
         ->  Materialize  (cost=0.00..2.10 rows=1 width=4)
               ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..2.09 rows=1 width=4)
                     Hash Key: random_dis_varchar.x
                     ->  Seq Scan on random_dis_varchar  (cost=0.00..2.03 rows=1 width=4)
 Optimizer: Postgres query optimizer
(9 rows)

select * from bar_char left join random_dis_varchar on bar_char.p=random_dis_varchar.x;
   p   |  x   
-------+------
 2     | 2  
 3     | 3   
 1     | 1 
(3 rows)

-- check motion is added when performing a NL Inner Join between relations when
-- the join condition columns belong to different opfamily and both are
-- distribution keys
explain select * from foo_varchar inner join bar_char on foo_varchar.a=bar_char.p;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.00..4.26 rows=4 width=10)
   ->  Nested Loop  (cost=0.00..4.26 rows=2 width=10)
         Join Filter: ((foo_varchar.a)::bpchar = bar_char.p)
         ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..2.09 rows=1 width=4)
               Hash Key: foo_varchar.a
               ->  Seq Scan on foo_varchar  (cost=0.00..2.03 rows=1 width=4)
         ->  Materialize  (cost=0.00..2.04 rows=1 width=6)
               ->  Seq Scan on bar_char  (cost=0.00..2.03 rows=1 width=6)
 Optimizer: Postgres query optimizer
(9 rows)

select * from foo_varchar inner join bar_char on foo_varchar.a=bar_char.p;
  a   |   p   
------+-------
 2    | 2    
 3    | 3    
 1    | 1    
(3 rows)

-- There is a plan change (from redistribution to broadcast) because a NULL
-- matching distribution is returned when there is opfamily mismatch between join
-- columns.
explain select * from foo_varchar inner join random_dis_char on foo_varchar.a=random_dis_char.y;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice3; segments: 3)  (cost=0.00..4.32 rows=4 width=10)
   ->  Nested Loop  (cost=0.00..4.32 rows=2 width=10)
         Join Filter: ((foo_varchar.a)::bpchar = random_dis_char.y)
         ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..2.09 rows=1 width=4)
               Hash Key: foo_varchar.a
               ->  Seq Scan on foo_varchar  (cost=0.00..2.03 rows=1 width=4)
         ->  Materialize  (cost=0.00..2.10 rows=1 width=6)
               ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..2.09 rows=1 width=6)
                     Hash Key: random_dis_char.y
                     ->  Seq Scan on random_dis_char  (cost=0.00..2.03 rows=1 width=6)
 Optimizer: Postgres query optimizer
(11 rows)

select * from foo_varchar inner join random_dis_char on foo_varchar.a=random_dis_char.y;
  a   |   y   
------+-------
 1    | 1    
 2    | 2    
 3    | 3    
(3 rows)

explain select * from bar_char inner join random_dis_varchar on bar_char.p=random_dis_varchar.x;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.00..4.26 rows=4 width=10)
   ->  Nested Loop  (cost=0.00..4.26 rows=2 width=10)
         Join Filter: (bar_char.p = (random_dis_varchar.x)::bpchar)
         ->  Seq Scan on bar_char  (cost=0.00..2.03 rows=1 width=6)
         ->  Materialize  (cost=0.00..2.10 rows=1 width=4)
               ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..2.09 rows=1 width=4)
                     Hash Key: random_dis_varchar.x
                     ->  Seq Scan on random_dis_varchar  (cost=0.00..2.03 rows=1 width=4)
 Optimizer: Postgres query optimizer
(9 rows)

select * from bar_char inner join random_dis_varchar on bar_char.p=random_dis_varchar.x;
   p   |  x   
-------+------
 2     | 2  
 3     | 3   
 1     | 1 
(3 rows)

drop table foo_varchar;
drop table bar_char;
drop table random_dis_varchar;
drop table random_dis_char;
set optimizer_enable_hashjoin to on;
reset enable_hashjoin;
reset enable_nestloop;
