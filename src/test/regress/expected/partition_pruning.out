--
-- Tests on partition pruning (with ORCA) or constraint exclusion (with the
-- Postgres planner). These tests check that you get an "expected" plan, that
-- only scans the partitions that are needed.
--
-- The "correct" plan for a given query depends a lot on the capabilities of
-- the planner and the rest of the system, so the expected output can need
-- updating, as the system improves.
--
-- start_matchsubs
-- m/\(cost=.*\)/
-- s/\(cost=.*\)//
-- end_matchsubs
-- Create test table with two partitions, for values equal to '1' and values equal to '2'.
create table parttab (n numeric, t text)
  partition by list (n)(partition one values ('1'), partition two values('2'));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'n' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
-- Insert three rows. They're all equal to '1', but different number of zeros after decimal point.
insert into parttab values
  ('1', 'one'),
  ('1.0', 'one point zero'),
  ('1.00', 'one point zero zero');
-- select rows whose text representation is three characters long. This should return the '1.0' row.
select * from parttab where length(n::text) = 3;
  n  |       t        
-----+----------------
 1.0 | one point zero
(1 row)

explain select * from parttab where length(n::text) = 3;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..533.04 rows=70 width=64)
   ->  Append  (cost=0.00..532.12 rows=23 width=64)
         ->  Seq Scan on parttab_1_prt_one  (cost=0.00..266.00 rows=12 width=64)
               Filter: (length((n)::text) = 3)
         ->  Seq Scan on parttab_1_prt_two  (cost=0.00..266.00 rows=12 width=64)
               Filter: (length((n)::text) = 3)
 Optimizer: Postgres query optimizer
(7 rows)

-- Use index scans when possible. That exercises more code, and allows us to
-- spot the cases where the planner cannot use even when it exists.
set enable_seqscan=off;
set enable_bitmapscan=on;
set enable_indexscan=on;
create schema partition_pruning;
set search_path to partition_pruning;
-- Set up common test tables.
CREATE TABLE pt_lt_tab
(
  col1 int,
  col2 decimal,
  col3 text,
  col4 bool
)
distributed by (col1)
partition by list(col2)
(
  partition part1 values(1,2,3,4,5,6,7,8,9,10),
  partition part2 values(11,12,13,14,15,16,17,18,19,20),
  partition part3 values(21,22,23,24,25,26,27,28,29,30),
  partition part4 values(31,32,33,34,35,36,37,38,39,40),
  partition part5 values(41,42,43,44,45,46,47,48,49,50)
);
INSERT INTO pt_lt_tab SELECT i, i,'a',True FROM generate_series(1,3)i;
INSERT INTO pt_lt_tab SELECT i, i,'b',True FROM generate_series(4,6)i;
INSERT INTO pt_lt_tab SELECT i, i,'c',True FROM generate_series(7,10)i;
INSERT INTO pt_lt_tab SELECT i, i,'e',True FROM generate_series(11,13)i;
INSERT INTO pt_lt_tab SELECT i, i,'f',True FROM generate_series(14,16)i;
INSERT INTO pt_lt_tab SELECT i, i,'g',True FROM generate_series(17,20)i;
INSERT INTO pt_lt_tab SELECT i, i,'i',False FROM generate_series(21,23)i;
INSERT INTO pt_lt_tab SELECT i, i,'k',False FROM generate_series(24,26)i;
INSERT INTO pt_lt_tab SELECT i, i,'h',False FROM generate_series(27,30)i;
INSERT INTO pt_lt_tab SELECT i, i,'m',False FROM generate_series(31,33)i;
INSERT INTO pt_lt_tab SELECT i, i,'o',False FROM generate_series(34,36)i;
INSERT INTO pt_lt_tab SELECT i, i,'n',False FROM generate_series(37,40)i;
INSERT INTO pt_lt_tab SELECT i, i,'p',False FROM generate_series(41,43)i;
INSERT INTO pt_lt_tab SELECT i, i,'s',False FROM generate_series(44,46)i;
INSERT INTO pt_lt_tab SELECT i, i,'q',False FROM generate_series(47,50)i;
ANALYZE pt_lt_tab;
-- pt_lt_tab_df is the same as pt_lt_tab, but with a default partition (and some
-- values in the default partition, including NULLs).
CREATE TABLE pt_lt_tab_df
(
  col1 int,
  col2 decimal,
  col3 text,
  col4 bool
)
distributed by (col1)
partition by list(col2)
(
  partition part1 VALUES(1,2,3,4,5,6,7,8,9,10),
  partition part2 VALUES(11,12,13,14,15,16,17,18,19,20),
  partition part3 VALUES(21,22,23,24,25,26,27,28,29,30),
  partition part4 VALUES(31,32,33,34,35,36,37,38,39,40),
  partition part5 VALUES(41,42,43,44,45,46,47,48,49,50),
  default partition def
);
INSERT INTO pt_lt_tab_df SELECT i, i,'a',True FROM generate_series(1,3)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'b',True FROM generate_series(4,6)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'c',True FROM generate_series(7,10)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'e',True FROM generate_series(11,13)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'f',True FROM generate_series(14,16)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'g',True FROM generate_series(17,20)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'i',False FROM generate_series(21,23)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'k',False FROM generate_series(24,26)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'h',False FROM generate_series(27,30)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'m',False FROM generate_series(31,33)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'o',False FROM generate_series(34,36)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'n',False FROM generate_series(37,40)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'p',False FROM generate_series(41,43)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'s',False FROM generate_series(44,46)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'q',False FROM generate_series(47,50)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'u',True FROM generate_series(51,53)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'x',True FROM generate_series(54,56)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'w',True FROM generate_series(57,60)i;
INSERT INTO pt_lt_tab_df VALUES(NULL,NULL,NULL,NULL);
INSERT INTO pt_lt_tab_df VALUES(NULL,NULL,NULL,NULL);
INSERT INTO pt_lt_tab_df VALUES(NULL,NULL,NULL,NULL);
ANALYZE pt_lt_tab_df;
--
-- Test that stable functions are evaluated when constructing the plan. This
-- differs from PostgreSQL. In PostgreSQL, PREPARE/EXECUTE creates a reusable
-- plan, while in GPDB, we re-plan the query on every execution, so that the
-- stable function is executed during planning, and we can therefore do
-- partition pruning based on its result.
--
create or replace function stabletestfunc() returns integer as $$
begin
  return 10;
end;
$$ language plpgsql stable;
PREPARE prep_prune AS select * from pt_lt_tab WHERE col2 = stabletestfunc();
-- The plan should only scan one partition, where col2 = 10.
EXPLAIN EXECUTE prep_prune;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000003.15 rows=1 width=12)
   ->  Seq Scan on pt_lt_tab_1_prt_part1  (cost=10000000000.00..10000000003.12 rows=1 width=12)
         Filter: (col2 = '10'::numeric)
 Optimizer: Postgres query optimizer
(4 rows)

-- Also test that Params are const-evaluated.
PREPARE prep_prune_param AS select * from pt_lt_tab WHERE col2 = $1;
EXPLAIN EXECUTE prep_prune_param(10);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000003.15 rows=1 width=12)
   ->  Seq Scan on pt_lt_tab_1_prt_part1  (cost=10000000000.00..10000000003.12 rows=1 width=12)
         Filter: (col2 = '10'::numeric)
 Optimizer: Postgres query optimizer
(4 rows)

-- @description B-tree single index key = non-partitioning key
CREATE INDEX idx1 on pt_lt_tab(col1);
SELECT * FROM pt_lt_tab WHERE col1 < 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 < 10 ORDER BY col2,col3 LIMIT 5;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=580.96..581.03 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=580.96..581.17 rows=15 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=580.96..580.97 rows=5 width=12)
               ->  Sort  (cost=580.96..580.98 rows=7 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..580.85 rows=7 width=12)
                           ->  Index Scan using pt_lt_tab_1_prt_part1_col1_idx on pt_lt_tab_1_prt_part1  (cost=0.14..404.24 rows=3 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col1_idx on pt_lt_tab_1_prt_part2  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col1_idx on pt_lt_tab_1_prt_part3  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col1_idx on pt_lt_tab_1_prt_part4  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col1_idx on pt_lt_tab_1_prt_part5  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 < 10)
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 > 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
(0 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 > 50 ORDER BY col2,col3 LIMIT 5;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=5500.82..5500.93 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=5500.82..5500.93 rows=5 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=5500.82..5500.83 rows=2 width=12)
               ->  Sort  (cost=5500.82..5500.83 rows=2 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..5500.76 rows=2 width=12)
                           ->  Index Scan using pt_lt_tab_1_prt_part1_col1_idx on pt_lt_tab_1_prt_part1  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col1_idx on pt_lt_tab_1_prt_part2  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col1_idx on pt_lt_tab_1_prt_part3  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col1_idx on pt_lt_tab_1_prt_part4  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col1_idx on pt_lt_tab_1_prt_part5  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: (col1 > 50)
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 = 25 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   25 |   25 | k    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 = 25 ORDER BY col2,col3 LIMIT 5;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=220.82..220.89 rows=5 width=12)
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=220.82..220.99 rows=12 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=220.82..220.83 rows=4 width=12)
               ->  Sort  (cost=220.82..220.83 rows=5 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..220.76 rows=5 width=12)
                           ->  Index Scan using pt_lt_tab_1_prt_part1_col1_idx on pt_lt_tab_1_prt_part1  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 = 25)
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col1_idx on pt_lt_tab_1_prt_part2  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 = 25)
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col1_idx on pt_lt_tab_1_prt_part3  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 = 25)
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col1_idx on pt_lt_tab_1_prt_part4  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 = 25)
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col1_idx on pt_lt_tab_1_prt_part5  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 = 25)
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 <> 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 <> 10 ORDER BY col2,col3 LIMIT 5;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=50000000016.37..50000000016.48 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=50000000016.37..50000000016.48 rows=5 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=50000000016.37..50000000016.38 rows=2 width=12)
               ->  Sort  (cost=50000000016.37..50000000016.48 rows=15 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=10000000000.00..50000000015.62 rows=15 width=12)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col1 <> 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part2  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col1 <> 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part3  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col1 <> 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part4  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col1 <> 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part5  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col1 <> 10
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 > 10 AND col1 < 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 > 10 AND col1 < 50 ORDER BY col2,col3 LIMIT 5;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1661.47..1661.54 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=1661.47..1661.68 rows=15 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=1661.47..1661.48 rows=5 width=12)
               ->  Sort  (cost=1661.47..1661.50 rows=14 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..1661.23 rows=14 width=12)
                           ->  Index Scan using pt_lt_tab_1_prt_part1_col1_idx on pt_lt_tab_1_prt_part1  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: ((col1 > 10) AND (col1 < 50))
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col1_idx on pt_lt_tab_1_prt_part2  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col1 > 10) AND (col1 < 50))
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col1_idx on pt_lt_tab_1_prt_part3  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col1 > 10) AND (col1 < 50))
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col1_idx on pt_lt_tab_1_prt_part4  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col1 > 10) AND (col1 < 50))
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col1_idx on pt_lt_tab_1_prt_part5  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col1 > 10) AND (col1 < 50))
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 > 10 OR col1 = 25 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 > 10 OR col1 = 25 ORDER BY col2,col3 LIMIT 5;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Limit  (cost=46115.01..46115.12 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=46115.01..46115.12 rows=5 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=46115.01..46115.02 rows=2 width=12)
               ->  Sort  (cost=46115.01..46115.11 rows=14 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=2000.29..46114.33 rows=14 width=12)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part1  (cost=2000.29..2100.30 rows=1 width=12)
                                 Recheck Cond: col1 > 10 OR col1 = 25
                                 ->  BitmapOr  (cost=2000.29..2000.29 rows=1 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part1_col1_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col1 > 10)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part1_col1_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col1 = 25)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part2  (cost=11000.36..11003.51 rows=4 width=12)
                                 Recheck Cond: col1 > 10 OR col1 = 25
                                 ->  BitmapOr  (cost=11000.36..11000.36 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part2_col1_idx  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: (col1 > 10)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part2_col1_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col1 = 25)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part3  (cost=11000.36..11003.51 rows=4 width=12)
                                 Recheck Cond: col1 > 10 OR col1 = 25
                                 ->  BitmapOr  (cost=11000.36..11000.36 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part3_col1_idx  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: (col1 > 10)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part3_col1_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col1 = 25)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part4  (cost=11000.36..11003.51 rows=4 width=12)
                                 Recheck Cond: col1 > 10 OR col1 = 25
                                 ->  BitmapOr  (cost=11000.36..11000.36 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part4_col1_idx  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: (col1 > 10)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part4_col1_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col1 = 25)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part5  (cost=11000.36..11003.51 rows=4 width=12)
                                 Recheck Cond: col1 > 10 OR col1 = 25
                                 ->  BitmapOr  (cost=11000.36..11000.36 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part5_col1_idx  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: (col1 > 10)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part5_col1_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col1 = 25)
 Optimizer: Postgres query optimizer
(43 rows)

SELECT * FROM pt_lt_tab WHERE col1 between 10 AND 25 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   10 |   10 | c    | t
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 between 10 AND 25 ORDER BY col2,col3 LIMIT 5;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=701.04..701.11 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=701.04..701.25 rows=15 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=701.04..701.05 rows=5 width=12)
               ->  Sort  (cost=701.04..701.06 rows=8 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..700.92 rows=8 width=12)
                           ->  Index Scan using pt_lt_tab_1_prt_part1_col1_idx on pt_lt_tab_1_prt_part1  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: ((col1 >= 10) AND (col1 <= 25))
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col1_idx on pt_lt_tab_1_prt_part2  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col1 >= 10) AND (col1 <= 25))
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col1_idx on pt_lt_tab_1_prt_part3  (cost=0.14..164.19 rows=1 width=12)
                                 Index Cond: ((col1 >= 10) AND (col1 <= 25))
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col1_idx on pt_lt_tab_1_prt_part4  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: ((col1 >= 10) AND (col1 <= 25))
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col1_idx on pt_lt_tab_1_prt_part5  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: ((col1 >= 10) AND (col1 <= 25))
 Optimizer: Postgres query optimizer
(18 rows)

DROP INDEX idx1;
-- @description B-tree single index key = partitioning key
CREATE INDEX idx1 on pt_lt_tab(col2);
SELECT * FROM pt_lt_tab WHERE col2 < 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 < 10 ORDER BY col2,col3 LIMIT 5;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=364.26..364.33 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=364.26..364.34 rows=6 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=364.26..364.26 rows=2 width=12)
               ->  Sort  (cost=364.26..364.26 rows=3 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Index Scan using pt_lt_tab_1_prt_part1_col2_idx on pt_lt_tab_1_prt_part1  (cost=0.14..364.23 rows=3 width=12)
                           Index Cond: (col2 < '10'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
(0 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 50 ORDER BY col2,col3 LIMIT 5;
                      QUERY PLAN                      
------------------------------------------------------
 Limit  (cost=0.02..0.03 rows=1 width=0)
   ->  Sort  (cost=0.02..0.03 rows=1 width=0)
         Sort Key: pt_lt_tab.col2, pt_lt_tab.col3
         ->  Result  (cost=0.00..0.01 rows=1 width=0)
               One-Time Filter: false
 Optimizer: Postgres query optimizer
(6 rows)

SELECT * FROM pt_lt_tab WHERE col2 = 25 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   25 |   25 | k    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 = 25 ORDER BY col2,col3 LIMIT 5;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=44.17..44.19 rows=1 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=44.17..44.19 rows=1 width=12)
         Merge Key: pt_lt_tab_1_prt_part3.col3
         ->  Limit  (cost=44.17..44.17 rows=1 width=12)
               ->  Sort  (cost=44.16..44.17 rows=1 width=12)
                     Sort Key: pt_lt_tab_1_prt_part3.col3
                     ->  Index Scan using pt_lt_tab_1_prt_part3_col2_idx on pt_lt_tab_1_prt_part3  (cost=0.14..44.15 rows=1 width=12)
                           Index Cond: (col2 = '25'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_lt_tab WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=50000000016.37..50000000016.48 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=50000000016.37..50000000016.48 rows=5 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=50000000016.37..50000000016.38 rows=2 width=12)
               ->  Sort  (cost=50000000016.37..50000000016.48 rows=15 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=10000000000.00..50000000015.62 rows=15 width=12)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part2  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part3  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part4  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part5  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 10 AND col2 < 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 10 AND col2 < 50 ORDER BY col2,col3 LIMIT 5;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1617.30..1617.37 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=1617.30..1617.51 rows=15 width=12)
         Merge Key: pt_lt_tab_1_prt_part2.col2, pt_lt_tab_1_prt_part2.col3
         ->  Limit  (cost=1617.30..1617.31 rows=5 width=12)
               ->  Sort  (cost=1617.29..1617.33 rows=13 width=12)
                     Sort Key: pt_lt_tab_1_prt_part2.col2, pt_lt_tab_1_prt_part2.col3
                     ->  Append  (cost=0.14..1617.07 rows=13 width=12)
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col2_idx on pt_lt_tab_1_prt_part2  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 > '10'::numeric) AND (col2 < '50'::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col2_idx on pt_lt_tab_1_prt_part3  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 > '10'::numeric) AND (col2 < '50'::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col2_idx on pt_lt_tab_1_prt_part4  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 > '10'::numeric) AND (col2 < '50'::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col2_idx on pt_lt_tab_1_prt_part5  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 > '10'::numeric) AND (col2 < '50'::numeric))
 Optimizer: Postgres query optimizer
(16 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 10 OR col2 = 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 10 OR col2 = 50 ORDER BY col2,col3 LIMIT 5;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Limit  (cost=44014.69..44014.81 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=44014.69..44014.81 rows=5 width=12)
         Merge Key: pt_lt_tab_1_prt_part2.col2, pt_lt_tab_1_prt_part2.col3
         ->  Limit  (cost=44014.69..44014.71 rows=2 width=12)
               ->  Sort  (cost=44014.69..44014.79 rows=14 width=12)
                     Sort Key: pt_lt_tab_1_prt_part2.col2, pt_lt_tab_1_prt_part2.col3
                     ->  Append  (cost=11000.36..44014.03 rows=14 width=12)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part2  (cost=11000.36..11003.51 rows=4 width=12)
                                 Recheck Cond: col2 > 10::numeric OR col2 = 50::numeric
                                 ->  BitmapOr  (cost=11000.36..11000.36 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part2_col2_idx  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: (col2 > 10::numeric)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part2_col2_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col2 = 50::numeric)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part3  (cost=11000.36..11003.51 rows=4 width=12)
                                 Recheck Cond: col2 > 10::numeric OR col2 = 50::numeric
                                 ->  BitmapOr  (cost=11000.36..11000.36 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part3_col2_idx  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: (col2 > 10::numeric)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part3_col2_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col2 = 50::numeric)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part4  (cost=11000.36..11003.51 rows=4 width=12)
                                 Recheck Cond: col2 > 10::numeric OR col2 = 50::numeric
                                 ->  BitmapOr  (cost=11000.36..11000.36 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part4_col2_idx  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: (col2 > 10::numeric)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part4_col2_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col2 = 50::numeric)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part5  (cost=11000.36..11003.51 rows=4 width=12)
                                 Recheck Cond: col2 > 10::numeric OR col2 = 50::numeric
                                 ->  BitmapOr  (cost=11000.36..11000.36 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part5_col2_idx  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: (col2 > 10::numeric)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part5_col2_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col2 = 50::numeric)
 Optimizer: Postgres query optimizer
(36 rows)

SELECT * FROM pt_lt_tab WHERE col2 between 10 AND 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   10 |   10 | c    | t
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 between 10 AND 50 ORDER BY col2,col3 LIMIT 5;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1661.47..1661.54 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=1661.47..1661.68 rows=15 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=1661.47..1661.48 rows=5 width=12)
               ->  Sort  (cost=1661.47..1661.50 rows=14 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..1661.23 rows=14 width=12)
                           ->  Index Scan using pt_lt_tab_1_prt_part1_col2_idx on pt_lt_tab_1_prt_part1  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col2_idx on pt_lt_tab_1_prt_part2  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col2_idx on pt_lt_tab_1_prt_part3  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col2_idx on pt_lt_tab_1_prt_part4  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col2_idx on pt_lt_tab_1_prt_part5  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
 Optimizer: Postgres query optimizer
(18 rows)

DROP INDEX idx1;
-- @description multiple column b-tree index
CREATE INDEX idx1 on pt_lt_tab(col1,col2);
SELECT * FROM pt_lt_tab WHERE col1 < 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 < 10 ORDER BY col2,col3 LIMIT 5;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=580.96..581.03 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=580.96..581.17 rows=15 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=580.96..580.97 rows=5 width=12)
               ->  Sort  (cost=580.96..580.98 rows=7 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..580.85 rows=7 width=12)
                           ->  Index Scan using pt_lt_tab_1_prt_part1_col1_col2_idx on pt_lt_tab_1_prt_part1  (cost=0.14..404.24 rows=3 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col1_col2_idx on pt_lt_tab_1_prt_part2  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col1_col2_idx on pt_lt_tab_1_prt_part3  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col1_col2_idx on pt_lt_tab_1_prt_part4  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col1_col2_idx on pt_lt_tab_1_prt_part5  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: (col1 < 10)
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 > 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
(0 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 > 50 ORDER BY col2,col3 LIMIT 5;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=5500.82..5500.93 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=5500.82..5500.93 rows=5 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=5500.82..5500.83 rows=2 width=12)
               ->  Sort  (cost=5500.82..5500.83 rows=2 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..5500.76 rows=2 width=12)
                           ->  Index Scan using pt_lt_tab_1_prt_part1_col1_col2_idx on pt_lt_tab_1_prt_part1  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col1_col2_idx on pt_lt_tab_1_prt_part2  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col1_col2_idx on pt_lt_tab_1_prt_part3  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col1_col2_idx on pt_lt_tab_1_prt_part4  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col1_col2_idx on pt_lt_tab_1_prt_part5  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: (col1 > 50)
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col2 = 25 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   25 |   25 | k    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 = 25 ORDER BY col2,col3 LIMIT 5;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=404.23..404.26 rows=1 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=404.23..404.26 rows=1 width=12)
         Merge Key: pt_lt_tab_1_prt_part3.col3
         ->  Limit  (cost=404.23..404.24 rows=1 width=12)
               ->  Sort  (cost=404.23..404.23 rows=1 width=12)
                     Sort Key: pt_lt_tab_1_prt_part3.col3
                     ->  Index Scan using pt_lt_tab_1_prt_part3_col1_col2_idx on pt_lt_tab_1_prt_part3  (cost=0.14..404.22 rows=1 width=12)
                           Index Cond: (col2 = '25'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_lt_tab WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=50000000016.37..50000000016.48 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=50000000016.37..50000000016.48 rows=5 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=50000000016.37..50000000016.38 rows=2 width=12)
               ->  Sort  (cost=50000000016.37..50000000016.48 rows=15 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=10000000000.00..50000000015.62 rows=15 width=12)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part2  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part3  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part4  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part5  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 10 AND col1 = 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
(0 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 10 AND col1 = 10 ORDER BY col2,col3 LIMIT 5;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=4400.66..4400.75 rows=4 width=12)
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=4400.66..4400.75 rows=4 width=12)
         Merge Key: pt_lt_tab_1_prt_part2.col2, pt_lt_tab_1_prt_part2.col3
         ->  Limit  (cost=4400.66..4400.67 rows=2 width=12)
               ->  Sort  (cost=4400.66..4400.67 rows=2 width=12)
                     Sort Key: pt_lt_tab_1_prt_part2.col2, pt_lt_tab_1_prt_part2.col3
                     ->  Append  (cost=0.14..4400.62 rows=2 width=12)
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col1_col2_idx on pt_lt_tab_1_prt_part2  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: ((col1 = 10) AND (col2 > 10::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col1_col2_idx on pt_lt_tab_1_prt_part3  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: ((col1 = 10) AND (col2 > 10::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col1_col2_idx on pt_lt_tab_1_prt_part4  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: ((col1 = 10) AND (col2 > 10::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col1_col2_idx on pt_lt_tab_1_prt_part5  (cost=0.14..1100.15 rows=1 width=12)
                                 Index Cond: ((col1 = 10) AND (col2 > 10::numeric))
 Optimizer: Postgres query optimizer
(16 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 10.00 OR col1 = 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 10.00 OR col1 = 50 ORDER BY col2,col3 LIMIT 5;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=46115.01..46115.12 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=46115.01..46115.12 rows=5 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=46115.01..46115.02 rows=2 width=12)
               ->  Sort  (cost=46115.01..46115.11 rows=14 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=11000.35..55114.40 rows=14 width=12)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part1  (cost=11000.35..11100.37 rows=1 width=12)
                                 Recheck Cond: ((col2 > 10.00) OR (col1 = 50))
                                 ->  BitmapOr  (cost=11000.35..11000.35 rows=1 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part1_col1_col2_idx  (cost=0.00..10000.21 rows=1 width=0)
                                             Index Cond: (col2 > 10.00)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part1_col1_col2_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col1 = 50)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part2  (cost=11000.36..11003.51 rows=4 width=12)
                                 Recheck Cond: col2 > 10.00 OR col1 = 50
                                 ->  BitmapOr  (cost=11000.36..11000.36 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part2_col1_col2_idx  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: (col2 > 10.00)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part2_col1_col2_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col1 = 50)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part3  (cost=11000.36..11003.51 rows=4 width=12)
                                 Recheck Cond: col2 > 10.00 OR col1 = 50
                                 ->  BitmapOr  (cost=11000.36..11000.36 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part3_col1_col2_idx  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: (col2 > 10.00)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part3_col1_col2_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col1 = 50)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part4  (cost=11000.36..11003.51 rows=4 width=12)
                                 Recheck Cond: col2 > 10.00 OR col1 = 50
                                 ->  BitmapOr  (cost=11000.36..11000.36 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part4_col1_col2_idx  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: (col2 > 10.00)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part4_col1_col2_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col1 = 50)
                           ->  Bitmap Heap Scan on pt_lt_tab_1_prt_part5  (cost=11000.36..11003.51 rows=4 width=12)
                                 Recheck Cond: col2 > 10.00 OR col1 = 50
                                 ->  BitmapOr  (cost=11000.36..11000.36 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part5_col1_col2_idx  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: (col2 > 10.00)
                                       ->  Bitmap Index Scan on pt_lt_tab_1_prt_part5_col1_col2_idx  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: (col1 = 50)
 Optimizer: Postgres query optimizer
(43 rows)

SELECT * FROM pt_lt_tab WHERE col2 between 10 AND 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   10 |   10 | c    | t
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 between 10 AND 50 ORDER BY col2,col3 LIMIT 5;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=2021.56..2021.63 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=2021.56..2021.77 rows=15 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=2021.56..2021.57 rows=5 width=12)
               ->  Sort  (cost=2021.56..2021.59 rows=14 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..2021.32 rows=14 width=12)
                           ->  Index Scan using pt_lt_tab_1_prt_part1_col1_col2_idx on pt_lt_tab_1_prt_part1  (cost=0.14..404.25 rows=1 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col1_col2_idx on pt_lt_tab_1_prt_part2  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col1_col2_idx on pt_lt_tab_1_prt_part3  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col1_col2_idx on pt_lt_tab_1_prt_part4  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col1_col2_idx on pt_lt_tab_1_prt_part5  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
 Optimizer: Postgres query optimizer
(18 rows)

DROP INDEX idx1;
-- @description multi-column unique constraint (= b-tree index). Essentially the
-- same as the previous case, but the columns are the other way 'round, and we
-- do this on the table with default partition.
ALTER TABLE pt_lt_tab_df ADD CONSTRAINT col2_col1_unique unique(col2,col1);
SELECT * FROM pt_lt_tab_df WHERE col1 < 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col1 < 10 ORDER BY col2,col3 LIMIT 5;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=2425.50..2425.57 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=2425.50..2425.71 rows=15 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
         ->  Limit  (cost=2425.50..2425.51 rows=5 width=12)
               ->  Sort  (cost=2425.49..2425.51 rows=8 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
                     ->  Append  (cost=0.14..2425.37 rows=8 width=12)
                           ->  Index Scan using pt_lt_tab_df_1_prt_part1_col2_col1_key on pt_lt_tab_df_1_prt_part1  (cost=0.14..404.24 rows=3 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_df_1_prt_part2_col2_col1_key on pt_lt_tab_df_1_prt_part2  (cost=0.14..404.22 rows=1 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_df_1_prt_part3_col2_col1_key on pt_lt_tab_df_1_prt_part3  (cost=0.14..404.22 rows=1 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_df_1_prt_part4_col2_col1_key on pt_lt_tab_df_1_prt_part4  (cost=0.14..404.22 rows=1 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_df_1_prt_part5_col2_col1_key on pt_lt_tab_df_1_prt_part5  (cost=0.14..404.22 rows=1 width=12)
                                 Index Cond: (col1 < 10)
                           ->  Index Scan using pt_lt_tab_df_1_prt_def_col2_col1_key on pt_lt_tab_df_1_prt_def  (cost=0.14..404.24 rows=1 width=12)
                                 Index Cond: (col1 < 10)
 Optimizer: Postgres query optimizer
(20 rows)

SELECT * FROM pt_lt_tab_df WHERE col1 > 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   51 |   51 | u    | t
   52 |   52 | u    | t
   53 |   53 | u    | t
   54 |   54 | x    | t
   55 |   55 | x    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col1 > 50 ORDER BY col2,col3 LIMIT 5;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=2425.50..2425.57 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=2425.50..2425.71 rows=15 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
         ->  Limit  (cost=2425.50..2425.51 rows=5 width=12)
               ->  Sort  (cost=2425.49..2425.51 rows=8 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
                     ->  Append  (cost=0.14..2425.37 rows=8 width=12)
                           ->  Index Scan using pt_lt_tab_df_1_prt_part1_col2_col1_key on pt_lt_tab_df_1_prt_part1  (cost=0.14..404.22 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_df_1_prt_part2_col2_col1_key on pt_lt_tab_df_1_prt_part2  (cost=0.14..404.22 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_df_1_prt_part3_col2_col1_key on pt_lt_tab_df_1_prt_part3  (cost=0.14..404.22 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_df_1_prt_part4_col2_col1_key on pt_lt_tab_df_1_prt_part4  (cost=0.14..404.22 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_df_1_prt_part5_col2_col1_key on pt_lt_tab_df_1_prt_part5  (cost=0.14..404.22 rows=1 width=12)
                                 Index Cond: (col1 > 50)
                           ->  Index Scan using pt_lt_tab_df_1_prt_def_col2_col1_key on pt_lt_tab_df_1_prt_def  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: (col1 > 50)
 Optimizer: Postgres query optimizer
(20 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 = 25 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   25 |   25 | k    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 = 25 ORDER BY col2,col3 LIMIT 5;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=44.17..44.19 rows=1 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=44.17..44.19 rows=1 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part3.col3
         ->  Limit  (cost=44.17..44.17 rows=1 width=12)
               ->  Sort  (cost=44.16..44.17 rows=1 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part3.col3
                     ->  Index Scan using pt_lt_tab_df_1_prt_part3_col2_col1_key on pt_lt_tab_df_1_prt_part3  (cost=0.14..44.15 rows=1 width=12)
                           Index Cond: (col2 = '25'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=60000000019.74..60000000019.85 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=60000000019.74..60000000019.85 rows=5 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
         ->  Limit  (cost=60000000019.74..60000000019.75 rows=2 width=12)
               ->  Sort  (cost=60000000019.74..60000000019.88 rows=20 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
                     ->  Append  (cost=10000000000.00..60000000018.79 rows=20 width=12)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part1  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part2  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part3  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part4  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def  (cost=10000000000.00..10000000003.16 rows=5 width=12)
                                 Filter: col2 <> 10::numeric
 Optimizer: Postgres query optimizer
(20 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 > 10 AND col1 = 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
(0 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 > 10 AND col1 = 10 ORDER BY col2,col3 LIMIT 5;
                                                                        QUERY PLAN                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=48201.28..48201.40 rows=5 width=12)
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=48201.28..48201.40 rows=5 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part2.col2, pt_lt_tab_df_1_prt_part2.col3
         ->  Limit  (cost=48201.28..48201.30 rows=2 width=12)
               ->  Sort  (cost=48201.28..48201.30 rows=2 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part2.col2, pt_lt_tab_df_1_prt_part2.col3
                     ->  Append  (cost=0.14..48201.23 rows=2 width=12)
                           ->  Index Scan using pt_lt_tab_df_1_prt_part2_col2_col1_key on pt_lt_tab_df_1_prt_part2  (cost=0.14..10100.25 rows=1 width=12)
                                 Index Cond: col2 > 10::numeric AND col1 = 10
                           ->  Index Scan using pt_lt_tab_df_1_prt_part3_col2_col1_key on pt_lt_tab_df_1_prt_part3  (cost=0.14..10100.25 rows=1 width=12)
                                 Index Cond: col2 > 10::numeric AND col1 = 10
                           ->  Index Scan using pt_lt_tab_df_1_prt_part4_col2_col1_key on pt_lt_tab_df_1_prt_part4  (cost=0.14..10100.25 rows=1 width=12)
                                 Index Cond: col2 > 10::numeric AND col1 = 10
                           ->  Index Scan using pt_lt_tab_df_1_prt_part5_col2_col1_key on pt_lt_tab_df_1_prt_part5  (cost=0.14..10100.25 rows=1 width=12)
                                 Index Cond: col2 > 10::numeric AND col1 = 10
                           ->  Index Scan using pt_lt_tab_df_1_prt_def_col2_col1_key on pt_lt_tab_df_1_prt_def  (cost=0.14..7800.25 rows=1 width=12)
                                 Index Cond: col2 > 10::numeric AND col1 = 10
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 > 10.00 OR col1 = 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 > 10.00 OR col1 = 50 ORDER BY col2,col3 LIMIT 5;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=108819.13..108819.24 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=108819.13..108819.24 rows=5 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
         ->  Limit  (cost=108819.13..108819.14 rows=2 width=12)
               ->  Sort  (cost=108819.13..108819.26 rows=18 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
                     ->  Append  (cost=11000.35..108818.28 rows=18 width=12)
                           ->  Bitmap Heap Scan on pt_lt_tab_df_1_prt_part1  (cost=11000.35..11100.37 rows=1 width=12)
                                 Recheck Cond: col2 > 10.00 OR col1 = 50
                                 ->  BitmapOr  (cost=11000.35..11000.35 rows=1 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_df_1_prt_part1_col2_col1_key  (cost=0.00..1000.14 rows=1 width=0)
                                             Index Cond: col2 > 10.00
                                       ->  Bitmap Index Scan on pt_lt_tab_df_1_prt_part1_col2_col1_key  (cost=0.00..10000.21 rows=1 width=0)
                                             Index Cond: col1 = 50
                           ->  Bitmap Heap Scan on pt_lt_tab_df_1_prt_part2  (cost=20000.42..20003.57 rows=4 width=12)
                                 Recheck Cond: col2 > 10.00 OR col1 = 50
                                 ->  BitmapOr  (cost=20000.42..20000.42 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_df_1_prt_part2_col2_col1_key  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: col2 > 10.00
                                       ->  Bitmap Index Scan on pt_lt_tab_df_1_prt_part2_col2_col1_key  (cost=0.00..10000.21 rows=1 width=0)
                                             Index Cond: col1 = 50
                           ->  Bitmap Heap Scan on pt_lt_tab_df_1_prt_part3  (cost=20000.42..20003.57 rows=4 width=12)
                                 Recheck Cond: col2 > 10.00 OR col1 = 50
                                 ->  BitmapOr  (cost=20000.42..20000.42 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_df_1_prt_part3_col2_col1_key  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: col2 > 10.00
                                       ->  Bitmap Index Scan on pt_lt_tab_df_1_prt_part3_col2_col1_key  (cost=0.00..10000.21 rows=1 width=0)
                                             Index Cond: col1 = 50
                           ->  Bitmap Heap Scan on pt_lt_tab_df_1_prt_part4  (cost=20000.42..20003.57 rows=4 width=12)
                                 Recheck Cond: col2 > 10.00 OR col1 = 50
                                 ->  BitmapOr  (cost=20000.42..20000.42 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_df_1_prt_part4_col2_col1_key  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: col2 > 10.00
                                       ->  Bitmap Index Scan on pt_lt_tab_df_1_prt_part4_col2_col1_key  (cost=0.00..10000.21 rows=1 width=0)
                                             Index Cond: col1 = 50
                           ->  Bitmap Heap Scan on pt_lt_tab_df_1_prt_part5  (cost=20000.42..20003.57 rows=4 width=12)
                                 Recheck Cond: col2 > 10.00 OR col1 = 50
                                 ->  BitmapOr  (cost=20000.42..20000.42 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_df_1_prt_part5_col2_col1_key  (cost=0.00..10000.21 rows=4 width=0)
                                             Index Cond: col2 > 10.00
                                       ->  Bitmap Index Scan on pt_lt_tab_df_1_prt_part5_col2_col1_key  (cost=0.00..10000.21 rows=1 width=0)
                                             Index Cond: col1 = 50
                           ->  Bitmap Heap Scan on pt_lt_tab_df_1_prt_def  (cost=17700.45..17703.61 rows=4 width=12)
                                 Recheck Cond: col2 > 10.00 OR col1 = 50
                                 ->  BitmapOr  (cost=17700.45..17700.45 rows=4 width=0)
                                       ->  Bitmap Index Scan on pt_lt_tab_df_1_prt_def_col2_col1_key  (cost=0.00..7700.21 rows=4 width=0)
                                             Index Cond: col2 > 10.00
                                       ->  Bitmap Index Scan on pt_lt_tab_df_1_prt_def_col2_col1_key  (cost=0.00..10000.23 rows=1 width=0)
                                             Index Cond: col1 = 50
 Optimizer: Postgres query optimizer
(50 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 between 10 AND 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   10 |   10 | c    | t
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 between 10 AND 50 ORDER BY col2,col3 LIMIT 5;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1697.64..1697.71 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=1697.64..1697.85 rows=15 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
         ->  Limit  (cost=1697.64..1697.65 rows=5 width=12)
               ->  Sort  (cost=1697.64..1697.68 rows=15 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
                     ->  Append  (cost=0.14..1697.38 rows=15 width=12)
                           ->  Index Scan using pt_lt_tab_df_1_prt_part1_col2_col1_key on pt_lt_tab_df_1_prt_part1  (cost=0.14..44.15 rows=1 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_df_1_prt_part2_col2_col1_key on pt_lt_tab_df_1_prt_part2  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_df_1_prt_part3_col2_col1_key on pt_lt_tab_df_1_prt_part3  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_df_1_prt_part4_col2_col1_key on pt_lt_tab_df_1_prt_part4  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_df_1_prt_part5_col2_col1_key on pt_lt_tab_df_1_prt_part5  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using pt_lt_tab_df_1_prt_def_col2_col1_key on pt_lt_tab_df_1_prt_def  (cost=0.14..36.15 rows=1 width=12)
                                 Index Cond: ((col2 >= '10'::numeric) AND (col2 <= '50'::numeric))
 Optimizer: Postgres query optimizer
(20 rows)

ALTER TABLE pt_lt_tab_df DROP CONSTRAINT col2_col1_unique;
-- @description Heterogeneous index, index on partition key, b-tree index on all partitions
CREATE INDEX idx1 on pt_lt_tab_1_prt_part1(col2);
CREATE INDEX idx2 on pt_lt_tab_1_prt_part2(col2);
CREATE INDEX idx3 on pt_lt_tab_1_prt_part3(col2);
CREATE INDEX idx4 on pt_lt_tab_1_prt_part4(col2);
CREATE INDEX idx5 on pt_lt_tab_1_prt_part5(col2);
SELECT * FROM pt_lt_tab WHERE col2 between 1 AND 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 between 1 AND 50 ORDER BY col2,col3 LIMIT 5;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Limit  (cost=2021.62..2021.69 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=2021.62..2021.84 rows=15 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=2021.62..2021.64 rows=5 width=12)
               ->  Sort  (cost=2021.62..2021.66 rows=17 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..2021.34 rows=17 width=12)
                           ->  Index Scan using idx1 on pt_lt_tab_1_prt_part1  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using idx2 on pt_lt_tab_1_prt_part2  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using idx3 on pt_lt_tab_1_prt_part3  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using idx4 on pt_lt_tab_1_prt_part4  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '50'::numeric))
                           ->  Index Scan using idx5 on pt_lt_tab_1_prt_part5  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '50'::numeric))
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 5 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    6 |    6 | b    | t
    7 |    7 | c    | t
    8 |    8 | c    | t
    9 |    9 | c    | t
   10 |   10 | c    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 5 ORDER BY col2,col3 LIMIT 5;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1861.43..1861.50 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=1861.43..1861.64 rows=15 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=1861.43..1861.44 rows=5 width=12)
               ->  Sort  (cost=1861.42..1861.46 rows=15 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..1861.17 rows=15 width=12)
                           ->  Index Scan using idx1 on pt_lt_tab_1_prt_part1  (cost=0.14..244.20 rows=2 width=12)
                                 Index Cond: (col2 > '5'::numeric)
                           ->  Index Scan using idx2 on pt_lt_tab_1_prt_part2  (cost=0.14..404.24 rows=3 width=12)
                                 Index Cond: (col2 > '5'::numeric)
                           ->  Index Scan using idx3 on pt_lt_tab_1_prt_part3  (cost=0.14..404.24 rows=3 width=12)
                                 Index Cond: (col2 > '5'::numeric)
                           ->  Index Scan using idx4 on pt_lt_tab_1_prt_part4  (cost=0.14..404.24 rows=3 width=12)
                                 Index Cond: (col2 > '5'::numeric)
                           ->  Index Scan using idx5 on pt_lt_tab_1_prt_part5  (cost=0.14..404.24 rows=3 width=12)
                                 Index Cond: (col2 > '5'::numeric)
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col2 = 5 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    5 |    5 | b    | t
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 = 5 ORDER BY col2,col3 LIMIT 5;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Limit  (cost=44.17..44.19 rows=1 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=44.17..44.19 rows=1 width=12)
         Merge Key: pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=44.17..44.17 rows=1 width=12)
               ->  Sort  (cost=44.16..44.17 rows=1 width=12)
                     Sort Key: pt_lt_tab_1_prt_part1.col3
                     ->  Index Scan using idx1 on pt_lt_tab_1_prt_part1  (cost=0.14..44.15 rows=1 width=12)
                           Index Cond: (col2 = '5'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

DROP INDEX idx1;
DROP INDEX idx2;
DROP INDEX idx3;
DROP INDEX idx4;
DROP INDEX idx5;
-- @description Heterogeneous index,b-tree index on all parts,index, index on non-partition col
CREATE INDEX idx1 on pt_lt_tab_df_1_prt_part1(col1);
CREATE INDEX idx2 on pt_lt_tab_df_1_prt_part2(col1);
CREATE INDEX idx3 on pt_lt_tab_df_1_prt_part3(col1);
CREATE INDEX idx4 on pt_lt_tab_df_1_prt_part4(col1);
CREATE INDEX idx5 on pt_lt_tab_df_1_prt_part5(col1);
CREATE INDEX idx6 on pt_lt_tab_df_1_prt_def(col1);
SELECT * FROM pt_lt_tab_df WHERE col1 between 1 AND 100 ORDER BY col1 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col1 between 1 AND 100 ORDER BY col1 LIMIT 5;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.89..4936.95 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.89..4936.95 rows=5 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col1
         ->  Limit  (cost=0.89..4936.85 rows=2 width=12)
               ->  Merge Append  (cost=0.89..59220.63 rows=20 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col1
                     ->  Index Scan using idx1 on pt_lt_tab_df_1_prt_part1  (cost=0.14..10193.85 rows=4 width=12)
                           Index Cond: col1 >= 1 AND col1 <= 100
                     ->  Index Scan using idx2 on pt_lt_tab_df_1_prt_part2  (cost=0.14..10285.61 rows=4 width=12)
                           Index Cond: col1 >= 1 AND col1 <= 100
                     ->  Index Scan using idx3 on pt_lt_tab_df_1_prt_part3  (cost=0.14..10252.62 rows=4 width=12)
                           Index Cond: col1 >= 1 AND col1 <= 100
                     ->  Index Scan using idx4 on pt_lt_tab_df_1_prt_part4  (cost=0.14..10217.07 rows=4 width=12)
                           Index Cond: col1 >= 1 AND col1 <= 100
                     ->  Index Scan using idx5 on pt_lt_tab_df_1_prt_part5  (cost=0.14..10271.47 rows=4 width=12)
                           Index Cond: col1 >= 1 AND col1 <= 100
                     ->  Index Scan using idx6 on pt_lt_tab_df_1_prt_def  (cost=0.14..7998.23 rows=4 width=12)
                           Index Cond: col1 >= 1 AND col1 <= 100
 Optimizer: Postgres query optimizer
(19 rows)

SELECT * FROM pt_lt_tab_df WHERE col1 > 50 ORDER BY col1 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   51 |   51 | u    | t
   52 |   52 | u    | t
   53 |   53 | u    | t
   54 |   54 | x    | t
   55 |   55 | x    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col1 > 50 ORDER BY col1 LIMIT 5;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.89..4500.82 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.89..4500.82 rows=5 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col1
         ->  Limit  (cost=0.89..4500.72 rows=2 width=12)
               ->  Merge Append  (cost=0.89..13499.47 rows=5 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col1
                     ->  Index Scan using idx1 on pt_lt_tab_df_1_prt_part1  (cost=0.14..1100.15 rows=1 width=12)
                           Index Cond: col1 > 50
                     ->  Index Scan using idx2 on pt_lt_tab_df_1_prt_part2  (cost=0.14..1100.15 rows=1 width=12)
                           Index Cond: col1 > 50
                     ->  Index Scan using idx3 on pt_lt_tab_df_1_prt_part3  (cost=0.14..1100.15 rows=1 width=12)
                           Index Cond: col1 > 50
                     ->  Index Scan using idx4 on pt_lt_tab_df_1_prt_part4  (cost=0.14..1100.15 rows=1 width=12)
                           Index Cond: col1 > 50
                     ->  Index Scan using idx5 on pt_lt_tab_df_1_prt_part5  (cost=0.14..1100.15 rows=1 width=12)
                           Index Cond: col1 > 50
                     ->  Index Scan using idx6 on pt_lt_tab_df_1_prt_def  (cost=0.14..7998.21 rows=4 width=12)
                           Index Cond: col1 > 50
 Optimizer: Postgres query optimizer
(19 rows)

SELECT * FROM pt_lt_tab_df WHERE col1 < 50 ORDER BY col1 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col1 < 50 ORDER BY col1 LIMIT 5;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.89..5111.42 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.89..5111.42 rows=5 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col1
         ->  Limit  (cost=0.89..5111.32 rows=2 width=12)
               ->  Merge Append  (cost=0.89..52122.17 rows=17 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col1
                     ->  Index Scan using idx1 on pt_lt_tab_df_1_prt_part1  (cost=0.14..10193.83 rows=4 width=12)
                           Index Cond: col1 < 50
                     ->  Index Scan using idx2 on pt_lt_tab_df_1_prt_part2  (cost=0.14..10285.58 rows=4 width=12)
                           Index Cond: col1 < 50
                     ->  Index Scan using idx3 on pt_lt_tab_df_1_prt_part3  (cost=0.14..10252.59 rows=4 width=12)
                           Index Cond: col1 < 50
                     ->  Index Scan using idx4 on pt_lt_tab_df_1_prt_part4  (cost=0.14..10217.04 rows=4 width=12)
                           Index Cond: col1 < 50
                     ->  Index Scan using idx5 on pt_lt_tab_df_1_prt_part5  (cost=0.14..10271.44 rows=4 width=12)
                           Index Cond: col1 < 50
                     ->  Index Scan using idx6 on pt_lt_tab_df_1_prt_def  (cost=0.14..900.15 rows=1 width=12)
                           Index Cond: col1 < 50
 Optimizer: Postgres query optimizer
(19 rows)

DROP INDEX idx1;
DROP INDEX idx2;
DROP INDEX idx3;
DROP INDEX idx4;
DROP INDEX idx5;
DROP INDEX idx6;
-- @description Heterogeneous index,b-tree index on all parts including default, index on partition col
CREATE INDEX idx1 on pt_lt_tab_df_1_prt_part1(col2);
CREATE INDEX idx2 on pt_lt_tab_df_1_prt_part2(col2);
CREATE INDEX idx3 on pt_lt_tab_df_1_prt_part3(col2);
CREATE INDEX idx4 on pt_lt_tab_df_1_prt_part4(col2);
CREATE INDEX idx5 on pt_lt_tab_df_1_prt_part5(col2);
CREATE INDEX idx6 on pt_lt_tab_df_1_prt_def(col2);
SELECT * FROM pt_lt_tab_df WHERE col2 between 1 AND 100 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 between 1 AND 100 ORDER BY col2,col3 LIMIT 5;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Limit  (cost=2333.95..2334.02 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=2333.95..2334.16 rows=15 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
         ->  Limit  (cost=2333.95..2333.96 rows=5 width=12)
               ->  Sort  (cost=2333.94..2333.99 rows=20 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
                     ->  Append  (cost=0.14..2333.61 rows=20 width=12)
                           ->  Index Scan using idx1 on pt_lt_tab_df_1_prt_part1  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '100'::numeric))
                           ->  Index Scan using idx2 on pt_lt_tab_df_1_prt_part2  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '100'::numeric))
                           ->  Index Scan using idx3 on pt_lt_tab_df_1_prt_part3  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '100'::numeric))
                           ->  Index Scan using idx4 on pt_lt_tab_df_1_prt_part4  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '100'::numeric))
                           ->  Index Scan using idx5 on pt_lt_tab_df_1_prt_part5  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '100'::numeric))
                           ->  Index Scan using idx6 on pt_lt_tab_df_1_prt_def  (cost=0.14..312.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '100'::numeric))
 Optimizer: Postgres query optimizer
(20 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 > 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   51 |   51 | u    | t
   52 |   52 | u    | t
   53 |   53 | u    | t
   54 |   54 | x    | t
   55 |   55 | x    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 > 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=312.27..312.35 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=312.27..312.37 rows=7 width=12)
         Merge Key: pt_lt_tab_df_1_prt_def.col2, pt_lt_tab_df_1_prt_def.col3
         ->  Limit  (cost=312.27..312.28 rows=2 width=12)
               ->  Sort  (cost=312.27..312.28 rows=3 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_def.col2, pt_lt_tab_df_1_prt_def.col3
                     ->  Index Scan using idx6 on pt_lt_tab_df_1_prt_def  (cost=0.14..312.24 rows=3 width=12)
                           Index Cond: (col2 > '50'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 = 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   50 |   50 | q    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 = 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit  (cost=44.17..44.19 rows=1 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=44.17..44.19 rows=1 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part5.col3
         ->  Limit  (cost=44.17..44.17 rows=1 width=12)
               ->  Sort  (cost=44.16..44.17 rows=1 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part5.col3
                     ->  Index Scan using idx5 on pt_lt_tab_df_1_prt_part5  (cost=0.14..44.15 rows=1 width=12)
                           Index Cond: (col2 = '50'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=60000000019.74..60000000019.85 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=60000000019.74..60000000019.85 rows=5 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
         ->  Limit  (cost=60000000019.74..60000000019.75 rows=2 width=12)
               ->  Sort  (cost=60000000019.74..60000000019.88 rows=20 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
                     ->  Append  (cost=10000000000.00..60000000018.79 rows=20 width=12)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part1  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part2  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part3  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part4  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5  (cost=10000000000.00..10000000003.12 rows=3 width=12)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def  (cost=10000000000.00..10000000003.16 rows=5 width=12)
                                 Filter: col2 <> 10::numeric
 Optimizer: Postgres query optimizer
(20 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 between 1 AND 100 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 between 1 AND 100 ORDER BY col2,col3 LIMIT 5;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Limit  (cost=2333.95..2334.02 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=2333.95..2334.16 rows=15 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
         ->  Limit  (cost=2333.95..2333.96 rows=5 width=12)
               ->  Sort  (cost=2333.94..2333.99 rows=20 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
                     ->  Append  (cost=0.14..2333.61 rows=20 width=12)
                           ->  Index Scan using idx1 on pt_lt_tab_df_1_prt_part1  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '100'::numeric))
                           ->  Index Scan using idx2 on pt_lt_tab_df_1_prt_part2  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '100'::numeric))
                           ->  Index Scan using idx3 on pt_lt_tab_df_1_prt_part3  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '100'::numeric))
                           ->  Index Scan using idx4 on pt_lt_tab_df_1_prt_part4  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '100'::numeric))
                           ->  Index Scan using idx5 on pt_lt_tab_df_1_prt_part5  (cost=0.14..404.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '100'::numeric))
                           ->  Index Scan using idx6 on pt_lt_tab_df_1_prt_def  (cost=0.14..312.27 rows=3 width=12)
                                 Index Cond: ((col2 >= '1'::numeric) AND (col2 <= '100'::numeric))
 Optimizer: Postgres query optimizer
(20 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 < 50 AND col1 > 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 < 50 AND col1 > 10 ORDER BY col2,col3 LIMIT 5;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Limit  (cost=2057.67..2057.74 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=2057.67..2057.88 rows=15 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
         ->  Limit  (cost=2057.67..2057.68 rows=5 width=12)
               ->  Sort  (cost=2057.67..2057.71 rows=15 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
                     ->  Append  (cost=0.14..2057.41 rows=15 width=12)
                           ->  Index Scan using idx1 on pt_lt_tab_df_1_prt_part1  (cost=0.14..404.25 rows=1 width=12)
                                 Index Cond: (col2 < '50'::numeric)
                                 Filter: (col1 > 10)
                           ->  Index Scan using idx2 on pt_lt_tab_df_1_prt_part2  (cost=0.14..404.25 rows=3 width=12)
                                 Index Cond: (col2 < '50'::numeric)
                                 Filter: (col1 > 10)
                           ->  Index Scan using idx3 on pt_lt_tab_df_1_prt_part3  (cost=0.14..404.25 rows=3 width=12)
                                 Index Cond: (col2 < '50'::numeric)
                                 Filter: (col1 > 10)
                           ->  Index Scan using idx4 on pt_lt_tab_df_1_prt_part4  (cost=0.14..404.25 rows=3 width=12)
                                 Index Cond: (col2 < '50'::numeric)
                                 Filter: (col1 > 10)
                           ->  Index Scan using idx5 on pt_lt_tab_df_1_prt_part5  (cost=0.14..404.25 rows=3 width=12)
                                 Index Cond: (col2 < '50'::numeric)
                                 Filter: (col1 > 10)
                           ->  Index Scan using idx6 on pt_lt_tab_df_1_prt_def  (cost=0.14..36.16 rows=1 width=12)
                                 Index Cond: (col2 < '50'::numeric)
                                 Filter: (col1 > 10)
 Optimizer: Postgres query optimizer
(26 rows)

DROP INDEX idx1;
DROP INDEX idx2;
DROP INDEX idx3;
DROP INDEX idx4;
DROP INDEX idx5;
DROP INDEX idx6;
-- @description Negative tests Combination tests, no index on default partition
CREATE INDEX idx1 on pt_lt_tab_df_1_prt_part1(col2);
CREATE INDEX idx2 on pt_lt_tab_df_1_prt_part2(col2);
CREATE INDEX idx3 on pt_lt_tab_df_1_prt_part3(col2);
CREATE INDEX idx4 on pt_lt_tab_df_1_prt_part4(col2);
CREATE INDEX idx5 on pt_lt_tab_df_1_prt_part5(col2);
SELECT * FROM pt_lt_tab_df WHERE col2 > 51 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   52 |   52 | u    | t
   53 |   53 | u    | t
   54 |   54 | x    | t
   55 |   55 | x    | t
   56 |   56 | x    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 > 51 ORDER BY col2,col3 LIMIT 5;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Limit  (cost=10000000003.31..10000000003.42 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000003.31..10000000003.42 rows=5 width=12)
         Merge Key: pt_lt_tab_df_1_prt_def.col2, pt_lt_tab_df_1_prt_def.col3
         ->  Limit  (cost=10000000003.31..10000000003.32 rows=2 width=12)
               ->  Sort  (cost=10000000003.31..10000000003.33 rows=4 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_def.col2, pt_lt_tab_df_1_prt_def.col3
                     ->  Seq Scan on pt_lt_tab_df_1_prt_def  (cost=10000000000.00..10000000003.16 rows=4 width=12)
                           Filter: (col2 > '51'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 = 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   50 |   50 | q    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 = 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit  (cost=44.17..44.19 rows=1 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=44.17..44.19 rows=1 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part5.col3
         ->  Limit  (cost=44.17..44.17 rows=1 width=12)
               ->  Sort  (cost=44.16..44.17 rows=1 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part5.col3
                     ->  Index Scan using idx5 on pt_lt_tab_df_1_prt_part5  (cost=0.14..44.15 rows=1 width=12)
                           Index Cond: (col2 = '50'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

DROP INDEX idx1;
DROP INDEX idx2;
DROP INDEX idx3;
DROP INDEX idx4;
DROP INDEX idx5;
-- @description Negative tests Combination tests ,index exists on some regular partitions and not on the default partition
CREATE INDEX idx1 on pt_lt_tab_df_1_prt_part1(col2);
CREATE INDEX idx5 on pt_lt_tab_df_1_prt_part5(col2);
SELECT * FROM pt_lt_tab_df WHERE col2 is NULL ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
      |      |      | 
      |      |      | 
      |      |      | 
(3 rows)

DROP INDEX idx1;
DROP INDEX idx5;
-- @description Heterogeneous index,b-tree index on all parts,index , multiple index 
CREATE INDEX idx1 on pt_lt_tab_df_1_prt_part1(col2,col1);
CREATE INDEX idx2 on pt_lt_tab_df_1_prt_part2(col2,col1);
CREATE INDEX idx3 on pt_lt_tab_df_1_prt_part3(col2,col1);
CREATE INDEX idx4 on pt_lt_tab_df_1_prt_part4(col2,col1);
CREATE INDEX idx5 on pt_lt_tab_df_1_prt_part5(col2,col1);
CREATE INDEX idx6 on pt_lt_tab_df_1_prt_def(col2,col1);
SELECT * FROM pt_lt_tab_df WHERE col2 = 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   50 |   50 | q    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 = 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit  (cost=44.17..44.19 rows=1 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=44.17..44.19 rows=1 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part5.col3
         ->  Limit  (cost=44.17..44.17 rows=1 width=12)
               ->  Sort  (cost=44.16..44.17 rows=1 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part5.col3
                     ->  Index Scan using idx5 on pt_lt_tab_df_1_prt_part5  (cost=0.14..44.15 rows=1 width=12)
                           Index Cond: (col2 = '50'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 > 10 AND col1 between 1 AND 100 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 > 10 AND col1 between 1 AND 100 ORDER BY col2,col3 LIMIT 5;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1929.73..1929.80 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=1929.73..1929.95 rows=15 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part2.col2, pt_lt_tab_df_1_prt_part2.col3
         ->  Limit  (cost=1929.73..1929.75 rows=5 width=12)
               ->  Sort  (cost=1929.73..1929.77 rows=16 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part2.col2, pt_lt_tab_df_1_prt_part2.col3
                     ->  Append  (cost=0.14..1929.46 rows=16 width=12)
                           ->  Index Scan using idx2 on pt_lt_tab_df_1_prt_part2  (cost=0.14..404.29 rows=3 width=12)
                                 Index Cond: ((col2 > '10'::numeric) AND (col1 >= 1) AND (col1 <= 100))
                           ->  Index Scan using idx3 on pt_lt_tab_df_1_prt_part3  (cost=0.14..404.29 rows=3 width=12)
                                 Index Cond: ((col2 > '10'::numeric) AND (col1 >= 1) AND (col1 <= 100))
                           ->  Index Scan using idx4 on pt_lt_tab_df_1_prt_part4  (cost=0.14..404.29 rows=3 width=12)
                                 Index Cond: ((col2 > '10'::numeric) AND (col1 >= 1) AND (col1 <= 100))
                           ->  Index Scan using idx5 on pt_lt_tab_df_1_prt_part5  (cost=0.14..404.29 rows=3 width=12)
                                 Index Cond: ((col2 > '10'::numeric) AND (col1 >= 1) AND (col1 <= 100))
                           ->  Index Scan using idx6 on pt_lt_tab_df_1_prt_def  (cost=0.14..312.29 rows=3 width=12)
                                 Index Cond: ((col2 > '10'::numeric) AND (col1 >= 1) AND (col1 <= 100))
 Optimizer: Postgres query optimizer
(18 rows)

SELECT * FROM pt_lt_tab_df WHERE col1 = 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   10 |   10 | c    | t
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col1 = 10 ORDER BY col2,col3 LIMIT 5;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=60601.42..60601.53 rows=5 width=12)
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=60601.42..60601.53 rows=5 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
         ->  Limit  (cost=60601.42..60601.43 rows=2 width=12)
               ->  Sort  (cost=60601.42..60601.44 rows=2 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part1.col2, pt_lt_tab_df_1_prt_part1.col3
                     ->  Append  (cost=0.14..60601.34 rows=2 width=12)
                           ->  Index Scan using idx1 on pt_lt_tab_df_1_prt_part1  (cost=0.14..10100.22 rows=1 width=12)
                                 Index Cond: col1 = 10
                           ->  Index Scan using idx2 on pt_lt_tab_df_1_prt_part2  (cost=0.14..10100.22 rows=1 width=12)
                                 Index Cond: col1 = 10
                           ->  Index Scan using idx3 on pt_lt_tab_df_1_prt_part3  (cost=0.14..10100.22 rows=1 width=12)
                                 Index Cond: col1 = 10
                           ->  Index Scan using idx4 on pt_lt_tab_df_1_prt_part4  (cost=0.14..10100.22 rows=1 width=12)
                                 Index Cond: col1 = 10
                           ->  Index Scan using idx5 on pt_lt_tab_df_1_prt_part5  (cost=0.14..10100.22 rows=1 width=12)
                                 Index Cond: col1 = 10
                           ->  Index Scan using idx6 on pt_lt_tab_df_1_prt_def  (cost=0.14..10100.24 rows=1 width=12)
                                 Index Cond: col1 = 10
 Optimizer: Postgres query optimizer
(20 rows)

DROP INDEX idx1;
DROP INDEX idx2;
DROP INDEX idx3;
DROP INDEX idx4;
DROP INDEX idx5;
DROP INDEX idx6;
-- @description Index exists on some continuous set of partitions, e.g. p1,p2,p3
CREATE INDEX idx1 on pt_lt_tab_df_1_prt_part1(col2);
CREATE INDEX idx2 on pt_lt_tab_df_1_prt_part2(col2);
CREATE INDEX idx3 on pt_lt_tab_df_1_prt_part3(col2);
SELECT * FROM pt_lt_tab_df WHERE col2 = 35 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   35 |   35 | o    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 = 35 ORDER BY col2,col3 LIMIT 5;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Limit  (cost=10000000003.14..10000000003.16 rows=1 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000003.14..10000000003.16 rows=1 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part4.col3
         ->  Limit  (cost=10000000003.14..10000000003.14 rows=1 width=12)
               ->  Sort  (cost=10000000003.14..10000000003.14 rows=1 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part4.col3
                     ->  Seq Scan on pt_lt_tab_df_1_prt_part4  (cost=10000000000.00..10000000003.12 rows=1 width=12)
                           Filter: (col2 = '35'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

DROP INDEX idx1;
DROP INDEX idx2;
DROP INDEX idx3;
-- @description Index exists on some regular partitions and on the default partition [INDEX exists on non-consecutive partitions, e.g. p1,p3,p5]
CREATE INDEX idx1 on pt_lt_tab_df_1_prt_part1(col2);
CREATE INDEX idx5 on pt_lt_tab_df_1_prt_part5(col2);
CREATE INDEX idx6 on pt_lt_tab_df_1_prt_def(col2);
SELECT * FROM pt_lt_tab_df WHERE col2 > 15 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   16 |   16 | f    | t
   17 |   17 | g    | t
   18 |   18 | g    | t
   19 |   19 | g    | t
   20 |   20 | g    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 > 15 ORDER BY col2,col3 LIMIT 5;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=30000000719.87..30000000719.94 rows=5 width=12)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=30000000719.87..30000000720.08 rows=15 width=12)
         Merge Key: pt_lt_tab_df_1_prt_part2.col2, pt_lt_tab_df_1_prt_part2.col3
         ->  Limit  (cost=30000000719.87..30000000719.88 rows=5 width=12)
               ->  Sort  (cost=30000000719.86..30000000719.90 rows=15 width=12)
                     Sort Key: pt_lt_tab_df_1_prt_part2.col2, pt_lt_tab_df_1_prt_part2.col3
                     ->  Append  (cost=10000000000.00..30000000719.61 rows=15 width=12)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part2  (cost=10000000000.00..10000000001.04 rows=2 width=12)
                                 Filter: (col2 > '15'::numeric)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part3  (cost=10000000000.00..10000000001.04 rows=3 width=12)
                                 Filter: (col2 > '15'::numeric)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part4  (cost=10000000000.00..10000000001.04 rows=3 width=12)
                                 Filter: (col2 > '15'::numeric)
                           ->  Index Scan using idx5 on pt_lt_tab_df_1_prt_part5  (cost=0.14..404.24 rows=3 width=12)
                                 Index Cond: (col2 > '15'::numeric)
                           ->  Index Scan using idx6 on pt_lt_tab_df_1_prt_def  (cost=0.14..312.24 rows=3 width=12)
                                 Index Cond: (col2 > '15'::numeric)
 Optimizer: Postgres query optimizer
(18 rows)

DROP INDEX idx1;
DROP INDEX idx5;
DROP INDEX idx6;
--
-- Finally, after running all the other tests on pg_lt_tab, test that
-- partition pruning still works after dropping a column
--
CREATE INDEX idx1 on pt_lt_tab(col4);
ALTER TABLE pt_lt_tab DROP column col1;
NOTICE:  dropping a column that is part of the distribution policy forces a random distribution policy
NOTICE:  dropping a column that is part of the distribution policy forces a random distribution policy
NOTICE:  dropping a column that is part of the distribution policy forces a random distribution policy
NOTICE:  dropping a column that is part of the distribution policy forces a random distribution policy
NOTICE:  dropping a column that is part of the distribution policy forces a random distribution policy
NOTICE:  dropping a column that is part of the distribution policy forces a random distribution policy
SELECT * FROM pt_lt_tab WHERE col4 is False ORDER BY col2,col3 LIMIT 5;
 col2 | col3 | col4 
------+------+------
   21 | i    | f
   22 | i    | f
   23 | i    | f
   24 | k    | f
   25 | k    | f
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col4 is False ORDER BY col2,col3 LIMIT 5;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1300.29..1300.40 rows=5 width=8)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=1300.29..1300.40 rows=5 width=8)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=1300.29..1300.30 rows=2 width=8)
               ->  Sort  (cost=1300.28..1300.36 rows=11 width=8)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..1299.75 rows=11 width=8)
                           ->  Index Scan using pt_lt_tab_1_prt_part1_col4_idx on pt_lt_tab_1_prt_part1  (cost=0.14..40.23 rows=1 width=8)
                                 Index Cond: (col4 = false)
                                 Filter: (col4 IS FALSE)
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col4_idx on pt_lt_tab_1_prt_part2  (cost=0.14..40.23 rows=1 width=8)
                                 Index Cond: (col4 = false)
                                 Filter: (col4 IS FALSE)
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col4_idx on pt_lt_tab_1_prt_part3  (cost=0.14..406.43 rows=4 width=8)
                                 Index Cond: (col4 = false)
                                 Filter: (col4 IS FALSE)
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col4_idx on pt_lt_tab_1_prt_part4  (cost=0.14..406.43 rows=4 width=8)
                                 Index Cond: (col4 = false)
                                 Filter: (col4 IS FALSE)
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col4_idx on pt_lt_tab_1_prt_part5  (cost=0.14..406.43 rows=4 width=8)
                                 Index Cond: (col4 = false)
                                 Filter: (col4 IS FALSE)
 Optimizer: Postgres query optimizer
(23 rows)

SELECT * FROM pt_lt_tab WHERE col4 = False ORDER BY col2,col3 LIMIT 5;
 col2 | col3 | col4 
------+------+------
   21 | i    | f
   22 | i    | f
   23 | i    | f
   24 | k    | f
   25 | k    | f
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col4 = False ORDER BY col2,col3 LIMIT 5;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1300.29..1300.40 rows=5 width=8)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=1300.29..1300.40 rows=5 width=8)
         Merge Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
         ->  Limit  (cost=1300.29..1300.30 rows=2 width=8)
               ->  Sort  (cost=1300.28..1300.36 rows=11 width=8)
                     Sort Key: pt_lt_tab_1_prt_part1.col2, pt_lt_tab_1_prt_part1.col3
                     ->  Append  (cost=0.14..1299.75 rows=11 width=8)
                           ->  Index Scan using pt_lt_tab_1_prt_part1_col4_idx on pt_lt_tab_1_prt_part1  (cost=0.14..40.23 rows=1 width=8)
                                 Index Cond: (col4 = false)
                                 Filter: (NOT col4)
                           ->  Index Scan using pt_lt_tab_1_prt_part2_col4_idx on pt_lt_tab_1_prt_part2  (cost=0.14..40.23 rows=1 width=8)
                                 Index Cond: (col4 = false)
                                 Filter: (NOT col4)
                           ->  Index Scan using pt_lt_tab_1_prt_part3_col4_idx on pt_lt_tab_1_prt_part3  (cost=0.14..406.43 rows=4 width=8)
                                 Index Cond: (col4 = false)
                                 Filter: (NOT col4)
                           ->  Index Scan using pt_lt_tab_1_prt_part4_col4_idx on pt_lt_tab_1_prt_part4  (cost=0.14..406.43 rows=4 width=8)
                                 Index Cond: (col4 = false)
                                 Filter: (NOT col4)
                           ->  Index Scan using pt_lt_tab_1_prt_part5_col4_idx on pt_lt_tab_1_prt_part5  (cost=0.14..406.43 rows=4 width=8)
                                 Index Cond: (col4 = false)
                                 Filter: (NOT col4)
 Optimizer: Postgres query optimizer
(23 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 41 ORDER BY col2,col3 LIMIT 5;
 col2 | col3 | col4 
------+------+------
   42 | p    | f
   43 | p    | f
   44 | s    | f
   45 | s    | f
   46 | s    | f
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 41 ORDER BY col2,col3 LIMIT 5;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Limit  (cost=10000000003.27..10000000003.38 rows=5 width=8)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000003.27..10000000003.38 rows=5 width=8)
         Merge Key: pt_lt_tab_1_prt_part5.col2, pt_lt_tab_1_prt_part5.col3
         ->  Limit  (cost=10000000003.27..10000000003.28 rows=2 width=8)
               ->  Sort  (cost=10000000003.27..10000000003.29 rows=3 width=8)
                     Sort Key: pt_lt_tab_1_prt_part5.col2, pt_lt_tab_1_prt_part5.col3
                     ->  Seq Scan on pt_lt_tab_1_prt_part5  (cost=10000000000.00..10000000003.12 rows=3 width=8)
                           Filter: (col2 > '41'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

ALTER TABLE pt_lt_tab DROP column col4;
SELECT * FROM pt_lt_tab WHERE col2 > 41 ORDER BY col2,col3 LIMIT 5;
 col2 | col3 
------+------
   42 | p
   43 | p
   44 | s
   45 | s
   46 | s
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 41 ORDER BY col2,col3 LIMIT 5;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Limit  (cost=10000000003.27..10000000003.38 rows=5 width=8)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000003.27..10000000003.38 rows=5 width=8)
         Merge Key: pt_lt_tab_1_prt_part5.col2, pt_lt_tab_1_prt_part5.col3
         ->  Limit  (cost=10000000003.27..10000000003.28 rows=2 width=8)
               ->  Sort  (cost=10000000003.27..10000000003.29 rows=3 width=8)
                     Sort Key: pt_lt_tab_1_prt_part5.col2, pt_lt_tab_1_prt_part5.col3
                     ->  Seq Scan on pt_lt_tab_1_prt_part5  (cost=10000000000.00..10000000003.12 rows=3 width=8)
                           Filter: (col2 > '41'::numeric)
 Optimizer: Postgres query optimizer
(9 rows)

--
-- Test a more complicated partitioning scheme, with subpartitions.
--
CREATE TABLE pt_complex (i int, j int, k int, l int, m int) DISTRIBUTED BY (i)
PARTITION BY list(k)
  SUBPARTITION BY list(j) SUBPARTITION TEMPLATE (subpartition p11 values (1), subpartition p12 values(2))
  SUBPARTITION BY list(l) SUBPARTITION TEMPLATE (subpartition p11 values (1), subpartition p12 values(2))
( partition p1 values(1), partition p2 values(2));
INSERT INTO pt_complex VALUES (1, 1, 1, 1, 1), (2, 2, 2, 2, 2);
CREATE INDEX i_pt_complex ON pt_complex (i);
SELECT * FROM pt_complex WHERE i = 1 AND j = 1;
 i | j | k | l | m 
---+---+---+---+---
 1 | 1 | 1 | 1 | 1
(1 row)

EXPLAIN SELECT * FROM pt_complex WHERE i = 1 AND j = 1;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=100.65..6405.82 rows=9 width=20)
   ->  Append  (cost=100.65..6405.82 rows=3 width=20)
         ->  Bitmap Heap Scan on pt_complex_1_prt_p1_2_prt_p11_3_prt_p11  (cost=100.65..1601.46 rows=1 width=20)
               Recheck Cond: (i = 1)
               Filter: (j = 1)
               ->  Bitmap Index Scan on pt_complex_1_prt_p1_2_prt_p11_3_prt_p11_i_idx  (cost=0.00..100.65 rows=22 width=0)
                     Index Cond: (i = 1)
         ->  Bitmap Heap Scan on pt_complex_1_prt_p1_2_prt_p11_3_prt_p12  (cost=100.65..1601.46 rows=1 width=20)
               Recheck Cond: (i = 1)
               Filter: (j = 1)
               ->  Bitmap Index Scan on pt_complex_1_prt_p1_2_prt_p11_3_prt_p12_i_idx  (cost=0.00..100.65 rows=22 width=0)
                     Index Cond: (i = 1)
         ->  Bitmap Heap Scan on pt_complex_1_prt_p2_2_prt_p11_3_prt_p11  (cost=100.65..1601.46 rows=1 width=20)
               Recheck Cond: (i = 1)
               Filter: (j = 1)
               ->  Bitmap Index Scan on pt_complex_1_prt_p2_2_prt_p11_3_prt_p11_i_idx  (cost=0.00..100.65 rows=22 width=0)
                     Index Cond: (i = 1)
         ->  Bitmap Heap Scan on pt_complex_1_prt_p2_2_prt_p11_3_prt_p12  (cost=100.65..1601.46 rows=1 width=20)
               Recheck Cond: (i = 1)
               Filter: (j = 1)
               ->  Bitmap Index Scan on pt_complex_1_prt_p2_2_prt_p11_3_prt_p12_i_idx  (cost=0.00..100.65 rows=22 width=0)
                     Index Cond: (i = 1)
 Optimizer: Postgres query optimizer
(23 rows)

--
-- See MPP-6861
--
CREATE TABLE ds_4
(
  month_id character varying(6),
  cust_group_acc numeric(10),
  mobile_no character varying(10),
  source character varying(12),
  vas_group numeric(10),
  vas_type numeric(10),
  count_vas integer,
  amt_vas numeric(10,2),
  network_type character varying(3),
  execution_id integer
)
WITH (
  OIDS=FALSE
)
DISTRIBUTED BY (cust_group_acc, mobile_no)
PARTITION BY LIST(month_id)
          (
          PARTITION p200800 VALUES('200800'),
          PARTITION p200801 VALUES('200801'),
          PARTITION p200802 VALUES('200802'),
          PARTITION p200803 VALUES('200803')
);
-- this is the case that worked before MPP-6861
-- start_ignore
-- Known_opt_diff: MPP-21316
-- end_ignore
explain select * from ds_4 where month_id = '200800';
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000280.29 rows=15 width=196)
   ->  Seq Scan on ds_4_1_prt_p200800  (cost=10000000000.00..10000000280.00 rows=5 width=196)
         Filter: ((month_id)::text = '200800'::text)
 Optimizer: Postgres query optimizer
(4 rows)

-- now we can evaluate this function at planning/prune time
-- start_ignore
-- Known_opt_diff: MPP-21316
-- end_ignore
explain select * from ds_4 where month_id::int = 200800;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..40000001409.44 rows=58 width=196)
   ->  Append  (cost=10000000000.00..40000001408.29 rows=20 width=196)
         ->  Seq Scan on ds_4_1_prt_p200800  (cost=10000000000.00..10000000352.00 rows=5 width=196)
               Filter: ((month_id)::integer = 200800)
         ->  Seq Scan on ds_4_1_prt_p200801  (cost=10000000000.00..10000000352.00 rows=5 width=196)
               Filter: ((month_id)::integer = 200800)
         ->  Seq Scan on ds_4_1_prt_p200802  (cost=10000000000.00..10000000352.00 rows=5 width=196)
               Filter: ((month_id)::integer = 200800)
         ->  Seq Scan on ds_4_1_prt_p200803  (cost=10000000000.00..10000000352.00 rows=5 width=196)
               Filter: ((month_id)::integer = 200800)
 Optimizer: Postgres query optimizer
(11 rows)

-- this will be satisfied by 200800
-- start_ignore
-- Known_opt_diff: MPP-21316
-- end_ignore
explain select * from ds_4 where month_id::int - 801 < 200000;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..40000002032.00 rows=19200 width=196)
   ->  Append  (cost=10000000000.00..40000001648.00 rows=6400 width=196)
         ->  Seq Scan on ds_4_1_prt_p200800  (cost=10000000000.00..10000000388.00 rows=1600 width=196)
               Filter: (((month_id)::integer - 801) < 200000)
         ->  Seq Scan on ds_4_1_prt_p200801  (cost=10000000000.00..10000000388.00 rows=1600 width=196)
               Filter: (((month_id)::integer - 801) < 200000)
         ->  Seq Scan on ds_4_1_prt_p200802  (cost=10000000000.00..10000000388.00 rows=1600 width=196)
               Filter: (((month_id)::integer - 801) < 200000)
         ->  Seq Scan on ds_4_1_prt_p200803  (cost=10000000000.00..10000000388.00 rows=1600 width=196)
               Filter: (((month_id)::integer - 801) < 200000)
 Optimizer: Postgres query optimizer
(11 rows)

-- test OR case -- should NOT get pruning
explain select * from ds_4 where month_id::int - 801 < 200000 OR count_vas > 10;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..40000001696.00 rows=32000 width=196)
   ->  Append  (cost=10000000000.00..40000001696.00 rows=10667 width=196)
         ->  Seq Scan on ds_4_1_prt_p200800  (cost=10000000000.00..10000000424.00 rows=2667 width=196)
               Filter: (month_id::integer - 801) < 200000 OR count_vas > 10
         ->  Seq Scan on ds_4_1_prt_p200801  (cost=10000000000.00..10000000424.00 rows=2667 width=196)
               Filter: (month_id::integer - 801) < 200000 OR count_vas > 10
         ->  Seq Scan on ds_4_1_prt_p200802  (cost=10000000000.00..10000000424.00 rows=2667 width=196)
               Filter: (month_id::integer - 801) < 200000 OR count_vas > 10
         ->  Seq Scan on ds_4_1_prt_p200803  (cost=10000000000.00..10000000424.00 rows=2667 width=196)
               Filter: (month_id::integer - 801) < 200000 OR count_vas > 10
 Optimizer: Postgres query optimizer
(11 rows)

-- test AND case -- should still get pruning
-- start_ignore
-- Known_opt_diff: MPP-21316
-- end_ignore
explain select * from ds_4 where month_id::int - 801 < 200000 AND count_vas > 10;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..40000001973.13 rows=11086 width=196)
   ->  Append  (cost=10000000000.00..40000001751.43 rows=3696 width=196)
         ->  Seq Scan on ds_4_1_prt_p200800  (cost=10000000000.00..10000000424.00 rows=924 width=196)
               Filter: ((count_vas > 10) AND (((month_id)::integer - 801) < 200000))
         ->  Seq Scan on ds_4_1_prt_p200801  (cost=10000000000.00..10000000424.00 rows=924 width=196)
               Filter: ((count_vas > 10) AND (((month_id)::integer - 801) < 200000))
         ->  Seq Scan on ds_4_1_prt_p200802  (cost=10000000000.00..10000000424.00 rows=924 width=196)
               Filter: ((count_vas > 10) AND (((month_id)::integer - 801) < 200000))
         ->  Seq Scan on ds_4_1_prt_p200803  (cost=10000000000.00..10000000424.00 rows=924 width=196)
               Filter: ((count_vas > 10) AND (((month_id)::integer - 801) < 200000))
 Optimizer: Postgres query optimizer
(11 rows)

-- test expression case : should get pruning
-- start_ignore
-- Known_opt_diff: MPP-21316
-- end_ignore
explain select * from ds_4 where case when month_id = '200800' then 100 else 2 end = 100;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..40000001265.44 rows=58 width=196)
   ->  Append  (cost=10000000000.00..40000001264.29 rows=20 width=196)
         ->  Seq Scan on ds_4_1_prt_p200800  (cost=10000000000.00..10000000316.00 rows=5 width=196)
               Filter: (CASE WHEN ((month_id)::text = '200800'::text) THEN 100 ELSE 2 END = 100)
         ->  Seq Scan on ds_4_1_prt_p200801  (cost=10000000000.00..10000000316.00 rows=5 width=196)
               Filter: (CASE WHEN ((month_id)::text = '200800'::text) THEN 100 ELSE 2 END = 100)
         ->  Seq Scan on ds_4_1_prt_p200802  (cost=10000000000.00..10000000316.00 rows=5 width=196)
               Filter: (CASE WHEN ((month_id)::text = '200800'::text) THEN 100 ELSE 2 END = 100)
         ->  Seq Scan on ds_4_1_prt_p200803  (cost=10000000000.00..10000000316.00 rows=5 width=196)
               Filter: (CASE WHEN ((month_id)::text = '200800'::text) THEN 100 ELSE 2 END = 100)
 Optimizer: Postgres query optimizer
(11 rows)

-- test expression case : should get pruning
-- start_ignore
-- Known_opt_diff: MPP-21316
-- end_ignore
explain select * from ds_4 where case when month_id = '200800' then NULL else 2 end IS NULL;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..40000001121.44 rows=58 width=196)
   ->  Append  (cost=10000000000.00..40000001120.29 rows=20 width=196)
         ->  Seq Scan on ds_4_1_prt_p200800  (cost=10000000000.00..10000000280.00 rows=5 width=196)
               Filter: (CASE WHEN ((month_id)::text = '200800'::text) THEN NULL::integer ELSE 2 END IS NULL)
         ->  Seq Scan on ds_4_1_prt_p200801  (cost=10000000000.00..10000000280.00 rows=5 width=196)
               Filter: (CASE WHEN ((month_id)::text = '200800'::text) THEN NULL::integer ELSE 2 END IS NULL)
         ->  Seq Scan on ds_4_1_prt_p200802  (cost=10000000000.00..10000000280.00 rows=5 width=196)
               Filter: (CASE WHEN ((month_id)::text = '200800'::text) THEN NULL::integer ELSE 2 END IS NULL)
         ->  Seq Scan on ds_4_1_prt_p200803  (cost=10000000000.00..10000000280.00 rows=5 width=196)
               Filter: (CASE WHEN ((month_id)::text = '200800'::text) THEN NULL::integer ELSE 2 END IS NULL)
 Optimizer: Postgres query optimizer
(11 rows)

-- should still get pruning here -- count_vas is only used in the path for month id = 200800
-- start_ignore
-- Known_opt_diff: MPP-21316
-- end_ignore
explain select * from ds_4 where case when month_id::int = 200800 then count_vas else 2 end IS NULL;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..40000001409.44 rows=58 width=196)
   ->  Append  (cost=10000000000.00..40000001408.29 rows=20 width=196)
         ->  Seq Scan on ds_4_1_prt_p200800  (cost=10000000000.00..10000000352.00 rows=5 width=196)
               Filter: (CASE WHEN ((month_id)::integer = 200800) THEN count_vas ELSE 2 END IS NULL)
         ->  Seq Scan on ds_4_1_prt_p200801  (cost=10000000000.00..10000000352.00 rows=5 width=196)
               Filter: (CASE WHEN ((month_id)::integer = 200800) THEN count_vas ELSE 2 END IS NULL)
         ->  Seq Scan on ds_4_1_prt_p200802  (cost=10000000000.00..10000000352.00 rows=5 width=196)
               Filter: (CASE WHEN ((month_id)::integer = 200800) THEN count_vas ELSE 2 END IS NULL)
         ->  Seq Scan on ds_4_1_prt_p200803  (cost=10000000000.00..10000000352.00 rows=5 width=196)
               Filter: (CASE WHEN ((month_id)::integer = 200800) THEN count_vas ELSE 2 END IS NULL)
 Optimizer: Postgres query optimizer
(11 rows)

-- do one that matches a couple partitions
-- start_ignore
-- Known_opt_diff: MPP-21316
-- end_ignore
explain select * from ds_4 where month_id::int in (200801, 1,55,6,6,6,6,66,565,65,65,200803);
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..40000002145.28 rows=692 width=196)
   ->  Append  (cost=10000000000.00..40000002131.46 rows=231 width=196)
         ->  Seq Scan on ds_4_1_prt_p200800  (cost=10000000000.00..10000000532.00 rows=58 width=196)
               Filter: ((month_id)::integer = ANY ('{200801,1,55,6,6,6,6,66,565,65,65,200803}'::integer[]))
         ->  Seq Scan on ds_4_1_prt_p200801  (cost=10000000000.00..10000000532.00 rows=58 width=196)
               Filter: ((month_id)::integer = ANY ('{200801,1,55,6,6,6,6,66,565,65,65,200803}'::integer[]))
         ->  Seq Scan on ds_4_1_prt_p200802  (cost=10000000000.00..10000000532.00 rows=58 width=196)
               Filter: ((month_id)::integer = ANY ('{200801,1,55,6,6,6,6,66,565,65,65,200803}'::integer[]))
         ->  Seq Scan on ds_4_1_prt_p200803  (cost=10000000000.00..10000000532.00 rows=58 width=196)
               Filter: ((month_id)::integer = ANY ('{200801,1,55,6,6,6,6,66,565,65,65,200803}'::integer[]))
 Optimizer: Postgres query optimizer
(11 rows)

-- cleanup
drop table ds_4;
--
-- See MPP-18979
--
CREATE TABLE ds_2
(
  month_id character varying(6),
  cust_group_acc numeric(10),
  mobile_no character varying(10),
  source character varying(12),
  vas_group numeric(10),
  vas_type numeric(10),
  count_vas integer,
  amt_vas numeric(10,2),
  network_type character varying(3),
  execution_id integer
)
WITH (
  OIDS=FALSE
)
DISTRIBUTED BY (cust_group_acc, mobile_no)
PARTITION BY LIST(month_id)
          (
          PARTITION p200800 VALUES('200800'),
          PARTITION p200801 VALUES('200801'),
          PARTITION p200802 VALUES('200802'),
          PARTITION p200803 VALUES('200803'),
          PARTITION p200804 VALUES('200804'),
          PARTITION p200805 VALUES('200805'),
          PARTITION p200806 VALUES('200806'),
          PARTITION p200807 VALUES('200807'),
          PARTITION p200808 VALUES('200808'),
          PARTITION p200809 VALUES('200809')
);
insert into ds_2(month_id) values('200800');
insert into ds_2(month_id) values('200801');
insert into ds_2(month_id) values('200802');
insert into ds_2(month_id) values('200803');
insert into ds_2(month_id) values('200804');
insert into ds_2(month_id) values('200805');
insert into ds_2(month_id) values('200806');
insert into ds_2(month_id) values('200807');
insert into ds_2(month_id) values('200808');
insert into ds_2(month_id) values('200809');
-- queries without bitmap scan
-- start_ignore
-- Known_opt_diff: MPP-21316
-- end_ignore
set optimizer_segments=2;
explain select * from ds_2 where month_id::int in (200808, 1315) order by month_id;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=100000003533.20..100000003539.68 rows=289 width=196)
   Merge Key: ds_2_1_prt_p200800.month_id
   ->  Sort  (cost=100000003533.20..100000003533.92 rows=97 width=196)
         Sort Key: ds_2_1_prt_p200800.month_id
         ->  Append  (cost=10000000000.00..100000003521.44 rows=97 width=196)
               ->  Seq Scan on ds_2_1_prt_p200800  (cost=10000000000.00..10000000352.00 rows=10 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,1315}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200801  (cost=10000000000.00..10000000352.00 rows=10 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,1315}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200802  (cost=10000000000.00..10000000352.00 rows=10 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,1315}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200803  (cost=10000000000.00..10000000352.00 rows=10 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,1315}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200804  (cost=10000000000.00..10000000352.00 rows=10 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,1315}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200805  (cost=10000000000.00..10000000352.00 rows=10 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,1315}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200806  (cost=10000000000.00..10000000352.00 rows=10 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,1315}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200807  (cost=10000000000.00..10000000352.00 rows=10 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,1315}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200808  (cost=10000000000.00..10000000352.00 rows=10 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,1315}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200809  (cost=10000000000.00..10000000352.00 rows=10 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,1315}'::integer[]))
 Optimizer: Postgres query optimizer
(26 rows)

-- start_ignore
-- Known_opt_diff: MPP-21316
-- end_ignore
explain  select * from ds_2 where month_id::int in (200808, 200801, 2008010) order by month_id;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=100000003721.07..100000003730.79 rows=432 width=196)
   Merge Key: ds_2_1_prt_p200800.month_id
   ->  Sort  (cost=100000003721.07..100000003722.15 rows=144 width=196)
         Sort Key: ds_2_1_prt_p200800.month_id
         ->  Append  (cost=10000000000.00..100000003702.16 rows=144 width=196)
               ->  Seq Scan on ds_2_1_prt_p200800  (cost=10000000000.00..10000000370.00 rows=15 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,200801,2008010}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200801  (cost=10000000000.00..10000000370.00 rows=15 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,200801,2008010}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200802  (cost=10000000000.00..10000000370.00 rows=15 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,200801,2008010}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200803  (cost=10000000000.00..10000000370.00 rows=15 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,200801,2008010}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200804  (cost=10000000000.00..10000000370.00 rows=15 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,200801,2008010}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200805  (cost=10000000000.00..10000000370.00 rows=15 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,200801,2008010}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200806  (cost=10000000000.00..10000000370.00 rows=15 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,200801,2008010}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200807  (cost=10000000000.00..10000000370.00 rows=15 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,200801,2008010}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200808  (cost=10000000000.00..10000000370.00 rows=15 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,200801,2008010}'::integer[]))
               ->  Seq Scan on ds_2_1_prt_p200809  (cost=10000000000.00..10000000370.00 rows=15 width=196)
                     Filter: ((month_id)::integer = ANY ('{200808,200801,2008010}'::integer[]))
 Optimizer: Postgres query optimizer
(26 rows)

reset optimizer_segments;
select * from ds_2 where month_id::int in (200907, 1315) order by month_id;
 month_id | cust_group_acc | mobile_no | source | vas_group | vas_type | count_vas | amt_vas | network_type | execution_id 
----------+----------------+-----------+--------+-----------+----------+-----------+---------+--------------+--------------
(0 rows)

select * from ds_2 where month_id::int in (200808, 1315) order by month_id;
 month_id | cust_group_acc | mobile_no | source | vas_group | vas_type | count_vas | amt_vas | network_type | execution_id 
----------+----------------+-----------+--------+-----------+----------+-----------+---------+--------------+--------------
 200808   |                |           |        |           |          |           |         |              |             
(1 row)

select * from ds_2 where month_id::int in (200808, 200801) order by month_id;
 month_id | cust_group_acc | mobile_no | source | vas_group | vas_type | count_vas | amt_vas | network_type | execution_id 
----------+----------------+-----------+--------+-----------+----------+-----------+---------+--------------+--------------
 200801   |                |           |        |           |          |           |         |              |             
 200808   |                |           |        |           |          |           |         |              |             
(2 rows)

select * from ds_2 where month_id::int in (200808, 200801, 2008010) order by month_id;
 month_id | cust_group_acc | mobile_no | source | vas_group | vas_type | count_vas | amt_vas | network_type | execution_id 
----------+----------------+-----------+--------+-----------+----------+-----------+---------+--------------+--------------
 200801   |                |           |        |           |          |           |         |              |             
 200808   |                |           |        |           |          |           |         |              |             
(2 rows)

-- cleanup
drop table ds_2;
drop table if exists dnsdata cascade;
NOTICE:  table "dnsdata" does not exist, skipping
CREATE TABLE dnsdata(dnsname text) DISTRIBUTED RANDOMLY;
CREATE INDEX dnsdata_d1_idx ON dnsdata USING bitmap (split_part(reverse(dnsname),'.'::text,1));
CREATE INDEX dnsdata_d2_idx ON dnsdata USING bitmap (split_part(reverse(dnsname),'.'::text,2));
insert into dnsdata values('www.google.com');
insert into dnsdata values('www.google1.com');
insert into dnsdata values('1.google.com');
insert into dnsdata values('2.google.com');
insert into dnsdata select 'www.b.com' from generate_series(1, 100000) as x(a);
analyze dnsdata;
-- queries with bitmap scan enabled
set enable_bitmapscan=on;
set enable_indexscan=on;
set enable_seqscan=off;
Select dnsname from dnsdata
where (split_part(reverse('cache.google.com'),'.',1))=(split_part(reverse(dnsname),'.',1))
and (split_part(reverse('cache.google.com'),'.',2))=(split_part(reverse(dnsname),'.',2)) 
order by dnsname;
    dnsname     
----------------
 1.google.com
 2.google.com
 www.google.com
(3 rows)

Select dnsname from dnsdata
where (split_part(reverse('cache.google.com'),'.',1))=(split_part(reverse(dnsname),'.',1))
and (split_part(reverse('cache.google.com'),'.',2))=(split_part(reverse(dnsname),'.',2))
and dnsname = 'cache.google.com'
order by dnsname;
 dnsname 
---------
(0 rows)

-- cleanup
drop table dnsdata cascade;
Create or replace function ZeroFunc(int) Returns int as $BODY$
BEGIN
  RETURN 0;
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;
drop table if exists mytable cascade;
NOTICE:  table "mytable" does not exist, skipping
create table mytable(i int, j int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into mytable select x, x+1 from generate_series(1, 100000) as x;
analyze mytable;
CREATE INDEX mytable_idx1 ON mytable USING bitmap(ZeroFunc(i));
select * from mytable where ZeroFunc(i)=0 and i=100 order by i;
  i  |  j  
-----+-----
 100 | 101
(1 row)

select * from mytable where ZeroFunc(i)=0 and i=-1 order by i;
 i | j 
---+---
(0 rows)

-- cleanup
drop function ZeroFunc(int) cascade;
NOTICE:  drop cascades to index mytable_idx1
drop table mytable cascade;
drop table if exists partprune_foo;
NOTICE:  table "partprune_foo" does not exist, skipping
create table partprune_foo(a int, b int, c int) partition by range (b) (start (1) end (101) every (10));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into partprune_foo select g % 5 + 1, g + 1, g % 10 + 1 from generate_series(0, 99) g;
analyze partprune_foo;
explain select * from partprune_foo;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..100000000011.83 rows=100 width=12)
   ->  Append  (cost=10000000000.00..100000000010.50 rows=33 width=12)
         ->  Seq Scan on partprune_foo_1_prt_1  (cost=10000000000.00..10000000001.03 rows=3 width=12)
         ->  Seq Scan on partprune_foo_1_prt_2  (cost=10000000000.00..10000000001.03 rows=3 width=12)
         ->  Seq Scan on partprune_foo_1_prt_3  (cost=10000000000.00..10000000001.03 rows=3 width=12)
         ->  Seq Scan on partprune_foo_1_prt_4  (cost=10000000000.00..10000000001.03 rows=3 width=12)
         ->  Seq Scan on partprune_foo_1_prt_5  (cost=10000000000.00..10000000001.03 rows=3 width=12)
         ->  Seq Scan on partprune_foo_1_prt_6  (cost=10000000000.00..10000000001.03 rows=3 width=12)
         ->  Seq Scan on partprune_foo_1_prt_7  (cost=10000000000.00..10000000001.03 rows=3 width=12)
         ->  Seq Scan on partprune_foo_1_prt_8  (cost=10000000000.00..10000000001.03 rows=3 width=12)
         ->  Seq Scan on partprune_foo_1_prt_9  (cost=10000000000.00..10000000001.03 rows=3 width=12)
         ->  Seq Scan on partprune_foo_1_prt_10  (cost=10000000000.00..10000000001.03 rows=3 width=12)
 Optimizer: Postgres query optimizer
(13 rows)

select * from partprune_foo;
 a |  b  | c  
---+-----+----
 1 |   1 |  1
 3 |   3 |  3
 5 |   5 |  5
 1 |   6 |  6
 3 |   8 |  8
 5 |  10 | 10
 1 |  11 |  1
 3 |  13 |  3
 5 |  15 |  5
 1 |  16 |  6
 3 |  18 |  8
 5 |  20 | 10
 1 |  21 |  1
 3 |  23 |  3
 5 |  25 |  5
 1 |  26 |  6
 3 |  28 |  8
 5 |  30 | 10
 1 |  31 |  1
 3 |  33 |  3
 5 |  35 |  5
 1 |  36 |  6
 3 |  38 |  8
 5 |  40 | 10
 1 |  41 |  1
 3 |  43 |  3
 5 |  45 |  5
 1 |  46 |  6
 3 |  48 |  8
 5 |  50 | 10
 1 |  51 |  1
 3 |  53 |  3
 5 |  55 |  5
 1 |  56 |  6
 3 |  58 |  8
 5 |  60 | 10
 1 |  61 |  1
 3 |  63 |  3
 5 |  65 |  5
 1 |  66 |  6
 3 |  68 |  8
 5 |  70 | 10
 1 |  71 |  1
 3 |  73 |  3
 5 |  75 |  5
 1 |  76 |  6
 3 |  78 |  8
 5 |  80 | 10
 1 |  81 |  1
 3 |  83 |  3
 5 |  85 |  5
 1 |  86 |  6
 3 |  88 |  8
 5 |  90 | 10
 1 |  91 |  1
 3 |  93 |  3
 5 |  95 |  5
 1 |  96 |  6
 3 |  98 |  8
 5 | 100 | 10
 2 |   2 |  2
 4 |   4 |  4
 2 |   7 |  7
 4 |   9 |  9
 2 |  12 |  2
 4 |  14 |  4
 2 |  17 |  7
 4 |  19 |  9
 2 |  22 |  2
 4 |  24 |  4
 2 |  27 |  7
 4 |  29 |  9
 2 |  32 |  2
 4 |  34 |  4
 2 |  37 |  7
 4 |  39 |  9
 2 |  42 |  2
 4 |  44 |  4
 2 |  47 |  7
 4 |  49 |  9
 2 |  52 |  2
 4 |  54 |  4
 2 |  57 |  7
 4 |  59 |  9
 2 |  62 |  2
 4 |  64 |  4
 2 |  67 |  7
 4 |  69 |  9
 2 |  72 |  2
 4 |  74 |  4
 2 |  77 |  7
 4 |  79 |  9
 2 |  82 |  2
 4 |  84 |  4
 2 |  87 |  7
 4 |  89 |  9
 2 |  92 |  2
 4 |  94 |  4
 2 |  97 |  7
 4 |  99 |  9
(100 rows)

explain select * from partprune_foo where b = 35;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000001.06 rows=1 width=12)
   ->  Seq Scan on partprune_foo_1_prt_4  (cost=10000000000.00..10000000001.04 rows=1 width=12)
         Filter: (b = 35)
 Optimizer: Postgres query optimizer
(4 rows)

select * from partprune_foo where b = 35;
 a | b  | c 
---+----+---
 5 | 35 | 5
(1 row)

explain select * from partprune_foo where b < 35;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..40000000004.67 rows=33 width=12)
   ->  Append  (cost=10000000000.00..40000000004.22 rows=11 width=12)
         ->  Seq Scan on partprune_foo_1_prt_1  (cost=10000000000.00..10000000001.04 rows=3 width=12)
               Filter: (b < 35)
         ->  Seq Scan on partprune_foo_1_prt_2  (cost=10000000000.00..10000000001.04 rows=3 width=12)
               Filter: (b < 35)
         ->  Seq Scan on partprune_foo_1_prt_3  (cost=10000000000.00..10000000001.04 rows=3 width=12)
               Filter: (b < 35)
         ->  Seq Scan on partprune_foo_1_prt_4  (cost=10000000000.00..10000000001.04 rows=1 width=12)
               Filter: (b < 35)
 Optimizer: Postgres query optimizer
(11 rows)

select * from partprune_foo where b < 35;
 a | b  | c  
---+----+----
 2 |  2 |  2
 4 |  4 |  4
 2 |  7 |  7
 4 |  9 |  9
 2 | 12 |  2
 4 | 14 |  4
 2 | 17 |  7
 4 | 19 |  9
 2 | 22 |  2
 4 | 24 |  4
 2 | 27 |  7
 4 | 29 |  9
 2 | 32 |  2
 4 | 34 |  4
 1 |  1 |  1
 3 |  3 |  3
 5 |  5 |  5
 1 |  6 |  6
 3 |  8 |  8
 5 | 10 | 10
 1 | 11 |  1
 3 | 13 |  3
 5 | 15 |  5
 1 | 16 |  6
 3 | 18 |  8
 5 | 20 | 10
 1 | 21 |  1
 3 | 23 |  3
 5 | 25 |  5
 1 | 26 |  6
 3 | 28 |  8
 5 | 30 | 10
 1 | 31 |  1
 3 | 33 |  3
(34 rows)

explain select * from partprune_foo where b in (5, 6, 14, 23);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000000003.33 rows=12 width=12)
   ->  Append  (cost=10000000000.00..30000000003.17 rows=4 width=12)
         ->  Seq Scan on partprune_foo_1_prt_1  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = ANY ('{5,6,14,23}'::integer[]))
         ->  Seq Scan on partprune_foo_1_prt_2  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = ANY ('{5,6,14,23}'::integer[]))
         ->  Seq Scan on partprune_foo_1_prt_3  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = ANY ('{5,6,14,23}'::integer[]))
 Optimizer: Postgres query optimizer
(9 rows)

select * from partprune_foo where b in (5, 6, 14, 23);
 a | b  | c 
---+----+---
 4 | 14 | 4
 5 |  5 | 5
 1 |  6 | 6
 3 | 23 | 3
(4 rows)

explain select * from partprune_foo where b < 15 or b > 60;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..70000000008.20 rows=56 width=12)
   ->  Append  (cost=10000000000.00..70000000007.44 rows=19 width=12)
         ->  Seq Scan on partprune_foo_1_prt_1  (cost=10000000000.00..10000000001.05 rows=3 width=12)
               Filter: ((b < 15) OR (b > 60))
         ->  Seq Scan on partprune_foo_1_prt_2  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: ((b < 15) OR (b > 60))
         ->  Seq Scan on partprune_foo_1_prt_6  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: ((b < 15) OR (b > 60))
         ->  Seq Scan on partprune_foo_1_prt_7  (cost=10000000000.00..10000000001.05 rows=3 width=12)
               Filter: ((b < 15) OR (b > 60))
         ->  Seq Scan on partprune_foo_1_prt_8  (cost=10000000000.00..10000000001.05 rows=3 width=12)
               Filter: ((b < 15) OR (b > 60))
         ->  Seq Scan on partprune_foo_1_prt_9  (cost=10000000000.00..10000000001.05 rows=3 width=12)
               Filter: ((b < 15) OR (b > 60))
         ->  Seq Scan on partprune_foo_1_prt_10  (cost=10000000000.00..10000000001.05 rows=3 width=12)
               Filter: ((b < 15) OR (b > 60))
 Optimizer: Postgres query optimizer
(17 rows)

select * from partprune_foo where b < 15 or b > 60;
 a |  b  | c  
---+-----+----
 1 |   1 |  1
 3 |   3 |  3
 5 |   5 |  5
 1 |   6 |  6
 3 |   8 |  8
 5 |  10 | 10
 1 |  11 |  1
 3 |  13 |  3
 1 |  61 |  1
 3 |  63 |  3
 5 |  65 |  5
 1 |  66 |  6
 3 |  68 |  8
 5 |  70 | 10
 1 |  71 |  1
 3 |  73 |  3
 5 |  75 |  5
 1 |  76 |  6
 3 |  78 |  8
 5 |  80 | 10
 1 |  81 |  1
 3 |  83 |  3
 5 |  85 |  5
 1 |  86 |  6
 3 |  88 |  8
 5 |  90 | 10
 1 |  91 |  1
 3 |  93 |  3
 5 |  95 |  5
 1 |  96 |  6
 3 |  98 |  8
 5 | 100 | 10
 2 |   2 |  2
 4 |   4 |  4
 2 |   7 |  7
 4 |   9 |  9
 2 |  12 |  2
 4 |  14 |  4
 2 |  62 |  2
 4 |  64 |  4
 2 |  67 |  7
 4 |  69 |  9
 2 |  72 |  2
 4 |  74 |  4
 2 |  77 |  7
 4 |  79 |  9
 2 |  82 |  2
 4 |  84 |  4
 2 |  87 |  7
 4 |  89 |  9
 2 |  92 |  2
 4 |  94 |  4
 2 |  97 |  7
 4 |  99 |  9
(54 rows)

explain select * from partprune_foo where b = 150;
                QUERY PLAN                
------------------------------------------
 Result  (cost=0.00..0.00 rows=0 width=0)
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

select * from partprune_foo where b = 150;
 a | b | c 
---+---+---
(0 rows)

explain select * from partprune_foo where b = a*5;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..100000000010.95 rows=30 width=12)
   ->  Append  (cost=10000000000.00..100000000010.55 rows=10 width=12)
         ->  Seq Scan on partprune_foo_1_prt_1  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = (a * 5))
         ->  Seq Scan on partprune_foo_1_prt_2  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = (a * 5))
         ->  Seq Scan on partprune_foo_1_prt_3  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = (a * 5))
         ->  Seq Scan on partprune_foo_1_prt_4  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = (a * 5))
         ->  Seq Scan on partprune_foo_1_prt_5  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = (a * 5))
         ->  Seq Scan on partprune_foo_1_prt_6  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = (a * 5))
         ->  Seq Scan on partprune_foo_1_prt_7  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = (a * 5))
         ->  Seq Scan on partprune_foo_1_prt_8  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = (a * 5))
         ->  Seq Scan on partprune_foo_1_prt_9  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = (a * 5))
         ->  Seq Scan on partprune_foo_1_prt_10  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = (a * 5))
 Optimizer: Postgres query optimizer
(23 rows)

select * from partprune_foo where b = a*5;
 a | b  | c 
---+----+---
 5 | 25 | 5
(1 row)

-- Test with IN() lists
-- Number of elements > threshold, partition elimination is not performed
set optimizer_array_expansion_threshold = 3;
explain select * from partprune_foo where b in (5, 6, 14, 23);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000000003.33 rows=12 width=12)
   ->  Append  (cost=10000000000.00..30000000003.17 rows=4 width=12)
         ->  Seq Scan on partprune_foo_1_prt_1  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = ANY ('{5,6,14,23}'::integer[]))
         ->  Seq Scan on partprune_foo_1_prt_2  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = ANY ('{5,6,14,23}'::integer[]))
         ->  Seq Scan on partprune_foo_1_prt_3  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = ANY ('{5,6,14,23}'::integer[]))
 Optimizer: Postgres query optimizer
(9 rows)

select * from partprune_foo where b in (5, 6, 14, 23);
 a | b  | c 
---+----+---
 1 |  6 | 6
 5 |  5 | 5
 4 | 14 | 4
 3 | 23 | 3
(4 rows)

reset optimizer_array_expansion_threshold;
-- Test "ANY (<array>)" syntax.
explain select * from partprune_foo where b = ANY ('{5, 6, 14}');
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000000002.18 rows=6 width=12)
   ->  Append  (cost=10000000000.00..20000000002.10 rows=2 width=12)
         ->  Seq Scan on partprune_foo_1_prt_1  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = ANY ('{5,6,14}'::integer[]))
         ->  Seq Scan on partprune_foo_1_prt_2  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b = ANY ('{5,6,14}'::integer[]))
 Optimizer: Postgres query optimizer
(7 rows)

select * from partprune_foo where b = ANY ('{5, 6, 14}');
 a | b  | c 
---+----+---
 1 |  6 | 6
 5 |  5 | 5
 4 | 14 | 4
(3 rows)

explain select * from partprune_foo where b < ANY ('{12, 14, 11}');
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000000002.29 rows=13 width=12)
   ->  Append  (cost=10000000000.00..20000000002.11 rows=4 width=12)
         ->  Seq Scan on partprune_foo_1_prt_1  (cost=10000000000.00..10000000001.05 rows=3 width=12)
               Filter: (b < ANY ('{12,14,11}'::integer[]))
         ->  Seq Scan on partprune_foo_1_prt_2  (cost=10000000000.00..10000000001.05 rows=1 width=12)
               Filter: (b < ANY ('{12,14,11}'::integer[]))
 Optimizer: Postgres query optimizer
(7 rows)

select * from partprune_foo where b < ANY ('{12, 14, 11}');
 a | b  | c  
---+----+----
 1 |  1 |  1
 2 |  2 |  2
 1 |  6 |  6
 2 |  7 |  7
 1 | 11 |  1
 2 | 12 |  2
 3 |  3 |  3
 4 |  4 |  4
 5 |  5 |  5
 3 |  8 |  8
 4 |  9 |  9
 5 | 10 | 10
 3 | 13 |  3
(13 rows)

-- Check for all the different number of partition selections
DROP TABLE IF EXISTS DATE_PARTS;
NOTICE:  table "date_parts" does not exist, skipping
CREATE TABLE DATE_PARTS (id int, year int, month int, day int, region text)
DISTRIBUTED BY (id)
PARTITION BY RANGE (year)
    SUBPARTITION BY LIST (month)
       SUBPARTITION TEMPLATE (
        SUBPARTITION Q1 VALUES (1, 2, 3), 
        SUBPARTITION Q2 VALUES (4 ,5 ,6),
        SUBPARTITION Q3 VALUES (7, 8, 9),
        SUBPARTITION Q4 VALUES (10, 11, 12),
        DEFAULT SUBPARTITION other_months )
        	SUBPARTITION BY RANGE(day)
        		SUBPARTITION TEMPLATE (
        		START (1) END (31) EVERY (10), 
		        DEFAULT SUBPARTITION other_days)
( START (2002) END (2012) EVERY (4), 
  DEFAULT PARTITION outlying_years );
insert into DATE_PARTS select i, extract(year from dt), extract(month from dt), extract(day from dt), NULL from (select i, '2002-01-01'::date + i * interval '1 day' day as dt from generate_series(1, 3650) as i) as t;
-- Expected total parts => 4 * 1 * 4 => 16: 
-- TODO #141973839: we selected extra parts because of disjunction: 32 parts: 4 * 2 * 4
explain analyze select * from DATE_PARTS where month between 1 and 3;
                                                                                         QUERY PLAN                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..320000007993.12 rows=13408 width=48) (actual time=9.267..14.353 rows=901 loops=1)
   ->  Append  (cost=10000000000.00..320000007814.35 rows=4469 width=48) (actual time=0.036..5.616 rows=314 loops=1)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.031..0.283 rows=44 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.300 rows=46 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.272 rows=45 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.048 rows=4 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.036 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.315 rows=53 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.292 rows=44 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.017..0.241 rows=39 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.053 rows=5 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.041 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.035 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.181 rows=22 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.167 rows=26 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.017..0.185 rows=25 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.047 rows=3 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.035 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.043 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.109 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.035 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_mo_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.029 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 3))
 Optimizer: Postgres query optimizer
 Planning Time: 22.983 ms
   (slice0)    Executor memory: 231K bytes.
   (slice1)    Executor memory: 274K bytes avg x 3 workers, 274K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 20.655 ms
(72 rows)

-- Expected total parts => 4 * 2 * 4 => 32: 
-- TODO #141973839: we selected extra parts because of disjunction: 48 parts: 4 * 3 * 4
explain analyze select * from DATE_PARTS where month between 1 and 4;
                                                                                         QUERY PLAN                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..480000011989.68 rows=20112 width=48) (actual time=8.526..15.152 rows=1201 loops=1)
   ->  Append  (cost=10000000000.00..480000011721.52 rows=6704 width=48) (actual time=0.036..7.859 rows=420 loops=1)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.030..0.346 rows=44 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.024..0.295 rows=46 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.019..0.282 rows=45 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.048 rows=4 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.017..0.129 rows=17 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
               Rows Removed by Filter: 34
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.017..0.131 rows=18 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
               Rows Removed by Filter: 26
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.017..0.115 rows=15 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
               Rows Removed by Filter: 30
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.040 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.023 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.325 rows=53 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.017..0.326 rows=44 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.246 rows=39 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.054 rows=5 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q2_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.019..0.125 rows=16 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
               Rows Removed by Filter: 34
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q2_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.120 rows=16 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
               Rows Removed by Filter: 22
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q2_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.017..0.127 rows=17 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
               Rows Removed by Filter: 18
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.027 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.028 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.032 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.015..0.149 rows=22 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.170 rows=26 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.192 rows=25 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.043 rows=3 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q2_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.090 rows=11 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
               Rows Removed by Filter: 11
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q2_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.074 rows=8 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
               Rows Removed by Filter: 12
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q2_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.016..0.080 rows=9 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
               Rows Removed by Filter: 21
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.033 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.029 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_mo_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=140 width=48) (actual time=0.000..0.028 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4))
 Optimizer: Postgres query optimizer
 Planning Time: 19.654 ms
   (slice0)    Executor memory: 358K bytes.
   (slice1)    Executor memory: 410K bytes avg x 3 workers, 410K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 23.471 ms
(113 rows)

-- Expected total parts => 1 * 2 * 4 => 8: 
-- TODO #141973839: we selected extra parts because of disjunction: 24 parts: 2 * 3 * 4
explain analyze select * from DATE_PARTS where year = 2003 and month between 1 and 4;
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..120000003341.75 rows=50 width=48) (actual time=1.907..2.558 rows=120 loops=1)
   ->  Append  (cost=10000000000.00..120000003341.08 rows=17 width=48) (actual time=0.037..1.019 rows=47 loops=1)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000278.42 rows=1 width=48) (actual time=0.027..0.130 rows=16 loops=1)
               Filter: ((month >= 1) AND (month <= 4) AND (year = 2003))
               Rows Removed by Filter: 25
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000278.42 rows=1 width=48) (actual time=0.021..0.103 rows=12 loops=1)
               Filter: ((month >= 1) AND (month <= 4) AND (year = 2003))
               Rows Removed by Filter: 34
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000278.42 rows=1 width=48) (actual time=0.018..0.089 rows=10 loops=1)
               Filter: ((month >= 1) AND (month <= 4) AND (year = 2003))
               Rows Removed by Filter: 27
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000278.42 rows=1 width=48) (actual time=0.015..0.037 rows=2 loops=1)
               Filter: ((month >= 1) AND (month <= 4) AND (year = 2003))
               Rows Removed by Filter: 1
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_2  (cost=10000000000.00..10000000278.42 rows=1 width=48) (actual time=0.018..0.068 rows=6 loops=1)
               Filter: ((month >= 1) AND (month <= 4) AND (year = 2003))
               Rows Removed by Filter: 45
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_3  (cost=10000000000.00..10000000278.42 rows=1 width=48) (actual time=0.018..0.060 rows=5 loops=1)
               Filter: ((month >= 1) AND (month <= 4) AND (year = 2003))
               Rows Removed by Filter: 30
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_4  (cost=10000000000.00..10000000278.42 rows=1 width=48) (actual time=0.019..0.056 rows=4 loops=1)
               Filter: ((month >= 1) AND (month <= 4) AND (year = 2003))
               Rows Removed by Filter: 41
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000278.42 rows=1 width=48) (actual time=0.000..0.027 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4) AND (year = 2003))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000278.42 rows=1 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4) AND (year = 2003))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000278.42 rows=1 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4) AND (year = 2003))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000278.42 rows=1 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4) AND (year = 2003))
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000278.42 rows=1 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((month >= 1) AND (month <= 4) AND (year = 2003))
 Optimizer: Postgres query optimizer
 Planning Time: 3.569 ms
   (slice0)    Executor memory: 104K bytes.
   (slice1)    Executor memory: 108K bytes avg x 3 workers, 108K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 4.119 ms
(39 rows)

-- 1 :: 5 :: 4 => 20 // Only default for year
explain analyze select * from DATE_PARTS where year = 1999;
                                                                                        QUERY PLAN                                                                                         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..200000004184.24 rows=838 width=48) (actual time=2.325..2.335 rows=0 loops=1)
   ->  Append  (cost=10000000000.00..200000004173.06 rows=279 width=48) (actual time=0.000..0.381 rows=0 loops=1)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.033 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.033 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q3_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q3_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q3_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.023 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q3_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q4_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q4_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q4_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q4_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.032 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (year = 1999)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_mo_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (year = 1999)
 Optimizer: Postgres query optimizer
 Planning Time: 8.897 ms
   (slice0)    Executor memory: 135K bytes.
   (slice1)    Executor memory: 171K bytes avg x 3 workers, 171K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 4.325 ms
(48 rows)

-- 4 :: 1 :: 4 => 16 // Only default for month
explain analyze select * from DATE_PARTS where month = 13;
                                                                                        QUERY PLAN                                                                                         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..160000003347.39 rows=670 width=48) (actual time=1.283..1.293 rows=0 loops=1)
   ->  Append  (cost=10000000000.00..160000003338.45 rows=223 width=48) (actual time=0.000..0.320 rows=0 loops=1)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.036 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.036 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.023 rows=0 loops=1)
               Filter: (month = 13)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_mo_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.032 rows=0 loops=1)
               Filter: (month = 13)
 Optimizer: Postgres query optimizer
 Planning Time: 5.906 ms
   (slice0)    Executor memory: 114K bytes.
   (slice1)    Executor memory: 135K bytes avg x 3 workers, 135K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 3.238 ms
(40 rows)

-- 1 :: 1 :: 4 => 4 // Default for both year and month
explain analyze select * from DATE_PARTS where year = 1999 and month = 13;
                                                                                        QUERY PLAN                                                                                        
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..40000000974.18 rows=12 width=48) (actual time=0.817..0.827 rows=0 loops=1)
   ->  Append  (cost=10000000000.00..40000000974.02 rows=4 width=48) (actual time=0.000..0.115 rows=0 loops=1)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000243.50 rows=1 width=48) (actual time=0.000..0.032 rows=0 loops=1)
               Filter: ((year = 1999) AND (month = 13))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000243.50 rows=1 width=48) (actual time=0.000..0.024 rows=0 loops=1)
               Filter: ((year = 1999) AND (month = 13))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000243.50 rows=1 width=48) (actual time=0.000..0.025 rows=0 loops=1)
               Filter: ((year = 1999) AND (month = 13))
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_mo_3_prt_other_days  (cost=10000000000.00..10000000243.50 rows=1 width=48) (actual time=0.000..0.023 rows=0 loops=1)
               Filter: ((year = 1999) AND (month = 13))
 Optimizer: Postgres query optimizer
 Planning Time: 2.009 ms
   (slice0)    Executor memory: 49K bytes.
   (slice1)    Executor memory: 49K bytes avg x 3 workers, 49K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 2.021 ms
(16 rows)

-- 4 :: 5 :: 1 => 20 // Only default part for day
explain analyze select * from DATE_PARTS where day = 40;
                                                                                        QUERY PLAN                                                                                         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..200000004184.24 rows=838 width=48) (actual time=1.396..1.426 rows=0 loops=1)
   ->  Append  (cost=10000000000.00..200000004173.06 rows=279 width=48) (actual time=0.000..0.429 rows=0 loops=1)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.040 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.026 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q3_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.027 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q4_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.026 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.025 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.025 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q3_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.026 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q4_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.025 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.026 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.025 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q3_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.026 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q4_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.025 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.034 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q3_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q4_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (day = 40)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_mo_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (day = 40)
 Optimizer: Postgres query optimizer
 Planning Time: 15.269 ms
   (slice0)    Executor memory: 137K bytes.
   (slice1)    Executor memory: 172K bytes avg x 3 workers, 172K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 3.536 ms
(48 rows)

-- General predicate
-- TODO #141973839. We expected 112 parts: (month = 1) =>   4 * 1 * 4 => 16, month > 3 => 4 * 4 * 4 => 64, month in (0, 1, 2) => 4 * 1 * 4 => 16, month is NULL => 4 * 1 * 4 => 16.
-- However, we selected 128 parts: (month = 1) =>   4 * 1 * 4 => 16, month > 3 => 4 * 4 * 4 => 64, month in (0, 1, 2) => 4 * 2 * 4 => 32, month is NULL => 4 * 1 * 4 => 16.
explain analyze select * from DATE_PARTS where month = 1 union all select * from DATE_PARTS where month > 3 union all select * from DATE_PARTS where month in (0,1,2) union all select * from DATE_PARTS where month is null;
                                                                                                                           QUERY PLAN                                                                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..1280000044683.26 rows=899230 width=48) (actual time=11.783..57.666 rows=3649 loops=1)
   ->  Append  (cost=10000000000.00..1280000032693.53 rows=299743 width=48) (actual time=0.054..58.962 rows=1227 loops=1)
         ->  Append  (cost=10000000000.00..160000003338.45 rows=223 width=48) (actual time=0.043..2.059 rows=110 loops=1)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.026..0.156 rows=20 loops=1)
                     Filter: (month = 1)
                     Rows Removed by Filter: 21
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.018..0.110 rows=14 loops=1)
                     Filter: (month = 1)
                     Rows Removed by Filter: 22
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.019..0.121 rows=16 loops=1)
                     Filter: (month = 1)
                     Rows Removed by Filter: 29
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.015..0.043 rows=3 loops=1)
                     Filter: (month = 1)
                     Rows Removed by Filter: 1
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.016..0.119 rows=16 loops=1)
                     Filter: (month = 1)
                     Rows Removed by Filter: 37
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.015..0.113 rows=15 loops=1)
                     Filter: (month = 1)
                     Rows Removed by Filter: 27
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.016..0.113 rows=15 loops=1)
                     Filter: (month = 1)
                     Rows Removed by Filter: 24
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.023..0.046 rows=2 loops=1)
                     Filter: (month = 1)
                     Rows Removed by Filter: 3
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.015..0.067 rows=7 loops=1)
                     Filter: (month = 1)
                     Rows Removed by Filter: 15
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.015..0.071 rows=8 loops=1)
                     Filter: (month = 1)
                     Rows Removed by Filter: 11
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.016..0.079 rows=9 loops=1)
                     Filter: (month = 1)
                     Rows Removed by Filter: 16
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.015..0.037 rows=2 loops=1)
                     Filter: (month = 1)
                     Rows Removed by Filter: 1
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.023 rows=0 loops=1)
                     Filter: (month = 1)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.023 rows=0 loops=1)
                     Filter: (month = 1)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.023 rows=0 loops=1)
                     Filter: (month = 1)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.023 rows=0 loops=1)
                     Filter: (month = 1)
         ->  Append  (cost=10000000000.00..640000014839.11 rows=297956 width=48) (actual time=0.025..39.350 rows=924 loops=1)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.015..0.318 rows=51 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.277 rows=44 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.275 rows=45 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.015..0.037 rows=2 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q3_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.017..0.293 rows=45 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q3_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.025..0.280 rows=44 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q3_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.021..0.393 rows=49 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q3_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.019..0.052 rows=4 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q4_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.272 rows=42 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q4_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.282 rows=46 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q4_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.263 rows=42 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q4_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.043 rows=3 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.024 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.023 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.023 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.030 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q2_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.303 rows=50 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q2_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.024..0.307 rows=42 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q2_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.020..0.275 rows=45 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.037 rows=2 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q3_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.267 rows=44 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q3_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.017..0.267 rows=44 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q3_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.286 rows=47 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q3_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.049 rows=4 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q4_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.296 rows=41 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q4_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.017..0.286 rows=48 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q4_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.258 rows=41 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q4_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.020..0.047 rows=3 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.024 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.023 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.023 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.030 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q2_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.152 rows=23 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q2_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.016..0.135 rows=20 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q2_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=22.869..23.094 rows=30 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.026..0.044 rows=1 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q3_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.022..0.196 rows=23 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q3_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.021..0.203 rows=24 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q3_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.021..0.198 rows=23 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q3_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.035..0.058 rows=2 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q4_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.019..0.252 rows=24 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q4_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.020..0.170 rows=22 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q4_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.025..0.193 rows=25 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q4_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.018..0.042 rows=2 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.026 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.028 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.026 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.084 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q2_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q3_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q3_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q3_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q3_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.026 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q4_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q4_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.024 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q4_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q4_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.093 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_2  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_3  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_4  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_mo_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=4656 width=48) (actual time=0.000..0.025 rows=0 loops=1)
                     Filter: (month > 3)
         ->  Append  (cost=10000000000.00..320000007240.04 rows=1341 width=48) (actual time=0.026..4.359 rows=205 loops=1)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_2 date_parts_1_prt_2_2_prt_q1_3_prt_2_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.014..0.218 rows=30 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
                     Rows Removed by Filter: 14
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_3 date_parts_1_prt_2_2_prt_q1_3_prt_3_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.013..0.230 rows=32 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
                     Rows Removed by Filter: 14
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_4 date_parts_1_prt_2_2_prt_q1_3_prt_4_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.013..0.228 rows=31 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
                     Rows Removed by Filter: 14
               ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_other_days date_parts_1_prt_2_2_prt_q1_3_prt_other_days_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.012..0.041 rows=3 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
                     Rows Removed by Filter: 1
               ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_2 date_parts_1_prt_2_2_prt_other_months_3_prt_2_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.019 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_3 date_parts_1_prt_2_2_prt_other_months_3_prt_3_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.019 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_4 date_parts_1_prt_2_2_prt_other_months_3_prt_4_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.019 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_other_days date_parts_1_prt_2_2_prt_other_months_3_prt_other_days_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.019 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_2 date_parts_1_prt_3_2_prt_q1_3_prt_2_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.013..0.261 rows=35 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
                     Rows Removed by Filter: 18
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_3 date_parts_1_prt_3_2_prt_q1_3_prt_3_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.014..0.225 rows=31 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
                     Rows Removed by Filter: 13
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_4 date_parts_1_prt_3_2_prt_q1_3_prt_4_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.012..0.208 rows=28 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
                     Rows Removed by Filter: 11
               ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_other_days date_parts_1_prt_3_2_prt_q1_3_prt_other_days_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.012..0.036 rows=2 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
                     Rows Removed by Filter: 3
               ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_2 date_parts_1_prt_3_2_prt_other_months_3_prt_2_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.019 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_3 date_parts_1_prt_3_2_prt_other_months_3_prt_3_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.019 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_4 date_parts_1_prt_3_2_prt_other_months_3_prt_4_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.019 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_other_days date_parts_1_prt_3_2_prt_other_months_3_prt_other_days_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.019 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_2 date_parts_1_prt_4_2_prt_q1_3_prt_2_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.012..0.126 rows=16 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
                     Rows Removed by Filter: 6
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_3 date_parts_1_prt_4_2_prt_q1_3_prt_3_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.012..0.159 rows=19 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
                     Rows Removed by Filter: 7
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_4 date_parts_1_prt_4_2_prt_q1_3_prt_4_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.012..0.131 rows=17 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
                     Rows Removed by Filter: 8
               ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_other_days date_parts_1_prt_4_2_prt_q1_3_prt_other_days_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.011..0.035 rows=2 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
                     Rows Removed by Filter: 1
               ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_2 date_parts_1_prt_4_2_prt_other_months_3_prt_2_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.019 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_3 date_parts_1_prt_4_2_prt_other_months_3_prt_3_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.041 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_4 date_parts_1_prt_4_2_prt_other_months_3_prt_4_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_other_days date_parts_1_prt_4_2_prt_other_months_3_prt_other_days_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_2 date_parts_1_prt_outlying_years_2_prt_q1_3_prt_2_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_3 date_parts_1_prt_outlying_years_2_prt_q1_3_prt_3_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.024 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_4 date_parts_1_prt_outlying_years_2_prt_q1_3_prt_4_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.023 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_other_days date_parts_1_prt_outlying_years_2_prt_q1_3_prt_other_days_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_2 date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_2_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.120 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_3 date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_3_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_4 date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_4_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_mo_3_prt_other_days date_parts_1_prt_outlying_years_2_prt_other_mo_3_prt_other_da_1  (cost=10000000000.00..10000000226.04 rows=42 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month = ANY ('{0,1,2}'::integer[]))
         ->  Append  (cost=10000000000.00..160000002779.78 rows=223 width=48) (actual time=0.000..0.275 rows=0 loops=1)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_2 date_parts_1_prt_2_2_prt_other_months_3_prt_2_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_3 date_parts_1_prt_2_2_prt_other_months_3_prt_3_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_4 date_parts_1_prt_2_2_prt_other_months_3_prt_4_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_2_2_prt_other_months_3_prt_other_days date_parts_1_prt_2_2_prt_other_months_3_prt_other_days_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_2 date_parts_1_prt_3_2_prt_other_months_3_prt_2_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_3 date_parts_1_prt_3_2_prt_other_months_3_prt_3_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_4 date_parts_1_prt_3_2_prt_other_months_3_prt_4_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_3_2_prt_other_months_3_prt_other_days date_parts_1_prt_3_2_prt_other_months_3_prt_other_days_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_2 date_parts_1_prt_4_2_prt_other_months_3_prt_2_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_3 date_parts_1_prt_4_2_prt_other_months_3_prt_3_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_4 date_parts_1_prt_4_2_prt_other_months_3_prt_4_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_4_2_prt_other_months_3_prt_other_days date_parts_1_prt_4_2_prt_other_months_3_prt_other_days_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_2 date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_2_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_3 date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_3_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.020 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_4 date_parts_1_prt_outlying_years_2_prt_other_months_3_prt_4_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
               ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_other_mo_3_prt_other_days date_parts_1_prt_outlying_years_2_prt_other_mo_3_prt_other_da_2  (cost=10000000000.00..10000000173.67 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (month IS NULL)
 Optimizer: Postgres query optimizer
 Planning Time: 36.449 ms
   (slice0)    Executor memory: 832K bytes.
   (slice1)    Executor memory: 1016K bytes avg x 3 workers, 1016K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 80.924 ms
(292 rows)

-- Equality predicate
-- 16 partitions => 4 from year x 1 from month x 4 from days.
explain analyze select * from DATE_PARTS where month = 3;  -- Not working (it only produces general)
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..160000003347.39 rows=670 width=48) (actual time=3.288..5.053 rows=310 loops=1)
   ->  Append  (cost=10000000000.00..160000003338.45 rows=223 width=48) (actual time=0.041..2.141 rows=109 loops=1)
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.028..0.117 rows=14 loops=1)
               Filter: (month = 3)
               Rows Removed by Filter: 30
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.018..0.117 rows=16 loops=1)
               Filter: (month = 3)
               Rows Removed by Filter: 22
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.017..0.116 rows=16 loops=1)
               Filter: (month = 3)
               Rows Removed by Filter: 21
         ->  Seq Scan on date_parts_1_prt_2_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.016..0.036 rows=2 loops=1)
               Filter: (month = 3)
               Rows Removed by Filter: 1
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.018..0.129 rows=18 loops=1)
               Filter: (month = 3)
               Rows Removed by Filter: 35
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.016..0.104 rows=14 loops=1)
               Filter: (month = 3)
               Rows Removed by Filter: 20
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.017..0.111 rows=15 loops=1)
               Filter: (month = 3)
               Rows Removed by Filter: 24
         ->  Seq Scan on date_parts_1_prt_3_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.016..0.042 rows=3 loops=1)
               Filter: (month = 3)
               Rows Removed by Filter: 2
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.016..0.075 rows=9 loops=1)
               Filter: (month = 3)
               Rows Removed by Filter: 10
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.016..0.063 rows=7 loops=1)
               Filter: (month = 3)
               Rows Removed by Filter: 8
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.017..0.070 rows=8 loops=1)
               Filter: (month = 3)
               Rows Removed by Filter: 17
         ->  Seq Scan on date_parts_1_prt_4_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.015..0.030 rows=1 loops=1)
               Filter: (month = 3)
               Rows Removed by Filter: 2
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_2  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (month = 3)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_3  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (month = 3)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_4  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (month = 3)
         ->  Seq Scan on date_parts_1_prt_outlying_years_2_prt_q1_3_prt_other_days  (cost=10000000000.00..10000000208.58 rows=14 width=48) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (month = 3)
 Optimizer: Postgres query optimizer
 Planning Time: 4.311 ms
   (slice0)    Executor memory: 114K bytes.
   (slice1)    Executor memory: 135K bytes avg x 3 workers, 135K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 7.467 ms
(52 rows)

-- More Equality and General Predicates ---
create table foo(a int, b int)
partition by list (b)
(partition p1 values(1,3), partition p2 values(4,2), default partition other);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
-- General predicate
-- Total 6 parts. b = 1: 1 part, b > 3: 2 parts, b in (0, 1): 2 parts. b is null: 1 part
explain analyze select * from foo where b = 1 union all select * from foo where b > 3 union all select * from foo where b in (0,1) union all select * from foo where b is null;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..60000003442.80 rows=57917 width=8) (actual time=0.892..0.902 rows=0 loops=1)
   ->  Append  (cost=10000000000.00..60000002670.57 rows=19306 width=8) (actual time=0.000..0.129 rows=0 loops=1)
         ->  Seq Scan on foo_1_prt_p1  (cost=10000000000.00..10000000392.75 rows=29 width=8) (actual time=0.000..0.030 rows=0 loops=1)
               Filter: (b = 1)
         ->  Append  (cost=10000000000.00..20000000881.17 rows=19133 width=8) (actual time=0.000..0.049 rows=0 loops=1)
               ->  Seq Scan on foo_1_prt_p2  (cost=10000000000.00..10000000392.75 rows=9567 width=8) (actual time=0.000..0.022 rows=0 loops=1)
                     Filter: (b > 3)
               ->  Seq Scan on foo_1_prt_other  (cost=10000000000.00..10000000392.75 rows=9567 width=8) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: (b > 3)
         ->  Append  (cost=10000000000.00..20000000786.07 rows=115 width=8) (actual time=0.000..0.038 rows=0 loops=1)
               ->  Seq Scan on foo_1_prt_p1 foo_1_prt_p1_1  (cost=10000000000.00..10000000392.75 rows=57 width=8) (actual time=0.000..0.016 rows=0 loops=1)
                     Filter: (b = ANY ('{0,1}'::integer[]))
               ->  Seq Scan on foo_1_prt_other foo_1_prt_other_1  (cost=10000000000.00..10000000392.75 rows=57 width=8) (actual time=0.000..0.016 rows=0 loops=1)
                     Filter: (b = ANY ('{0,1}'::integer[]))
         ->  Seq Scan on foo_1_prt_other foo_1_prt_other_2  (cost=10000000000.00..10000000321.00 rows=29 width=8) (actual time=0.000..0.016 rows=0 loops=1)
               Filter: (b IS NULL)
 Optimizer: Postgres query optimizer
 Planning Time: 1.621 ms
   (slice0)    Executor memory: 44K bytes.
   (slice1)    Executor memory: 55K bytes avg x 3 workers, 55K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 2.007 ms
(22 rows)

drop table if exists pt;
NOTICE:  table "pt" does not exist, skipping
CREATE TABLE pt (id int, gender varchar(2)) 
DISTRIBUTED BY (id)
PARTITION BY LIST (gender)
( PARTITION girls VALUES ('F', NULL), 
  PARTITION boys VALUES ('M'), 
  DEFAULT PARTITION other );
-- General filter
-- TODO #141916623. Expecting 6 parts, but optimizer plan selects 7 parts. The 6 parts breakdown is: gender = 'F': 1 part, gender < 'M': 2 parts (including default), gender in ('F', F'M'): 2 parts, gender is null => 1 part
explain analyze select * from pt where gender = 'F' union all select * from pt where gender < 'M' union all select * from pt where gender in ('F', 'FM') union all select * from pt where gender is null;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..60000002878.54 rows=47827 width=16) (actual time=0.755..0.764 rows=0 loops=1)
   ->  Append  (cost=10000000000.00..60000002240.86 rows=15942 width=16) (actual time=0.000..0.121 rows=0 loops=1)
         ->  Seq Scan on pt_1_prt_girls  (cost=10000000000.00..10000000330.25 rows=24 width=16) (actual time=0.000..0.027 rows=0 loops=1)
               Filter: ((gender)::text = 'F'::text)
         ->  Append  (cost=10000000000.00..20000000739.50 rows=15800 width=16) (actual time=0.000..0.045 rows=0 loops=1)
               ->  Seq Scan on pt_1_prt_girls pt_1_prt_girls_1  (cost=10000000000.00..10000000330.25 rows=7900 width=16) (actual time=0.000..0.017 rows=0 loops=1)
                     Filter: ((gender)::text < 'M'::text)
               ->  Seq Scan on pt_1_prt_other  (cost=10000000000.00..10000000330.25 rows=7900 width=16) (actual time=0.000..0.021 rows=0 loops=1)
                     Filter: ((gender)::text < 'M'::text)
         ->  Append  (cost=10000000000.00..20000000660.97 rows=95 width=16) (actual time=0.000..0.038 rows=0 loops=1)
               ->  Seq Scan on pt_1_prt_girls pt_1_prt_girls_2  (cost=10000000000.00..10000000330.25 rows=47 width=16) (actual time=0.000..0.016 rows=0 loops=1)
                     Filter: ((gender)::text = ANY ('{F,FM}'::text[]))
               ->  Seq Scan on pt_1_prt_other pt_1_prt_other_1  (cost=10000000000.00..10000000330.25 rows=47 width=16) (actual time=0.000..0.016 rows=0 loops=1)
                     Filter: ((gender)::text = ANY ('{F,FM}'::text[]))
         ->  Seq Scan on pt_1_prt_girls pt_1_prt_girls_3  (cost=10000000000.00..10000000271.00 rows=24 width=16) (actual time=0.000..0.016 rows=0 loops=1)
               Filter: (gender IS NULL)
 Optimizer: Postgres query optimizer
 Planning Time: 2.629 ms
   (slice0)    Executor memory: 48K bytes.
   (slice1)    Executor memory: 55K bytes avg x 3 workers, 55K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 1.882 ms
(22 rows)

-- DML
-- Non-default part
insert into DATE_PARTS values (-1, 2004, 11, 30, NULL);
select * from date_parts_1_prt_2_2_prt_q4_3_prt_4 where id < 0;
 id | year | month | day | region 
----+------+-------+-----+--------
 -1 | 2004 |    11 |  30 | 
(1 row)

-- Default year
insert into DATE_PARTS values (-2, 1999, 11, 30, NULL);
select * from date_parts_1_prt_outlying_years_2_prt_q4_3_prt_4 where id < 0;
 id | year | month | day | region 
----+------+-------+-----+--------
 -2 | 1999 |    11 |  30 | 
(1 row)

-- Default month
insert into DATE_PARTS values (-3, 2004, 20, 30, NULL);
select * from date_parts_1_prt_2_2_prt_other_months where id < 0;
 id | year | month | day | region 
----+------+-------+-----+--------
 -3 | 2004 |    20 |  30 | 
(1 row)

-- Default day
insert into DATE_PARTS values (-4, 2004, 10, 50, NULL);
select * from date_parts_1_prt_2_2_prt_q4_3_prt_other_days where id < 0;
 id | year | month | day | region 
----+------+-------+-----+--------
 -4 | 2004 |    10 |  50 | 
(1 row)

-- Default everything
insert into DATE_PARTS values (-5, 1999, 20, 50, NULL);
select * from date_parts_1_prt_outlying_years_2_prt_other_mo_3_prt_other_days where id < 0;
 id | year | month | day | region 
----+------+-------+-----+--------
 -5 | 1999 |    20 |  50 | 
(1 row)

-- Default month + day but not year
insert into DATE_PARTS values (-6, 2002, 20, 50, NULL);
select * from date_parts_1_prt_2_2_prt_other_months_3_prt_other_days where id < 0;
 id | year | month | day | region 
----+------+-------+-----+--------
 -6 | 2002 |    20 |  50 | 
(1 row)

-- Dropped columns with exchange
drop table if exists sales;
NOTICE:  table "sales" does not exist, skipping
CREATE TABLE sales (trans_id int, to_be_dropped1 int, date date, amount 
decimal(9,2), to_be_dropped2 int, region text) 
DISTRIBUTED BY (trans_id)
PARTITION BY RANGE (date)
SUBPARTITION BY LIST (region)
SUBPARTITION TEMPLATE
( SUBPARTITION usa VALUES ('usa'), 
  SUBPARTITION asia VALUES ('asia'), 
  SUBPARTITION europe VALUES ('europe'), 
  DEFAULT SUBPARTITION other_regions)
  (START (date '2011-01-01') INCLUSIVE
   END (date '2012-01-01') EXCLUSIVE
   EVERY (INTERVAL '3 month'), 
   DEFAULT PARTITION outlying_dates );
-- This will introduce different column numbers in subsequent part tables
alter table sales drop column to_be_dropped1;
alter table sales drop column to_be_dropped2;
-- Create the exchange candidate without dropped columns
drop table if exists sales_exchange_part;
NOTICE:  table "sales_exchange_part" does not exist, skipping
create table sales_exchange_part (trans_id int, date date, amount 
decimal(9,2), region text);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'trans_id' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
-- Insert some data
insert into sales_exchange_part values(1, '2011-01-01', 10.1, 'usa');
-- Exchange
ALTER TABLE sales 
ALTER PARTITION FOR (date '2011-01-01')
EXCHANGE PARTITION FOR ('usa') WITH TABLE sales_exchange_part ;
ANALYZE sales;
-- TODO: #141973839. Expected 10 parts, currently selecting 15 parts. First level: 4 parts + 1 default. Second level 2 parts. Total 10 parts.
explain analyze select * from sales where region = 'usa' or region = 'asia';
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..100000000010.60 rows=30 width=50) (actual time=0.993..1.007 rows=1 loops=1)
   ->  Append  (cost=10000000000.00..100000000010.20 rows=10 width=50) (actual time=0.139..0.300 rows=1 loops=1)
         ->  Seq Scan on sales_1_prt_2_2_prt_asia  (cost=10000000000.00..10000000001.01 rows=1 width=54) (actual time=0.000..0.113 rows=0 loops=1)
               Filter: ((region = 'usa'::text) OR (region = 'asia'::text))
         ->  Seq Scan on sales_1_prt_2_2_prt_usa  (cost=10000000000.00..10000000001.01 rows=1 width=19) (actual time=0.019..0.035 rows=1 loops=1)
               Filter: ((region = 'usa'::text) OR (region = 'asia'::text))
         ->  Seq Scan on sales_1_prt_3_2_prt_asia  (cost=10000000000.00..10000000001.01 rows=1 width=54) (actual time=0.000..0.023 rows=0 loops=1)
               Filter: ((region = 'usa'::text) OR (region = 'asia'::text))
         ->  Seq Scan on sales_1_prt_3_2_prt_usa  (cost=10000000000.00..10000000001.01 rows=1 width=54) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((region = 'usa'::text) OR (region = 'asia'::text))
         ->  Seq Scan on sales_1_prt_4_2_prt_asia  (cost=10000000000.00..10000000001.01 rows=1 width=54) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((region = 'usa'::text) OR (region = 'asia'::text))
         ->  Seq Scan on sales_1_prt_4_2_prt_usa  (cost=10000000000.00..10000000001.01 rows=1 width=54) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((region = 'usa'::text) OR (region = 'asia'::text))
         ->  Seq Scan on sales_1_prt_5_2_prt_asia  (cost=10000000000.00..10000000001.01 rows=1 width=54) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: ((region = 'usa'::text) OR (region = 'asia'::text))
         ->  Seq Scan on sales_1_prt_5_2_prt_usa  (cost=10000000000.00..10000000001.01 rows=1 width=54) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((region = 'usa'::text) OR (region = 'asia'::text))
         ->  Seq Scan on sales_1_prt_outlying_dates_2_prt_asia  (cost=10000000000.00..10000000001.01 rows=1 width=54) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((region = 'usa'::text) OR (region = 'asia'::text))
         ->  Seq Scan on sales_1_prt_outlying_dates_2_prt_usa  (cost=10000000000.00..10000000001.01 rows=1 width=54) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: ((region = 'usa'::text) OR (region = 'asia'::text))
 Optimizer: Postgres query optimizer
 Planning Time: 5.994 ms
   (slice0)    Executor memory: 90K bytes.
   (slice1)    Executor memory: 96K bytes avg x 3 workers, 96K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 2.628 ms
(28 rows)

select * from sales where region = 'usa' or region = 'asia';
 trans_id |    date    | amount | region 
----------+------------+--------+--------
        1 | 01-01-2011 |  10.10 | usa
(1 row)

-- Test DynamicIndexScan with extra filter
create index idx_sales_date on sales(date);
explain select * from sales where date = '2011-01-01' and region = 'usa';
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.12..8.16 rows=1 width=19)
   ->  Index Scan using sales_1_prt_2_2_prt_usa_date_idx on sales_1_prt_2_2_prt_usa  (cost=0.12..8.14 rows=1 width=19)
         Index Cond: (date = '01-01-2011'::date)
         Filter: (region = 'usa'::text)
 Optimizer: Postgres query optimizer
(5 rows)

select * from sales where date = '2011-01-01' and region = 'usa';
 trans_id |    date    | amount | region 
----------+------------+--------+--------
        1 | 01-01-2011 |  10.10 | usa
(1 row)

-- Updating partition key
select * from sales_1_prt_2_2_prt_usa;
 trans_id |    date    | amount | region 
----------+------------+--------+--------
        1 | 01-01-2011 |  10.10 | usa
(1 row)

select * from sales_1_prt_2_2_prt_europe;
 trans_id | date | amount | region 
----------+------+--------+--------
(0 rows)

update sales set region = 'europe' where trans_id = 1;
select * from sales_1_prt_2_2_prt_europe;
 trans_id |    date    | amount | region 
----------+------------+--------+--------
        1 | 01-01-2011 |  10.10 | europe
(1 row)

select * from sales_1_prt_2_2_prt_usa;
 trans_id | date | amount | region 
----------+------+--------+--------
(0 rows)

select * from sales;
 trans_id |    date    | amount | region 
----------+------------+--------+--------
        1 | 01-01-2011 |  10.10 | europe
(1 row)

-- Distinct From
drop table if exists bar;
NOTICE:  table "bar" does not exist, skipping
CREATE TABLE bar (i INTEGER, j decimal)
partition by list (j)
subpartition by range (i) subpartition template (start(1) end(4) every(2))
(partition p1 values(0.2,2.8, NULL), partition p2 values(1.7,3.1),
partition p3 values(5.6), default partition other);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greengage Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into bar values(1, 0.2); --p1
insert into bar values(1, 1.7); --p2
insert into bar values(1, 2.1); --default
insert into bar values(1, 5.6); --default
insert into bar values(1, NULL); --p1
-- In-equality
-- 8 parts: All 4 parts on first level and each will have 2 range parts 
explain analyze select * from bar where j>0.02;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..80000003909.33 rows=132267 width=36) (actual time=1.116..1.421 rows=4 loops=1)
   ->  Append  (cost=10000000000.00..80000002145.78 rows=44089 width=36) (actual time=0.051..0.259 rows=4 loops=1)
         ->  Seq Scan on bar_1_prt_p1_2_prt_1  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.025..0.041 rows=1 loops=1)
               Filter: (j > 0.02)
               Rows Removed by Filter: 1
         ->  Seq Scan on bar_1_prt_p1_2_prt_2  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (j > 0.02)
         ->  Seq Scan on bar_1_prt_p2_2_prt_1  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.016..0.031 rows=1 loops=1)
               Filter: (j > 0.02)
         ->  Seq Scan on bar_1_prt_p2_2_prt_2  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (j > 0.02)
         ->  Seq Scan on bar_1_prt_p3_2_prt_1  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.015..0.030 rows=1 loops=1)
               Filter: (j > 0.02)
         ->  Seq Scan on bar_1_prt_p3_2_prt_2  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (j > 0.02)
         ->  Seq Scan on bar_1_prt_other_2_prt_1  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.015..0.030 rows=1 loops=1)
               Filter: (j > 0.02)
         ->  Seq Scan on bar_1_prt_other_2_prt_2  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.000..0.027 rows=0 loops=1)
               Filter: (j > 0.02)
 Optimizer: Postgres query optimizer
 Planning Time: 3.317 ms
   (slice0)    Executor memory: 57K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 2.869 ms
(25 rows)

-- 6 parts: Excluding 1 list parts at first level. So, 3 at first level and each has 2 at second level.
explain analyze select * from bar where j>2.8;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..60000002932.00 rows=99200 width=36) (actual time=0.590..0.635 rows=1 loops=1)
   ->  Append  (cost=10000000000.00..60000001609.33 rows=33067 width=36) (actual time=0.072..0.151 rows=1 loops=1)
         ->  Seq Scan on bar_1_prt_p2_2_prt_1  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.000..0.033 rows=0 loops=1)
               Filter: (j > 2.8)
         ->  Seq Scan on bar_1_prt_p2_2_prt_2  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (j > 2.8)
         ->  Seq Scan on bar_1_prt_p3_2_prt_1  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.015..0.031 rows=1 loops=1)
               Filter: (j > 2.8)
         ->  Seq Scan on bar_1_prt_p3_2_prt_2  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (j > 2.8)
         ->  Seq Scan on bar_1_prt_other_2_prt_1  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.000..0.025 rows=0 loops=1)
               Filter: (j > 2.8)
         ->  Seq Scan on bar_1_prt_other_2_prt_2  (cost=10000000000.00..10000000240.67 rows=5511 width=36) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (j > 2.8)
 Optimizer: Postgres query optimizer
 Planning Time: 1.398 ms
   (slice0)    Executor memory: 52K bytes.
   (slice1)    Executor memory: 52K bytes avg x 3 workers, 52K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 1.761 ms
(20 rows)

-- Distinct From
-- 6 parts: Everything except 1 part that contains 5.6.
explain analyze select * from bar where j is distinct from 5.6;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..80000007871.38 rows=396403 width=36) (actual time=0.657..0.688 rows=4 loops=1)
   ->  Append  (cost=10000000000.00..80000002586.01 rows=132134 width=36) (actual time=0.033..0.233 rows=4 loops=1)
         ->  Seq Scan on bar_1_prt_p1_2_prt_1  (cost=10000000000.00..10000000240.67 rows=16517 width=36) (actual time=0.023..0.044 rows=2 loops=1)
               Filter: (j IS DISTINCT FROM 5.6)
         ->  Seq Scan on bar_1_prt_p1_2_prt_2  (cost=10000000000.00..10000000240.67 rows=16517 width=36) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (j IS DISTINCT FROM 5.6)
         ->  Seq Scan on bar_1_prt_p2_2_prt_1  (cost=10000000000.00..10000000240.67 rows=16517 width=36) (actual time=0.015..0.030 rows=1 loops=1)
               Filter: (j IS DISTINCT FROM 5.6)
         ->  Seq Scan on bar_1_prt_p2_2_prt_2  (cost=10000000000.00..10000000240.67 rows=16517 width=36) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (j IS DISTINCT FROM 5.6)
         ->  Seq Scan on bar_1_prt_p3_2_prt_1  (cost=10000000000.00..10000000240.67 rows=16517 width=36) (actual time=0.000..0.024 rows=0 loops=1)
               Filter: (j IS DISTINCT FROM 5.6)
         ->  Seq Scan on bar_1_prt_p3_2_prt_2  (cost=10000000000.00..10000000240.67 rows=16517 width=36) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (j IS DISTINCT FROM 5.6)
         ->  Seq Scan on bar_1_prt_other_2_prt_1  (cost=10000000000.00..10000000240.67 rows=16517 width=36) (actual time=0.014..0.029 rows=1 loops=1)
               Filter: (j IS DISTINCT FROM 5.6)
         ->  Seq Scan on bar_1_prt_other_2_prt_2  (cost=10000000000.00..10000000240.67 rows=16517 width=36) (actual time=0.000..0.023 rows=0 loops=1)
               Filter: (j IS DISTINCT FROM 5.6)
 Optimizer: Postgres query optimizer
 Planning Time: 1.810 ms
   (slice0)    Executor memory: 57K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 1.856 ms
(24 rows)

-- 8 parts: NULL is shared with others on p1. So, all 8 parts.
explain analyze select * from bar where j is distinct from NULL;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..80000007540.71 rows=396403 width=36) (actual time=0.641..0.672 rows=4 loops=1)
   ->  Append  (cost=10000000000.00..80000002255.34 rows=132134 width=36) (actual time=0.031..0.228 rows=4 loops=1)
         ->  Seq Scan on bar_1_prt_p1_2_prt_1  (cost=10000000000.00..10000000199.33 rows=16517 width=36) (actual time=0.021..0.037 rows=1 loops=1)
               Filter: (j IS NOT NULL)
               Rows Removed by Filter: 1
         ->  Seq Scan on bar_1_prt_p1_2_prt_2  (cost=10000000000.00..10000000199.33 rows=16517 width=36) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (j IS NOT NULL)
         ->  Seq Scan on bar_1_prt_p2_2_prt_1  (cost=10000000000.00..10000000199.33 rows=16517 width=36) (actual time=0.014..0.034 rows=1 loops=1)
               Filter: (j IS NOT NULL)
         ->  Seq Scan on bar_1_prt_p2_2_prt_2  (cost=10000000000.00..10000000199.33 rows=16517 width=36) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (j IS NOT NULL)
         ->  Seq Scan on bar_1_prt_p3_2_prt_1  (cost=10000000000.00..10000000199.33 rows=16517 width=36) (actual time=0.014..0.028 rows=1 loops=1)
               Filter: (j IS NOT NULL)
         ->  Seq Scan on bar_1_prt_p3_2_prt_2  (cost=10000000000.00..10000000199.33 rows=16517 width=36) (actual time=0.000..0.021 rows=0 loops=1)
               Filter: (j IS NOT NULL)
         ->  Seq Scan on bar_1_prt_other_2_prt_1  (cost=10000000000.00..10000000199.33 rows=16517 width=36) (actual time=0.014..0.028 rows=1 loops=1)
               Filter: (j IS NOT NULL)
         ->  Seq Scan on bar_1_prt_other_2_prt_2  (cost=10000000000.00..10000000199.33 rows=16517 width=36) (actual time=0.000..0.022 rows=0 loops=1)
               Filter: (j IS NOT NULL)
 Optimizer: Postgres query optimizer
 Planning Time: 1.630 ms
   (slice0)    Executor memory: 57K bytes.
   (slice1)    Executor memory: 65K bytes avg x 3 workers, 65K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 1.958 ms
(25 rows)

-- Table partitioned by boolean column
CREATE TABLE pt_bool_tab
(
  col1 int,
  col2 bool
)
distributed by (col1)
partition by list(col2)
(
  partition part1 values(true),
  partition part2 values(false)
);
INSERT INTO pt_bool_tab SELECT i, true FROM generate_series(1,3)i;
INSERT INTO pt_bool_tab SELECT i, false FROM generate_series(1,2)i;
EXPLAIN SELECT * FROM pt_bool_tab WHERE col2 IS true;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000969.00 rows=46750 width=5)
   ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
         Filter: (col2 IS TRUE)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab WHERE col2 IS true;
 col1 | col2 
------+------
    1 | t
    2 | t
    3 | t
(3 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE col2 IS false;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000969.00 rows=46750 width=5)
   ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
         Filter: (col2 IS FALSE)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab WHERE col2 IS false;
 col1 | col2 
------+------
    2 | f
    1 | f
(2 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE col2 IS NULL;
                QUERY PLAN                
------------------------------------------
 Result  (cost=0.00..0.00 rows=0 width=0)
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

SELECT * FROM pt_bool_tab WHERE col2 IS NULL;
 col1 | col2 
------+------
(0 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE col2 IS unknown;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000000694.14 rows=187 width=5)
   ->  Append  (cost=10000000000.00..20000000691.65 rows=62 width=5)
         ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: (col2 IS UNKNOWN)
         ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: (col2 IS UNKNOWN)
 Optimizer: Postgres query optimizer
(7 rows)

SELECT * FROM pt_bool_tab WHERE col2 IS unknown;
 col1 | col2 
------+------
(0 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE col2 IS NOT true;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000969.00 rows=46750 width=5)
   ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
         Filter: (col2 IS NOT TRUE)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab WHERE col2 IS NOT true;
 col1 | col2 
------+------
    2 | f
    1 | f
(2 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE col2 IS NOT false;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000969.00 rows=46750 width=5)
   ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
         Filter: (col2 IS NOT FALSE)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab WHERE col2 IS NOT false;
 col1 | col2 
------+------
    2 | t
    3 | t
    1 | t
(3 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE col2 IS NOT unknown;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000003493.53 rows=186813 width=5)
   ->  Append  (cost=10000000000.00..20000001002.69 rows=62271 width=5)
         ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT UNKNOWN)
         ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT UNKNOWN)
 Optimizer: Postgres query optimizer
(7 rows)

SELECT * FROM pt_bool_tab WHERE col2 IS NOT unknown;
 col1 | col2 
------+------
    1 | f
    1 | t
    2 | f
    2 | t
    3 | t
(5 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE col2 IS NOT NULL;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000003493.53 rows=186813 width=5)
   ->  Append  (cost=10000000000.00..20000001002.69 rows=62271 width=5)
         ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT NULL)
         ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT NULL)
 Optimizer: Postgres query optimizer
(7 rows)

SELECT * FROM pt_bool_tab WHERE col2 IS NOT NULL;
 col1 | col2 
------+------
    1 | f
    1 | t
    2 | f
    2 | t
    3 | t
(5 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE (not col2) IS true;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000002093.83 rows=93500 width=5)
   ->  Append  (cost=10000000000.00..20000000847.17 rows=31167 width=5)
         ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS TRUE)
         ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS TRUE)
 Optimizer: Postgres-based planner
(7 rows)

SELECT * FROM pt_bool_tab WHERE (not col2) IS true;
 col1 | col2 
------+------
    2 | f
    1 | f
(2 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE (not col2) IS false;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000002093.83 rows=93500 width=5)
   ->  Append  (cost=10000000000.00..20000000847.17 rows=31167 width=5)
         ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS FALSE)
         ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS FALSE)
 Optimizer: Postgres-based planner
(7 rows)

SELECT * FROM pt_bool_tab WHERE (not col2) IS false;
 col1 | col2 
------+------
    2 | t
    3 | t
    1 | t
(3 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE (not col2) IS NULL;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000000694.14 rows=187 width=5)
   ->  Append  (cost=10000000000.00..20000000691.65 rows=62 width=5)
         ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS NULL)
         ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS NULL)
 Optimizer: Postgres-based planner
(7 rows)

SELECT * FROM pt_bool_tab WHERE (not col2) IS NULL;
 col1 | col2 
------+------
(0 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE (not col2) IS unknown;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000000694.14 rows=187 width=5)
   ->  Append  (cost=10000000000.00..20000000691.65 rows=62 width=5)
         ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS UNKNOWN)
         ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS UNKNOWN)
 Optimizer: Postgres-based planner
(7 rows)

SELECT * FROM pt_bool_tab WHERE (not col2) IS unknown;
 col1 | col2 
------+------
(0 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE (not col2) IS NOT true;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000002093.83 rows=93500 width=5)
   ->  Append  (cost=10000000000.00..20000000847.17 rows=31167 width=5)
         ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT TRUE)
         ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT TRUE)
 Optimizer: Postgres-based planner
(7 rows)

SELECT * FROM pt_bool_tab WHERE (not col2) IS NOT true;
 col1 | col2 
------+------
    2 | t
    3 | t
    1 | t
(3 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE (not col2) IS NOT false;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000002093.83 rows=93500 width=5)
   ->  Append  (cost=10000000000.00..20000000847.17 rows=31167 width=5)
         ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT FALSE)
         ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT FALSE)
 Optimizer: Postgres-based planner
(7 rows)

SELECT * FROM pt_bool_tab WHERE (not col2) IS NOT false;
 col1 | col2 
------+------
    2 | f
    1 | f
(2 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE (not col2) IS NOT unknown;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000003493.53 rows=186813 width=5)
   ->  Append  (cost=10000000000.00..20000001002.69 rows=62271 width=5)
         ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT UNKNOWN)
         ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT UNKNOWN)
 Optimizer: Postgres-based planner
(7 rows)

SELECT * FROM pt_bool_tab WHERE (not col2) IS NOT unknown;
 col1 | col2 
------+------
    1 | f
    1 | t
    2 | f
    2 | t
    3 | t
(5 rows)

EXPLAIN SELECT * FROM pt_bool_tab WHERE (not col2) IS NOT NULL;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000003493.53 rows=186813 width=5)
   ->  Append  (cost=10000000000.00..20000001002.69 rows=62271 width=5)
         ->  Seq Scan on pt_bool_tab_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT NULL)
         ->  Seq Scan on pt_bool_tab_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT NULL)
 Optimizer: Postgres-based planner
(7 rows)

SELECT * FROM pt_bool_tab WHERE (not col2) IS NOT NULL;
 col1 | col2 
------+------
    1 | f
    1 | t
    2 | f
    2 | t
    3 | t
(5 rows)

CREATE TABLE pt_bool_tab_df
(
  col1 int,
  col2 bool
)
distributed by (col1)
partition by list(col2)
(
  partition part1 values(true),
  partition part2 values(false),
  default partition def
);
INSERT INTO pt_bool_tab_df SELECT i, true FROM generate_series(1,3)i;
INSERT INTO pt_bool_tab_df SELECT i, false FROM generate_series(1,2)i;
INSERT INTO pt_bool_tab_df SELECT i, NULL FROM generate_series(1,1)i;
EXPLAIN SELECT * FROM pt_bool_tab_df WHERE col2 IS true;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000969.00 rows=46750 width=5)
   ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
         Filter: (col2 IS TRUE)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab_df WHERE col2 IS true;
 col1 | col2 
------+------
    1 | t
    2 | t
    3 | t
(3 rows)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE col2 IS false;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000969.00 rows=46750 width=5)
   ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
         Filter: (col2 IS FALSE)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab_df WHERE col2 IS false;
 col1 | col2 
------+------
    2 | f
    1 | f
(2 rows)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE col2 IS NULL;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000346.91 rows=94 width=5)
   ->  Seq Scan on pt_bool_tab_df_1_prt_def  (cost=10000000000.00..10000000345.67 rows=31 width=5)
         Filter: (col2 IS NULL)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab_df WHERE col2 IS NULL;
 col1 | col2 
------+------
    1 | 
(1 row)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE col2 IS unknown;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000001041.21 rows=280 width=5)
   ->  Append  (cost=10000000000.00..30000001037.47 rows=94 width=5)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: (col2 IS UNKNOWN)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: (col2 IS UNKNOWN)
         ->  Seq Scan on pt_bool_tab_df_1_prt_def  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: (col2 IS UNKNOWN)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_bool_tab_df WHERE col2 IS unknown;
 col1 | col2 
------+------
    1 | 
(1 row)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE col2 IS NOT true;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000969.00 rows=46750 width=5)
   ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
         Filter: (col2 IS NOT TRUE)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab_df WHERE col2 IS NOT true;
 col1 | col2 
------+------
    2 | f
    1 | f
(2 rows)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE col2 IS NOT false;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000969.00 rows=46750 width=5)
   ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
         Filter: (col2 IS NOT FALSE)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab_df WHERE col2 IS NOT false;
 col1 | col2 
------+------
    2 | t
    3 | t
    1 | t
(3 rows)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE col2 IS NOT unknown;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000005240.29 rows=280220 width=5)
   ->  Append  (cost=10000000000.00..30000001504.03 rows=93406 width=5)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT UNKNOWN)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT UNKNOWN)
         ->  Seq Scan on pt_bool_tab_df_1_prt_def  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT UNKNOWN)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_bool_tab_df WHERE col2 IS NOT unknown;
 col1 | col2 
------+------
    2 | f
    2 | t
    3 | t
    1 | f
    1 | t
(5 rows)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE col2 IS NOT NULL;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000005240.29 rows=280220 width=5)
   ->  Append  (cost=10000000000.00..30000001504.03 rows=93406 width=5)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT NULL)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT NULL)
         ->  Seq Scan on pt_bool_tab_df_1_prt_def  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT NULL)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_bool_tab_df WHERE col2 IS NOT NULL;
 col1 | col2 
------+------
    2 | f
    2 | t
    3 | t
    1 | f
    1 | t
(5 rows)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE (not col2) IS true;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000003140.75 rows=140250 width=5)
   ->  Append  (cost=10000000000.00..30000001270.75 rows=46750 width=5)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS TRUE)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS TRUE)
         ->  Seq Scan on pt_bool_tab_df_1_prt_def  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS TRUE)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_df WHERE (not col2) IS true;
 col1 | col2 
------+------
    1 | f
    2 | f
(2 rows)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE (not col2) IS false;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000003140.75 rows=140250 width=5)
   ->  Append  (cost=10000000000.00..30000001270.75 rows=46750 width=5)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS FALSE)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS FALSE)
         ->  Seq Scan on pt_bool_tab_df_1_prt_def  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS FALSE)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_df WHERE (not col2) IS false;
 col1 | col2 
------+------
    1 | t
    2 | t
    3 | t
(3 rows)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE (not col2) IS NULL;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000001041.21 rows=280 width=5)
   ->  Append  (cost=10000000000.00..30000001037.47 rows=94 width=5)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS NULL)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS NULL)
         ->  Seq Scan on pt_bool_tab_df_1_prt_def  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS NULL)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_df WHERE (not col2) IS NULL;
 col1 | col2 
------+------
    1 | 
(1 row)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE (not col2) IS unknown;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000001041.21 rows=280 width=5)
   ->  Append  (cost=10000000000.00..30000001037.47 rows=94 width=5)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS UNKNOWN)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS UNKNOWN)
         ->  Seq Scan on pt_bool_tab_df_1_prt_def  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS UNKNOWN)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_df WHERE (not col2) IS unknown;
 col1 | col2 
------+------
    1 | 
(1 row)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE (not col2) IS NOT true;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000003140.75 rows=140250 width=5)
   ->  Append  (cost=10000000000.00..30000001270.75 rows=46750 width=5)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT TRUE)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT TRUE)
         ->  Seq Scan on pt_bool_tab_df_1_prt_def  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT TRUE)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_df WHERE (not col2) IS NOT true;
 col1 | col2 
------+------
    2 | t
    3 | t
    1 | t
    1 | 
(4 rows)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE (not col2) IS NOT false;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000003140.75 rows=140250 width=5)
   ->  Append  (cost=10000000000.00..30000001270.75 rows=46750 width=5)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT FALSE)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT FALSE)
         ->  Seq Scan on pt_bool_tab_df_1_prt_def  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT FALSE)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_df WHERE (not col2) IS NOT false;
 col1 | col2 
------+------
    2 | f
    1 | f
    1 | 
(3 rows)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE (not col2) IS NOT unknown;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000005240.29 rows=280220 width=5)
   ->  Append  (cost=10000000000.00..30000001504.03 rows=93406 width=5)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT UNKNOWN)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT UNKNOWN)
         ->  Seq Scan on pt_bool_tab_df_1_prt_def  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT UNKNOWN)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_df WHERE (not col2) IS NOT unknown;
 col1 | col2 
------+------
    1 | f
    1 | t
    2 | f
    2 | t
    3 | t
(5 rows)

EXPLAIN SELECT * FROM pt_bool_tab_df WHERE (not col2) IS NOT NULL;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000005240.29 rows=280220 width=5)
   ->  Append  (cost=10000000000.00..30000001504.03 rows=93406 width=5)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT NULL)
         ->  Seq Scan on pt_bool_tab_df_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT NULL)
         ->  Seq Scan on pt_bool_tab_df_1_prt_def  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT NULL)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_df WHERE (not col2) IS NOT NULL;
 col1 | col2 
------+------
    2 | f
    2 | t
    3 | t
    1 | f
    1 | t
(5 rows)

CREATE TABLE pt_bool_tab_null
(
  col1 int,
  col2 bool
)
distributed by (col1)
partition by list(col2)
(
  partition part1 values(true),
  partition part2 values(false),
  partition part3 values(null)
);
INSERT INTO pt_bool_tab_null SELECT i, true FROM generate_series(1,3)i;
INSERT INTO pt_bool_tab_null SELECT i, false FROM generate_series(1,2)i;
INSERT INTO pt_bool_tab_null SELECT i, NULL FROM generate_series(1,1)i;
EXPLAIN SELECT * FROM pt_bool_tab_null WHERE col2 IS true;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000969.00 rows=46750 width=5)
   ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
         Filter: (col2 IS TRUE)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab_null WHERE col2 IS true;
 col1 | col2 
------+------
    1 | t
    2 | t
    3 | t
(3 rows)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE col2 IS false;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000969.00 rows=46750 width=5)
   ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
         Filter: (col2 IS FALSE)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab_null WHERE col2 IS false;
 col1 | col2 
------+------
    1 | f
    2 | f
(2 rows)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE col2 IS NULL;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000346.91 rows=94 width=5)
   ->  Seq Scan on pt_bool_tab_null_1_prt_part3  (cost=10000000000.00..10000000345.67 rows=31 width=5)
         Filter: (col2 IS NULL)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab_null WHERE col2 IS NULL;
 col1 | col2 
------+------
    1 | 
(1 row)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE col2 IS unknown;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000001041.21 rows=280 width=5)
   ->  Append  (cost=10000000000.00..30000001037.47 rows=94 width=5)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: (col2 IS UNKNOWN)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: (col2 IS UNKNOWN)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part3  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: (col2 IS UNKNOWN)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_bool_tab_null WHERE col2 IS unknown;
 col1 | col2 
------+------
    1 | 
(1 row)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE col2 IS NOT true;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000969.00 rows=46750 width=5)
   ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
         Filter: (col2 IS NOT TRUE)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab_null WHERE col2 IS NOT true;
 col1 | col2 
------+------
    1 | f
    2 | f
(2 rows)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE col2 IS NOT false;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..10000000969.00 rows=46750 width=5)
   ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
         Filter: (col2 IS NOT FALSE)
 Optimizer: Postgres query optimizer
(4 rows)

SELECT * FROM pt_bool_tab_null WHERE col2 IS NOT false;
 col1 | col2 
------+------
    2 | t
    3 | t
    1 | t
(3 rows)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE col2 IS NOT unknown;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000005240.29 rows=280220 width=5)
   ->  Append  (cost=10000000000.00..30000001504.03 rows=93406 width=5)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT UNKNOWN)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT UNKNOWN)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part3  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT UNKNOWN)
 Optimizer: Postgres query optimizer
(9 rows)

SELECT * FROM pt_bool_tab_null WHERE col2 IS NOT unknown;
 col1 | col2 
------+------
    2 | f
    2 | t
    3 | t
    1 | f
    1 | t
(5 rows)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE col2 IS NOT NULL;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..20000003493.53 rows=186813 width=5)
   ->  Append  (cost=10000000000.00..20000001002.69 rows=62271 width=5)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT NULL)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: (col2 IS NOT NULL)
 Optimizer: Postgres query optimizer
(7 rows)

SELECT * FROM pt_bool_tab_null WHERE col2 IS NOT NULL;
 col1 | col2 
------+------
    2 | f
    2 | t
    3 | t
    1 | f
    1 | t
(5 rows)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE (not col2) IS true;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000003140.75 rows=140250 width=5)
   ->  Append  (cost=10000000000.00..30000001270.75 rows=46750 width=5)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS TRUE)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS TRUE)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part3  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS TRUE)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_null WHERE (not col2) IS true;
 col1 | col2 
------+------
    2 | f
    1 | f
(2 rows)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE (not col2) IS false;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000003140.75 rows=140250 width=5)
   ->  Append  (cost=10000000000.00..30000001270.75 rows=46750 width=5)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS FALSE)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS FALSE)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part3  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS FALSE)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_null WHERE (not col2) IS false;
 col1 | col2 
------+------
    2 | t
    3 | t
    1 | t
(3 rows)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE (not col2) IS NULL;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000001041.21 rows=280 width=5)
   ->  Append  (cost=10000000000.00..30000001037.47 rows=94 width=5)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS NULL)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS NULL)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part3  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS NULL)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_null WHERE (not col2) IS NULL;
 col1 | col2 
------+------
    1 | 
(1 row)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE (not col2) IS unknown;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000001041.21 rows=280 width=5)
   ->  Append  (cost=10000000000.00..30000001037.47 rows=94 width=5)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS UNKNOWN)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS UNKNOWN)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part3  (cost=10000000000.00..10000000345.67 rows=31 width=5)
               Filter: ((NOT col2) IS UNKNOWN)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_null WHERE (not col2) IS unknown;
 col1 | col2 
------+------
    1 | 
(1 row)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE (not col2) IS NOT true;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000003140.75 rows=140250 width=5)
   ->  Append  (cost=10000000000.00..30000001270.75 rows=46750 width=5)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT TRUE)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT TRUE)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part3  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT TRUE)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_null WHERE (not col2) IS NOT true;
 col1 | col2 
------+------
    1 | t
    1 | 
    2 | t
    3 | t
(4 rows)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE (not col2) IS NOT false;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000003140.75 rows=140250 width=5)
   ->  Append  (cost=10000000000.00..30000001270.75 rows=46750 width=5)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT FALSE)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT FALSE)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part3  (cost=10000000000.00..10000000345.67 rows=15583 width=5)
               Filter: ((NOT col2) IS NOT FALSE)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_null WHERE (not col2) IS NOT false;
 col1 | col2 
------+------
    1 | f
    1 | 
    2 | f
(3 rows)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE (not col2) IS NOT unknown;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000005240.29 rows=280220 width=5)
   ->  Append  (cost=10000000000.00..30000001504.03 rows=93406 width=5)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT UNKNOWN)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT UNKNOWN)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part3  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT UNKNOWN)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_null WHERE (not col2) IS NOT unknown;
 col1 | col2 
------+------
    1 | f
    1 | t
    2 | f
    2 | t
    3 | t
(5 rows)

EXPLAIN SELECT * FROM pt_bool_tab_null WHERE (not col2) IS NOT NULL;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=10000000000.00..30000005240.29 rows=280220 width=5)
   ->  Append  (cost=10000000000.00..30000001504.03 rows=93406 width=5)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part2  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT NULL)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part1  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT NULL)
         ->  Seq Scan on pt_bool_tab_null_1_prt_part3  (cost=10000000000.00..10000000345.67 rows=31136 width=5)
               Filter: ((NOT col2) IS NOT NULL)
 Optimizer: Postgres-based planner
(9 rows)

SELECT * FROM pt_bool_tab_null WHERE (not col2) IS NOT NULL;
 col1 | col2 
------+------
    1 | f
    1 | t
    2 | f
    2 | t
    3 | t
(5 rows)

RESET ALL;
