-- Test locking behaviour. When creating, dropping, querying or adding indexes
-- partitioned tables, we want to lock only the master, not the children.
--
-- Previously, we used to only lock the parent table in many DDL operations.
-- That was always a bit bogus, but we did it to avoid running out of lock space
-- when working on large partition hierarchies. We don't play fast and loose
-- like that anymore, but keep the tests. If a user runs out of lock space, you
-- can work around that by simply bumping up max_locks_per_transactions.
--
-- Show locks in master and in segments. Because the number of segments
-- in the cluster depends on configuration, we print only summary information
-- of the locks in segments. If a relation is locked only on one segment,
-- we print that as a special case, but otherwise we just print "n segments",
-- meaning the relation is locked on more than one segment.
create or replace view locktest_master as
select coalesce(
  case when relname like 'pg_toast%index' then 'toast index'
       when relname like 'pg_toast%' then 'toast table'
       when relname like 'pg_aoseg%' then 'aoseg table'
       when relname like 'pg_aovisimap%index' then 'aovisimap index'
       when relname like 'pg_aovisimap%' then 'aovisimap table'
       else relname end, 'dropped table'),
  mode,
  locktype,
  'master'::text as node
from pg_locks l
left outer join pg_class c on ((l.locktype = 'append-only segment file' and l.relation = c.relfilenode) or (l.locktype != 'append-only segment file' and l.relation = c.oid)),
pg_database d
where relation is not null
and l.database = d.oid
and (relname <> 'gp_fault_strategy' and relname != 'locktest_master' or relname is NULL)
and d.datname = current_database()
and l.gp_segment_id = -1
group by l.gp_segment_id, relation, relname, locktype, mode
order by 1, 3, 2;
create or replace view locktest_segments_dist as
select relname,
  mode,
  locktype,
  l.gp_segment_id as node,
  relation
from pg_locks l
left outer join pg_class c on ((l.locktype = 'append-only segment file' and l.relation = c.relfilenode) or (l.locktype != 'append-only segment file' and l.relation = c.oid)),
pg_database d
where relation is not null
and l.database = d.oid
and (relname <> 'gp_fault_strategy' and relname != 'locktest_segments_dist' or relname is NULL)
and d.datname = current_database()
and l.gp_segment_id > -1
group by l.gp_segment_id, relation, relname, locktype, mode;
create or replace view locktest_segments as
SELECT coalesce(
  case when relname like 'pg_toast%index' then 'toast index'
       when relname like 'pg_toast%' then 'toast table'
       when relname like 'pg_aoseg%' then 'aoseg table'
       when relname like 'pg_aovisimap%index' then 'aovisimap index'
       when relname like 'pg_aovisimap%' then 'aovisimap table'
       else relname end, 'dropped table'),
  mode,
  locktype,
  case when count(*) = 1 then '1 segment'
       else 'n segments' end as node
  FROM gp_dist_random('locktest_segments_dist')
  group by relname, relation, mode, locktype;
-- Partitioned table with toast table
begin;
-- creation
create table partlockt (i int, t text) partition by range(i)
(start(1) end(10) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_1" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_2" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_3" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_4" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_5" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_6" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_7" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_8" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_9" for table "partlockt"
select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
     coalesce      |        mode         | locktype |  node  
-------------------+---------------------+----------+--------
 partlockt         | AccessExclusiveLock | relation | master
 partlockt_1_prt_1 | AccessExclusiveLock | relation | master
 partlockt_1_prt_2 | AccessExclusiveLock | relation | master
 partlockt_1_prt_3 | AccessExclusiveLock | relation | master
 partlockt_1_prt_4 | AccessExclusiveLock | relation | master
 partlockt_1_prt_5 | AccessExclusiveLock | relation | master
 partlockt_1_prt_6 | AccessExclusiveLock | relation | master
 partlockt_1_prt_7 | AccessExclusiveLock | relation | master
 partlockt_1_prt_8 | AccessExclusiveLock | relation | master
 partlockt_1_prt_9 | AccessExclusiveLock | relation | master
 toast index       | AccessExclusiveLock | relation | master
 toast table       | ShareLock           | relation | master
(12 rows)

select * from locktest_segments where coalesce not like 'gp_%' and coalesce not like 'pg_%';
     coalesce      |        mode         | locktype |    node    
-------------------+---------------------+----------+------------
 partlockt_1_prt_2 | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_8 | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_5 | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_3 | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_4 | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_1 | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_9 | AccessExclusiveLock | relation | n segments
 partlockt         | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_6 | AccessExclusiveLock | relation | n segments
 toast table       | ShareLock           | relation | n segments
 partlockt_1_prt_7 | AccessExclusiveLock | relation | n segments
 toast index       | AccessExclusiveLock | relation | n segments
(12 rows)

commit;
-- drop
begin;
drop table partlockt;
select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
   coalesce    |        mode         | locktype |  node  
---------------+---------------------+----------+--------
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
(30 rows)

select * from locktest_segments where coalesce not like 'gp_%' and coalesce not like 'pg_%';
   coalesce    |        mode         | locktype |    node    
---------------+---------------------+----------+------------
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
(30 rows)

commit;
-- AO table (ao segments, block directory won't exist after create)
begin;
-- creation
create table partlockt (i int, t text, n numeric)
with (appendonly = true)
partition by list(i)
(values(1), values(2), values(3));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_1" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_2" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_3" for table "partlockt"
select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
     coalesce      |        mode         | locktype |  node  
-------------------+---------------------+----------+--------
 partlockt         | AccessExclusiveLock | relation | master
 partlockt_1_prt_1 | AccessExclusiveLock | relation | master
 partlockt_1_prt_2 | AccessExclusiveLock | relation | master
 partlockt_1_prt_3 | AccessExclusiveLock | relation | master
 toast index       | AccessExclusiveLock | relation | master
 toast table       | ShareLock           | relation | master
(6 rows)

select * from locktest_segments where coalesce not like 'gp_%' and coalesce not like 'pg_%';
     coalesce      |        mode         | locktype |    node    
-------------------+---------------------+----------+------------
 toast index       | AccessExclusiveLock | relation | n segments
 partlockt         | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_3 | AccessExclusiveLock | relation | n segments
 toast table       | ShareLock           | relation | n segments
 partlockt_1_prt_2 | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_1 | AccessExclusiveLock | relation | n segments
(6 rows)

commit;
begin;
-- add a little data
insert into partlockt values(1), (2), (3);
insert into partlockt values(1), (2), (3);
insert into partlockt values(1), (2), (3);
insert into partlockt values(1), (2), (3);
insert into partlockt values(1), (2), (3);
select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
     coalesce      |        mode         |         locktype         |  node  
-------------------+---------------------+--------------------------+--------
 partlockt         | RowExclusiveLock    | relation                 | master
 partlockt_1_prt_1 | AccessExclusiveLock | append-only segment file | master
 partlockt_1_prt_1 | AccessShareLock     | relation                 | master
 partlockt_1_prt_1 | RowExclusiveLock    | relation                 | master
 partlockt_1_prt_2 | AccessExclusiveLock | append-only segment file | master
 partlockt_1_prt_2 | AccessShareLock     | relation                 | master
 partlockt_1_prt_2 | RowExclusiveLock    | relation                 | master
 partlockt_1_prt_3 | AccessExclusiveLock | append-only segment file | master
 partlockt_1_prt_3 | AccessShareLock     | relation                 | master
 partlockt_1_prt_3 | RowExclusiveLock    | relation                 | master
(10 rows)

select * from locktest_segments where coalesce not like 'gp_%' and coalesce not like 'pg_%';
     coalesce      |        mode         |         locktype         |    node    
-------------------+---------------------+--------------------------+------------
 aoseg table       | AccessShareLock     | relation                 | n segments
 aoseg table       | AccessShareLock     | relation                 | n segments
 aoseg table       | AccessShareLock     | relation                 | n segments
 partlockt_1_prt_1 | RowExclusiveLock    | relation                 | 1 segment
 partlockt_1_prt_2 | AccessExclusiveLock | append-only segment file | 1 segment
 aoseg table       | AccessShareLock     | relation                 | n segments
 partlockt         | RowExclusiveLock    | relation                 | n segments
 partlockt_1_prt_2 | RowExclusiveLock    | relation                 | 1 segment
 partlockt_1_prt_1 | AccessExclusiveLock | append-only segment file | 1 segment
 partlockt_1_prt_3 | RowExclusiveLock    | relation                 | 1 segment
 partlockt_1_prt_3 | AccessExclusiveLock | append-only segment file | 1 segment
(11 rows)

commit;
-- drop
begin;
drop table partlockt;
select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
   coalesce    |        mode         | locktype |  node  
---------------+---------------------+----------+--------
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
(24 rows)

select * from locktest_segments where coalesce not like 'gp_%' and coalesce not like 'pg_%';
   coalesce    |        mode         | locktype |    node    
---------------+---------------------+----------+------------
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
(24 rows)

commit;
-- Indexing
create table partlockt (i int, t text) partition by range(i)
(start(1) end(10) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_1" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_2" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_3" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_4" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_5" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_6" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_7" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_8" for table "partlockt"
NOTICE:  CREATE TABLE will create partition "partlockt_1_prt_9" for table "partlockt"
begin;
create index partlockt_idx on partlockt(i);
NOTICE:  building index for child partition "partlockt_1_prt_1"
NOTICE:  building index for child partition "partlockt_1_prt_2"
NOTICE:  building index for child partition "partlockt_1_prt_3"
NOTICE:  building index for child partition "partlockt_1_prt_4"
NOTICE:  building index for child partition "partlockt_1_prt_5"
NOTICE:  building index for child partition "partlockt_1_prt_6"
NOTICE:  building index for child partition "partlockt_1_prt_7"
NOTICE:  building index for child partition "partlockt_1_prt_8"
NOTICE:  building index for child partition "partlockt_1_prt_9"
select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
        coalesce         |        mode         | locktype |  node  
-------------------------+---------------------+----------+--------
 partlockt               | ShareLock           | relation | master
 partlockt_1_prt_1       | ShareLock           | relation | master
 partlockt_1_prt_1_i_idx | AccessExclusiveLock | relation | master
 partlockt_1_prt_2       | ShareLock           | relation | master
 partlockt_1_prt_2_i_idx | AccessExclusiveLock | relation | master
 partlockt_1_prt_3       | ShareLock           | relation | master
 partlockt_1_prt_3_i_idx | AccessExclusiveLock | relation | master
 partlockt_1_prt_4       | ShareLock           | relation | master
 partlockt_1_prt_4_i_idx | AccessExclusiveLock | relation | master
 partlockt_1_prt_5       | ShareLock           | relation | master
 partlockt_1_prt_5_i_idx | AccessExclusiveLock | relation | master
 partlockt_1_prt_6       | ShareLock           | relation | master
 partlockt_1_prt_6_i_idx | AccessExclusiveLock | relation | master
 partlockt_1_prt_7       | ShareLock           | relation | master
 partlockt_1_prt_7_i_idx | AccessExclusiveLock | relation | master
 partlockt_1_prt_8       | ShareLock           | relation | master
 partlockt_1_prt_8_i_idx | AccessExclusiveLock | relation | master
 partlockt_1_prt_9       | ShareLock           | relation | master
 partlockt_1_prt_9_i_idx | AccessExclusiveLock | relation | master
 partlockt_idx           | AccessExclusiveLock | relation | master
(20 rows)

select * from locktest_segments where coalesce not like 'gp_%' and coalesce not like 'pg_%';
        coalesce         |        mode         | locktype |    node    
-------------------------+---------------------+----------+------------
 partlockt               | ShareLock           | relation | n segments
 partlockt_1_prt_1       | ShareLock           | relation | n segments
 partlockt_1_prt_1_i_idx | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_2       | ShareLock           | relation | n segments
 partlockt_1_prt_2_i_idx | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_3       | ShareLock           | relation | n segments
 partlockt_1_prt_3_i_idx | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_4       | ShareLock           | relation | n segments
 partlockt_1_prt_4_i_idx | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_5       | ShareLock           | relation | n segments
 partlockt_1_prt_5_i_idx | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_6       | ShareLock           | relation | n segments
 partlockt_1_prt_6_i_idx | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_7       | ShareLock           | relation | n segments
 partlockt_1_prt_7_i_idx | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_8       | ShareLock           | relation | n segments
 partlockt_1_prt_8_i_idx | AccessExclusiveLock | relation | n segments
 partlockt_1_prt_9       | ShareLock           | relation | n segments
 partlockt_1_prt_9_i_idx | AccessExclusiveLock | relation | n segments
 partlockt_idx           | AccessExclusiveLock | relation | n segments
(20 rows)

commit;
-- Force use of the index in the select and delete below. We're not interested
-- in the plan we get, but a seqscan will not lock the index while an index
-- scan will, and we want to avoid the plan-dependent difference in the
-- expected output of this test.
set enable_seqscan=off;
-- test select locking
begin;
select * from partlockt where i = 1;
 i | t 
---+---
(0 rows)

-- Known_opt_diff: MPP-20936
select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
     coalesce      |      mode       | locktype |  node  
-------------------+-----------------+----------+--------
 partlockt         | AccessShareLock | relation | master
 partlockt_1_prt_1 | AccessShareLock | relation | master
(2 rows)

select * from locktest_segments where coalesce not like 'gp_%' and coalesce not like 'pg_%';
        coalesce         |      mode       | locktype |   node    
-------------------------+-----------------+----------+-----------
 partlockt_1_prt_1       | AccessShareLock | relation | 1 segment
 partlockt_1_prt_1_i_idx | AccessShareLock | relation | 1 segment
(2 rows)

commit;
begin;
-- insert locking
insert into partlockt values(3, 'f');
select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
     coalesce      |       mode       | locktype |  node  
-------------------+------------------+----------+--------
 partlockt         | RowExclusiveLock | relation | master
 partlockt_1_prt_1 | RowExclusiveLock | relation | master
 partlockt_1_prt_2 | RowExclusiveLock | relation | master
 partlockt_1_prt_3 | RowExclusiveLock | relation | master
 partlockt_1_prt_4 | RowExclusiveLock | relation | master
 partlockt_1_prt_5 | RowExclusiveLock | relation | master
 partlockt_1_prt_6 | RowExclusiveLock | relation | master
 partlockt_1_prt_7 | RowExclusiveLock | relation | master
 partlockt_1_prt_8 | RowExclusiveLock | relation | master
 partlockt_1_prt_9 | RowExclusiveLock | relation | master
(10 rows)

select * from locktest_segments where coalesce not like 'gp_%' and coalesce not like 'pg_%';
     coalesce      |       mode       | locktype |   node    
-------------------+------------------+----------+-----------
 partlockt         | RowExclusiveLock | relation | 1 segment
 partlockt_1_prt_3 | RowExclusiveLock | relation | 1 segment
(2 rows)

commit;
-- delete locking
begin;
delete from partlockt where i = 4;
-- Known_opt_diff: MPP-20936
select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
     coalesce      |     mode      | locktype |  node  
-------------------+---------------+----------+--------
 partlockt         | ExclusiveLock | relation | master
 partlockt_1_prt_1 | ExclusiveLock | relation | master
 partlockt_1_prt_2 | ExclusiveLock | relation | master
 partlockt_1_prt_3 | ExclusiveLock | relation | master
 partlockt_1_prt_4 | ExclusiveLock | relation | master
 partlockt_1_prt_5 | ExclusiveLock | relation | master
 partlockt_1_prt_6 | ExclusiveLock | relation | master
 partlockt_1_prt_7 | ExclusiveLock | relation | master
 partlockt_1_prt_8 | ExclusiveLock | relation | master
 partlockt_1_prt_9 | ExclusiveLock | relation | master
(10 rows)

select * from locktest_segments where coalesce not like 'gp_%' and coalesce not like 'pg_%';
        coalesce         |       mode       | locktype |    node    
-------------------------+------------------+----------+------------
 partlockt               | RowExclusiveLock | relation | n segments
 partlockt_1_prt_4       | AccessShareLock  | relation | n segments
 partlockt_1_prt_4_i_idx | AccessShareLock  | relation | n segments
(3 rows)

commit;
-- drop index
begin;
drop table partlockt;
select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
   coalesce    |        mode         | locktype |  node  
---------------+---------------------+----------+--------
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
 dropped table | AccessExclusiveLock | relation | master
(40 rows)

select * from locktest_segments where coalesce not like 'gp_%' and coalesce not like 'pg_%';
   coalesce    |        mode         | locktype |    node    
---------------+---------------------+----------+------------
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
 dropped table | AccessExclusiveLock | relation | n segments
(40 rows)

commit;
-- Test locking behaviour for SELECT from root partition. The locks are
-- acquired when gp_keep_partition_children_locks is on from both planner and
-- ORCA. In case of ORCA the locks are taken only on statically selected leafs
-- or on all leafs otherwise similar to planner.
create table t_part_multi_heap (a int, b int, c int)
distributed randomly
partition by range(b)
  subpartition by list(c) subpartition template
  (
    values(0),
    values(1),
    values(2)
  )
(start(0) end(2) every(1));
NOTICE:  CREATE TABLE will create partition "t_part_multi_heap_1_prt_1" for table "t_part_multi_heap"
NOTICE:  CREATE TABLE will create partition "t_part_multi_heap_1_prt_1_2_prt_1" for table "t_part_multi_heap_1_prt_1"
NOTICE:  CREATE TABLE will create partition "t_part_multi_heap_1_prt_1_2_prt_2" for table "t_part_multi_heap_1_prt_1"
NOTICE:  CREATE TABLE will create partition "t_part_multi_heap_1_prt_1_2_prt_3" for table "t_part_multi_heap_1_prt_1"
NOTICE:  CREATE TABLE will create partition "t_part_multi_heap_1_prt_2" for table "t_part_multi_heap"
NOTICE:  CREATE TABLE will create partition "t_part_multi_heap_1_prt_2_2_prt_1" for table "t_part_multi_heap_1_prt_2"
NOTICE:  CREATE TABLE will create partition "t_part_multi_heap_1_prt_2_2_prt_2" for table "t_part_multi_heap_1_prt_2"
NOTICE:  CREATE TABLE will create partition "t_part_multi_heap_1_prt_2_2_prt_3" for table "t_part_multi_heap_1_prt_2"
-- ORCA takes locks on selected leafs and planner takes on every leaf partition
begin;
select * from t_part_multi_heap where c=2;
 a | b | c 
---+---+---
(0 rows)

select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
             coalesce              |      mode       | locktype |  node  
-----------------------------------+-----------------+----------+--------
 t_part_multi_heap                 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_1_2_prt_3 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_2_2_prt_3 | AccessShareLock | relation | master
(3 rows)

commit;
-- ORCA and planner take locks on all leafs.
begin;
select * from t_part_multi_heap;
 a | b | c 
---+---+---
(0 rows)

select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
             coalesce              |      mode       | locktype |  node  
-----------------------------------+-----------------+----------+--------
 t_part_multi_heap                 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_1_2_prt_1 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_1_2_prt_2 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_1_2_prt_3 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_2_2_prt_1 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_2_2_prt_2 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_2_2_prt_3 | AccessShareLock | relation | master
(7 rows)

commit;
-- The same behaviour. Testing that ORCA could identify the range table inside
-- the cte.
begin;
with cte as (select * from t_part_multi_heap) select * from cte;
 a | b | c 
---+---+---
(0 rows)

select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
             coalesce              |      mode       | locktype |  node  
-----------------------------------+-----------------+----------+--------
 t_part_multi_heap                 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_1_2_prt_1 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_1_2_prt_2 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_1_2_prt_3 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_2_2_prt_1 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_2_2_prt_2 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_2_2_prt_3 | AccessShareLock | relation | master
(7 rows)

commit;
-- The same behaviour. Testing that ORCA could identify the range table inside
-- the SubLink.
create table bar (p int) distributed by (p);
begin;
select bar.p from bar where bar.p in (select a from t_part_multi_heap);
 p 
---
(0 rows)

select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
             coalesce              |      mode       | locktype |  node  
-----------------------------------+-----------------+----------+--------
 bar                               | AccessShareLock | relation | master
 t_part_multi_heap                 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_1_2_prt_1 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_1_2_prt_2 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_1_2_prt_3 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_2_2_prt_1 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_2_2_prt_2 | AccessShareLock | relation | master
 t_part_multi_heap_1_prt_2_2_prt_3 | AccessShareLock | relation | master
(8 rows)

commit;
drop table bar;
-- Test ORCA taking the locks in case of Partition Selector for join.
create table t_list_multi (a int, b int, c timestamp) distributed by (a)
partition by list(b)
  subpartition by list(c) 
  (partition part1 values (1)
    (subpartition s_part1 values ('2020-06-01', '2020-07-01', '2020-08-01'),
     subpartition s_part2 values ('2020-09-01', '2020-10-01', '2020-11-01')));
NOTICE:  CREATE TABLE will create partition "t_list_multi_1_prt_part1" for table "t_list_multi"
NOTICE:  CREATE TABLE will create partition "t_list_multi_1_prt_part1_2_prt_s_part1" for table "t_list_multi_1_prt_part1"
NOTICE:  CREATE TABLE will create partition "t_list_multi_1_prt_part1_2_prt_s_part2" for table "t_list_multi_1_prt_part1"
create table t_inner_to_join (b int, c date) distributed by (c);
begin;
select count(*) from (
    select distinct c
    from t_inner_to_join
    where c = '2020-07-01'
) tf, t_list_multi
where t_list_multi.c = tf.c;
 count 
-------
     0
(1 row)

select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
                coalesce                |      mode       | locktype |  node  
----------------------------------------+-----------------+----------+--------
 t_inner_to_join                        | AccessShareLock | relation | master
 t_list_multi                           | AccessShareLock | relation | master
 t_list_multi_1_prt_part1_2_prt_s_part1 | AccessShareLock | relation | master
 t_list_multi_1_prt_part1_2_prt_s_part2 | AccessShareLock | relation | master
(4 rows)

commit;
drop table t_inner_to_join;
drop table t_list_multi;
-- Test SELECT FOR UPDATE for acquiring RowShareLock lock on QD
begin;
select * from t_part_multi_heap where c=2 for update;
 a | b | c 
---+---+---
(0 rows)

select * from locktest_master where coalesce not like 'gp_%' and coalesce not like 'pg_%';
             coalesce              |      mode       | locktype |  node  
-----------------------------------+-----------------+----------+--------
 t_part_multi_heap                 | AccessShareLock | relation | master
 t_part_multi_heap                 | ExclusiveLock   | relation | master
 t_part_multi_heap_1_prt_1_2_prt_3 | RowShareLock    | relation | master
 t_part_multi_heap_1_prt_2_2_prt_3 | RowShareLock    | relation | master
(4 rows)

commit;
drop table t_part_multi_heap;
