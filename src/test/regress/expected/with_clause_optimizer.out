-- start_matchsubs
--
-- m/ERROR:  Too much references to non-SELECT CTE \(allpaths\.c:\d+\)/
-- s/\d+/XXX/g
--
-- m/ERROR:  could not devise a plan \(planner\.c:\d+\)/
-- s/\d+/XXX/g
--
-- m/ERROR:  could not devise a plan \(cdbpath\.c:\d+\)/
-- s/\d+/XXX/g
--
-- m/ERROR:  could not parallelize SubPlan \(cdbllize\.c:\d+\)/
-- s/\d+/XXX/g
--
-- end_matchsubs
drop table if exists with_test1 cascade;
NOTICE:  table "with_test1" does not exist, skipping
create table with_test1 (i int, t text, value int) distributed by (i);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into with_test1 select i%10, 'text' || i%20, i%30 from generate_series(0, 99) i;
drop table if exists with_test2 cascade;
NOTICE:  table "with_test2" does not exist, skipping
create table with_test2 (i int, t text, value int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into with_test2 select i%100, 'text' || i%200, i%300 from generate_series(0, 999) i;
-- With clause with one common table expression
--begin_equivalent
with my_sum(total) as (select sum(value) from with_test1)
select *
from my_sum;
 total 
-------
  1350
(1 row)

select sum(value) as total from with_test1;
 total 
-------
  1350
(1 row)

--end_equivalent
-- With clause with two common table expression
--begin_equivalent
with my_sum(total) as (select sum(value) from with_test1),
     my_count(cnt) as (select count(*) from with_test1)
select cnt, total
from my_sum, my_count;
 cnt | total 
-----+-------
 100 |  1350
(1 row)

select cnt, total
from (select sum(value) as total from with_test1) tmp1,
     (select count(*) as cnt from with_test1) tmp2;
 cnt | total 
-----+-------
 100 |  1350
(1 row)

--end_equivalent
-- With clause with one common table expression that is referenced twice
--begin_equivalent
with my_group_sum(i, total) as (select i, sum(value) from with_test1 group by i)
select gs1.i, gs1.total, gs2.total
from my_group_sum gs1, my_group_sum gs2
where gs1.i = gs2.i + 1;
 i | total | total 
---+-------+-------
 4 |   130 |   120
 2 |   110 |   100
 8 |   170 |   160
 6 |   150 |   140
 3 |   120 |   110
 7 |   160 |   150
 1 |   100 |    90
 9 |   180 |   170
 5 |   140 |   130
(9 rows)

select gs1.i, gs1.total, gs2.total
from (select i, sum(value) as total from with_test1 group by i) gs1,
     (select i, sum(value) as total from with_test1 group by i) gs2
where gs1.i = gs2.i + 1;
 i | total | total 
---+-------+-------
 3 |   120 |   110
 7 |   160 |   150
 1 |   100 |    90
 9 |   180 |   170
 5 |   140 |   130
 4 |   130 |   120
 2 |   110 |   100
 8 |   170 |   160
 6 |   150 |   140
(9 rows)

--end_equivalent
-- With clause with one common table expression that contains the other common table expression
--begin_equivalent
with my_count(i, cnt) as (select i, count(*) from with_test1 group by i),
     my_sum(total) as (select sum(cnt) from my_count)
select *
from my_sum;
 total 
-------
   100
(1 row)

select sum(cnt) as total from (select i, count(*) as cnt from with_test1 group by i) my_count;
 total 
-------
   100
(1 row)

--end_equivalent
-- WITH query contains WITH
--begin_equivalent
with my_sum(total) as (
     with my_group_sum(total) as (select sum(value) from with_test1 group by i)
     select sum(total) from my_group_sum)
select *
from my_sum;
 total 
-------
  1350
(1 row)

select sum(total) from (select sum(value) as total from with_test1 group by i) my_group_sum;
 sum  
------
 1350
(1 row)

--end_equivalent
-- pathkeys
with my_order as (select * from with_test1 order by i)
select i, count(*)
from my_order
group by i order by i;
 i | count 
---+-------
 0 |    10
 1 |    10
 2 |    10
 3 |    10
 4 |    10
 5 |    10
 6 |    10
 7 |    10
 8 |    10
 9 |    10
(10 rows)

-- WITH query used in InitPlan
--begin_equivalent
with my_max(maximum) as (select max(value) from with_test1)
select * from with_test2
where value < (select * from my_max);
 i  |    t    | value 
----+---------+-------
  1 | text1   |     1
  3 | text3   |     3
  5 | text5   |     5
  7 | text7   |     7
  9 | text9   |     9
 11 | text11  |    11
 13 | text13  |    13
 15 | text15  |    15
 17 | text17  |    17
 19 | text19  |    19
 21 | text21  |    21
 23 | text23  |    23
 25 | text25  |    25
 27 | text27  |    27
  1 | text101 |     1
  3 | text103 |     3
  5 | text105 |     5
  7 | text107 |     7
  9 | text109 |     9
 11 | text111 |    11
 13 | text113 |    13
 15 | text115 |    15
 17 | text117 |    17
 19 | text119 |    19
 21 | text121 |    21
 23 | text123 |    23
 25 | text125 |    25
 27 | text127 |    27
  1 | text1   |     1
  3 | text3   |     3
  5 | text5   |     5
  7 | text7   |     7
  9 | text9   |     9
 11 | text11  |    11
 13 | text13  |    13
 15 | text15  |    15
 17 | text17  |    17
 19 | text19  |    19
 21 | text21  |    21
 23 | text23  |    23
 25 | text25  |    25
 27 | text27  |    27
  1 | text101 |     1
  3 | text103 |     3
  5 | text105 |     5
  7 | text107 |     7
  9 | text109 |     9
 11 | text111 |    11
 13 | text113 |    13
 15 | text115 |    15
 17 | text117 |    17
 19 | text119 |    19
 21 | text121 |    21
 23 | text123 |    23
 25 | text125 |    25
 27 | text127 |    27
  0 | text0   |     0
  2 | text2   |     2
  4 | text4   |     4
  6 | text6   |     6
  8 | text8   |     8
 10 | text10  |    10
 12 | text12  |    12
 14 | text14  |    14
 16 | text16  |    16
 18 | text18  |    18
 20 | text20  |    20
 22 | text22  |    22
 24 | text24  |    24
 26 | text26  |    26
 28 | text28  |    28
  0 | text100 |     0
  2 | text102 |     2
  4 | text104 |     4
  6 | text106 |     6
  8 | text108 |     8
 10 | text110 |    10
 12 | text112 |    12
 14 | text114 |    14
 16 | text116 |    16
 18 | text118 |    18
 20 | text120 |    20
 22 | text122 |    22
 24 | text124 |    24
 26 | text126 |    26
 28 | text128 |    28
  0 | text0   |     0
  2 | text2   |     2
  4 | text4   |     4
  6 | text6   |     6
  8 | text8   |     8
 10 | text10  |    10
 12 | text12  |    12
 14 | text14  |    14
 16 | text16  |    16
 18 | text18  |    18
 20 | text20  |    20
 22 | text22  |    22
 24 | text24  |    24
 26 | text26  |    26
 28 | text28  |    28
  0 | text100 |     0
  2 | text102 |     2
  4 | text104 |     4
  6 | text106 |     6
  8 | text108 |     8
 10 | text110 |    10
 12 | text112 |    12
 14 | text114 |    14
 16 | text116 |    16
 18 | text118 |    18
 20 | text120 |    20
 22 | text122 |    22
 24 | text124 |    24
 26 | text126 |    26
 28 | text128 |    28
(116 rows)

select * from with_test2
where value < (with my_max(maximum) as (select max(value) from with_test1)
               select * from my_max);
 i  |    t    | value 
----+---------+-------
  1 | text1   |     1
  3 | text3   |     3
  5 | text5   |     5
  7 | text7   |     7
  9 | text9   |     9
 11 | text11  |    11
 13 | text13  |    13
 15 | text15  |    15
 17 | text17  |    17
 19 | text19  |    19
 21 | text21  |    21
 23 | text23  |    23
 25 | text25  |    25
 27 | text27  |    27
  1 | text101 |     1
  3 | text103 |     3
  5 | text105 |     5
  7 | text107 |     7
  9 | text109 |     9
 11 | text111 |    11
 13 | text113 |    13
 15 | text115 |    15
 17 | text117 |    17
 19 | text119 |    19
 21 | text121 |    21
 23 | text123 |    23
 25 | text125 |    25
 27 | text127 |    27
  1 | text1   |     1
  3 | text3   |     3
  5 | text5   |     5
  7 | text7   |     7
  9 | text9   |     9
 11 | text11  |    11
 13 | text13  |    13
 15 | text15  |    15
 17 | text17  |    17
 19 | text19  |    19
 21 | text21  |    21
 23 | text23  |    23
 25 | text25  |    25
 27 | text27  |    27
  1 | text101 |     1
  3 | text103 |     3
  5 | text105 |     5
  7 | text107 |     7
  9 | text109 |     9
 11 | text111 |    11
 13 | text113 |    13
 15 | text115 |    15
 17 | text117 |    17
 19 | text119 |    19
 21 | text121 |    21
 23 | text123 |    23
 25 | text125 |    25
 27 | text127 |    27
  0 | text0   |     0
  2 | text2   |     2
  4 | text4   |     4
  6 | text6   |     6
  8 | text8   |     8
 10 | text10  |    10
 12 | text12  |    12
 14 | text14  |    14
 16 | text16  |    16
 18 | text18  |    18
 20 | text20  |    20
 22 | text22  |    22
 24 | text24  |    24
 26 | text26  |    26
 28 | text28  |    28
  0 | text100 |     0
  2 | text102 |     2
  4 | text104 |     4
  6 | text106 |     6
  8 | text108 |     8
 10 | text110 |    10
 12 | text112 |    12
 14 | text114 |    14
 16 | text116 |    16
 18 | text118 |    18
 20 | text120 |    20
 22 | text122 |    22
 24 | text124 |    24
 26 | text126 |    26
 28 | text128 |    28
  0 | text0   |     0
  2 | text2   |     2
  4 | text4   |     4
  6 | text6   |     6
  8 | text8   |     8
 10 | text10  |    10
 12 | text12  |    12
 14 | text14  |    14
 16 | text16  |    16
 18 | text18  |    18
 20 | text20  |    20
 22 | text22  |    22
 24 | text24  |    24
 26 | text26  |    26
 28 | text28  |    28
  0 | text100 |     0
  2 | text102 |     2
  4 | text104 |     4
  6 | text106 |     6
  8 | text108 |     8
 10 | text110 |    10
 12 | text112 |    12
 14 | text114 |    14
 16 | text116 |    16
 18 | text118 |    18
 20 | text120 |    20
 22 | text122 |    22
 24 | text124 |    24
 26 | text126 |    26
 28 | text128 |    28
(116 rows)

select * from with_test2
where value < (select max(value) from with_test1);
 i  |    t    | value 
----+---------+-------
  1 | text1   |     1
  3 | text3   |     3
  5 | text5   |     5
  7 | text7   |     7
  9 | text9   |     9
 11 | text11  |    11
 13 | text13  |    13
 15 | text15  |    15
 17 | text17  |    17
 19 | text19  |    19
 21 | text21  |    21
 23 | text23  |    23
 25 | text25  |    25
 27 | text27  |    27
  1 | text101 |     1
  3 | text103 |     3
  5 | text105 |     5
  7 | text107 |     7
  9 | text109 |     9
 11 | text111 |    11
 13 | text113 |    13
 15 | text115 |    15
 17 | text117 |    17
 19 | text119 |    19
 21 | text121 |    21
 23 | text123 |    23
 25 | text125 |    25
 27 | text127 |    27
  1 | text1   |     1
  3 | text3   |     3
  5 | text5   |     5
  7 | text7   |     7
  9 | text9   |     9
 11 | text11  |    11
 13 | text13  |    13
 15 | text15  |    15
 17 | text17  |    17
 19 | text19  |    19
 21 | text21  |    21
 23 | text23  |    23
 25 | text25  |    25
 27 | text27  |    27
  1 | text101 |     1
  3 | text103 |     3
  5 | text105 |     5
  7 | text107 |     7
  9 | text109 |     9
 11 | text111 |    11
 13 | text113 |    13
 15 | text115 |    15
 17 | text117 |    17
 19 | text119 |    19
 21 | text121 |    21
 23 | text123 |    23
 25 | text125 |    25
 27 | text127 |    27
  0 | text0   |     0
  2 | text2   |     2
  4 | text4   |     4
  6 | text6   |     6
  8 | text8   |     8
 10 | text10  |    10
 12 | text12  |    12
 14 | text14  |    14
 16 | text16  |    16
 18 | text18  |    18
 20 | text20  |    20
 22 | text22  |    22
 24 | text24  |    24
 26 | text26  |    26
 28 | text28  |    28
  0 | text100 |     0
  2 | text102 |     2
  4 | text104 |     4
  6 | text106 |     6
  8 | text108 |     8
 10 | text110 |    10
 12 | text112 |    12
 14 | text114 |    14
 16 | text116 |    16
 18 | text118 |    18
 20 | text120 |    20
 22 | text122 |    22
 24 | text124 |    24
 26 | text126 |    26
 28 | text128 |    28
  0 | text0   |     0
  2 | text2   |     2
  4 | text4   |     4
  6 | text6   |     6
  8 | text8   |     8
 10 | text10  |    10
 12 | text12  |    12
 14 | text14  |    14
 16 | text16  |    16
 18 | text18  |    18
 20 | text20  |    20
 22 | text22  |    22
 24 | text24  |    24
 26 | text26  |    26
 28 | text28  |    28
  0 | text100 |     0
  2 | text102 |     2
  4 | text104 |     4
  6 | text106 |     6
  8 | text108 |     8
 10 | text110 |    10
 12 | text112 |    12
 14 | text114 |    14
 16 | text116 |    16
 18 | text118 |    18
 20 | text120 |    20
 22 | text122 |    22
 24 | text124 |    24
 26 | text126 |    26
 28 | text128 |    28
(116 rows)

--end_equivalent
-- WITH query used in InitPlan and the main query at the same time
--begin_equivalent
with my_max(maximum) as (select max(value) from with_test1)
select with_test2.* from with_test2, my_max
where value < (select * from my_max)
and i < maximum and i > maximum - 10;
 i  |    t    | value 
----+---------+-------
 21 | text21  |    21
 23 | text23  |    23
 25 | text25  |    25
 27 | text27  |    27
 21 | text121 |    21
 23 | text123 |    23
 25 | text125 |    25
 27 | text127 |    27
 21 | text21  |    21
 23 | text23  |    23
 25 | text25  |    25
 27 | text27  |    27
 21 | text121 |    21
 23 | text123 |    23
 25 | text125 |    25
 27 | text127 |    27
 20 | text20  |    20
 22 | text22  |    22
 24 | text24  |    24
 26 | text26  |    26
 28 | text28  |    28
 20 | text120 |    20
 22 | text122 |    22
 24 | text124 |    24
 26 | text126 |    26
 28 | text128 |    28
 20 | text20  |    20
 22 | text22  |    22
 24 | text24  |    24
 26 | text26  |    26
 28 | text28  |    28
 20 | text120 |    20
 22 | text122 |    22
 24 | text124 |    24
 26 | text126 |    26
 28 | text128 |    28
(36 rows)

select with_test2.* from with_test2, (select max(value) as maximum from with_test1) as my_max
where value < (select max(value) from with_test1)
and i < maximum and i > maximum - 10;
 i  |    t    | value 
----+---------+-------
 20 | text20  |    20
 22 | text22  |    22
 24 | text24  |    24
 26 | text26  |    26
 28 | text28  |    28
 20 | text120 |    20
 22 | text122 |    22
 24 | text124 |    24
 26 | text126 |    26
 28 | text128 |    28
 20 | text20  |    20
 22 | text22  |    22
 24 | text24  |    24
 26 | text26  |    26
 28 | text28  |    28
 20 | text120 |    20
 22 | text122 |    22
 24 | text124 |    24
 26 | text126 |    26
 28 | text128 |    28
 21 | text21  |    21
 23 | text23  |    23
 25 | text25  |    25
 27 | text27  |    27
 21 | text121 |    21
 23 | text123 |    23
 25 | text125 |    25
 27 | text127 |    27
 21 | text21  |    21
 23 | text23  |    23
 25 | text25  |    25
 27 | text27  |    27
 21 | text121 |    21
 23 | text123 |    23
 25 | text125 |    25
 27 | text127 |    27
(36 rows)

--end_equivalent
-- WITH query used in subplan
--begin_equivalent
with my_groupmax(i, maximum) as (select i, max(value) from with_test1 group by i)
select * from with_test2
where value < all (select maximum from my_groupmax);
 i  |    t    | value 
----+---------+-------
  1 | text1   |     1
  3 | text3   |     3
  5 | text5   |     5
  7 | text7   |     7
  9 | text9   |     9
 11 | text11  |    11
 13 | text13  |    13
 15 | text15  |    15
 17 | text17  |    17
 19 | text19  |    19
  1 | text101 |     1
  3 | text103 |     3
  5 | text105 |     5
  7 | text107 |     7
  9 | text109 |     9
 11 | text111 |    11
 13 | text113 |    13
 15 | text115 |    15
 17 | text117 |    17
 19 | text119 |    19
  1 | text1   |     1
  3 | text3   |     3
  5 | text5   |     5
  7 | text7   |     7
  9 | text9   |     9
 11 | text11  |    11
 13 | text13  |    13
 15 | text15  |    15
 17 | text17  |    17
 19 | text19  |    19
  1 | text101 |     1
  3 | text103 |     3
  5 | text105 |     5
  7 | text107 |     7
  9 | text109 |     9
 11 | text111 |    11
 13 | text113 |    13
 15 | text115 |    15
 17 | text117 |    17
 19 | text119 |    19
  0 | text0   |     0
  2 | text2   |     2
  4 | text4   |     4
  6 | text6   |     6
  8 | text8   |     8
 10 | text10  |    10
 12 | text12  |    12
 14 | text14  |    14
 16 | text16  |    16
 18 | text18  |    18
  0 | text100 |     0
  2 | text102 |     2
  4 | text104 |     4
  6 | text106 |     6
  8 | text108 |     8
 10 | text110 |    10
 12 | text112 |    12
 14 | text114 |    14
 16 | text116 |    16
 18 | text118 |    18
  0 | text0   |     0
  2 | text2   |     2
  4 | text4   |     4
  6 | text6   |     6
  8 | text8   |     8
 10 | text10  |    10
 12 | text12  |    12
 14 | text14  |    14
 16 | text16  |    16
 18 | text18  |    18
  0 | text100 |     0
  2 | text102 |     2
  4 | text104 |     4
  6 | text106 |     6
  8 | text108 |     8
 10 | text110 |    10
 12 | text112 |    12
 14 | text114 |    14
 16 | text116 |    16
 18 | text118 |    18
(80 rows)

select * from with_test2
where value < all (select max(value) from with_test1 group by i);
 i  |    t    | value 
----+---------+-------
  1 | text1   |     1
  3 | text3   |     3
  5 | text5   |     5
  7 | text7   |     7
  9 | text9   |     9
 11 | text11  |    11
 13 | text13  |    13
 15 | text15  |    15
 17 | text17  |    17
 19 | text19  |    19
  1 | text101 |     1
  3 | text103 |     3
  5 | text105 |     5
  7 | text107 |     7
  9 | text109 |     9
 11 | text111 |    11
 13 | text113 |    13
 15 | text115 |    15
 17 | text117 |    17
 19 | text119 |    19
  1 | text1   |     1
  3 | text3   |     3
  5 | text5   |     5
  7 | text7   |     7
  9 | text9   |     9
 11 | text11  |    11
 13 | text13  |    13
 15 | text15  |    15
 17 | text17  |    17
 19 | text19  |    19
  1 | text101 |     1
  3 | text103 |     3
  5 | text105 |     5
  7 | text107 |     7
  9 | text109 |     9
 11 | text111 |    11
 13 | text113 |    13
 15 | text115 |    15
 17 | text117 |    17
 19 | text119 |    19
  0 | text0   |     0
  2 | text2   |     2
  4 | text4   |     4
  6 | text6   |     6
  8 | text8   |     8
 10 | text10  |    10
 12 | text12  |    12
 14 | text14  |    14
 16 | text16  |    16
 18 | text18  |    18
  0 | text100 |     0
  2 | text102 |     2
  4 | text104 |     4
  6 | text106 |     6
  8 | text108 |     8
 10 | text110 |    10
 12 | text112 |    12
 14 | text114 |    14
 16 | text116 |    16
 18 | text118 |    18
  0 | text0   |     0
  2 | text2   |     2
  4 | text4   |     4
  6 | text6   |     6
  8 | text8   |     8
 10 | text10  |    10
 12 | text12  |    12
 14 | text14  |    14
 16 | text16  |    16
 18 | text18  |    18
  0 | text100 |     0
  2 | text102 |     2
  4 | text104 |     4
  6 | text106 |     6
  8 | text108 |     8
 10 | text110 |    10
 12 | text112 |    12
 14 | text114 |    14
 16 | text116 |    16
 18 | text118 |    18
(80 rows)

--end_equivalent
-- WITH query used in subplan and the main query at the same time
--begin_equivalent
with my_groupmax(i, maximum) as (select i, max(value) from with_test1 group by i)
select * from with_test2, my_groupmax
where with_test2.i = my_groupmax.i
and value < all (select maximum from my_groupmax);
 i |    t    | value | i | maximum 
---+---------+-------+---+---------
 1 | text1   |     1 | 1 |      21
 3 | text3   |     3 | 3 |      23
 5 | text5   |     5 | 5 |      25
 7 | text7   |     7 | 7 |      27
 9 | text9   |     9 | 9 |      29
 1 | text101 |     1 | 1 |      21
 3 | text103 |     3 | 3 |      23
 5 | text105 |     5 | 5 |      25
 7 | text107 |     7 | 7 |      27
 9 | text109 |     9 | 9 |      29
 1 | text1   |     1 | 1 |      21
 3 | text3   |     3 | 3 |      23
 5 | text5   |     5 | 5 |      25
 7 | text7   |     7 | 7 |      27
 9 | text9   |     9 | 9 |      29
 1 | text101 |     1 | 1 |      21
 3 | text103 |     3 | 3 |      23
 5 | text105 |     5 | 5 |      25
 7 | text107 |     7 | 7 |      27
 9 | text109 |     9 | 9 |      29
 0 | text0   |     0 | 0 |      20
 2 | text2   |     2 | 2 |      22
 4 | text4   |     4 | 4 |      24
 6 | text6   |     6 | 6 |      26
 8 | text8   |     8 | 8 |      28
 0 | text100 |     0 | 0 |      20
 2 | text102 |     2 | 2 |      22
 4 | text104 |     4 | 4 |      24
 6 | text106 |     6 | 6 |      26
 8 | text108 |     8 | 8 |      28
 0 | text0   |     0 | 0 |      20
 2 | text2   |     2 | 2 |      22
 4 | text4   |     4 | 4 |      24
 6 | text6   |     6 | 6 |      26
 8 | text8   |     8 | 8 |      28
 0 | text100 |     0 | 0 |      20
 2 | text102 |     2 | 2 |      22
 4 | text104 |     4 | 4 |      24
 6 | text106 |     6 | 6 |      26
 8 | text108 |     8 | 8 |      28
(40 rows)

select * from with_test2, (select i, max(value) as maximum from with_test1 group by i) as my_groupmax
where with_test2.i = my_groupmax.i
and value < all (select max(value) from with_test1 group by i);
 i |    t    | value | i | maximum 
---+---------+-------+---+---------
 1 | text1   |     1 | 1 |      21
 3 | text3   |     3 | 3 |      23
 5 | text5   |     5 | 5 |      25
 7 | text7   |     7 | 7 |      27
 9 | text9   |     9 | 9 |      29
 1 | text101 |     1 | 1 |      21
 3 | text103 |     3 | 3 |      23
 5 | text105 |     5 | 5 |      25
 7 | text107 |     7 | 7 |      27
 9 | text109 |     9 | 9 |      29
 1 | text1   |     1 | 1 |      21
 3 | text3   |     3 | 3 |      23
 5 | text5   |     5 | 5 |      25
 7 | text7   |     7 | 7 |      27
 9 | text9   |     9 | 9 |      29
 1 | text101 |     1 | 1 |      21
 3 | text103 |     3 | 3 |      23
 5 | text105 |     5 | 5 |      25
 7 | text107 |     7 | 7 |      27
 9 | text109 |     9 | 9 |      29
 0 | text0   |     0 | 0 |      20
 2 | text2   |     2 | 2 |      22
 4 | text4   |     4 | 4 |      24
 6 | text6   |     6 | 6 |      26
 8 | text8   |     8 | 8 |      28
 0 | text100 |     0 | 0 |      20
 2 | text102 |     2 | 2 |      22
 4 | text104 |     4 | 4 |      24
 6 | text106 |     6 | 6 |      26
 8 | text108 |     8 | 8 |      28
 0 | text0   |     0 | 0 |      20
 2 | text2   |     2 | 2 |      22
 4 | text4   |     4 | 4 |      24
 6 | text6   |     6 | 6 |      26
 8 | text8   |     8 | 8 |      28
 0 | text100 |     0 | 0 |      20
 2 | text102 |     2 | 2 |      22
 4 | text104 |     4 | 4 |      24
 6 | text106 |     6 | 6 |      26
 8 | text108 |     8 | 8 |      28
(40 rows)

--end_equivalent
--begin_equivalent
with my_groupmax(i, maximum) as (select i, max(value) from with_test1 group by i)
SELECT count(*) FROM my_groupmax WHERE maximum > (SELECT sum(maximum)/100 FROM my_groupmax);
 count 
-------
    10
(1 row)

select count(*) from (select i, max(value) as maximum from with_test1 group by i) as my_groupmax
where maximum > (SELECT sum(maximum)/100 FROM (select i, max(value) as maximum from with_test1 group by i) as tmp);
 count 
-------
    10
(1 row)

--end_equivalent
-- name resolution
--begin_equivalent
with my_max(maximum) as (select max(value) from with_test2)
select * from with_test1, my_max
where value < (with my_max(maximum) as (select max(i) from with_test1)
               select * from my_max);
 i |   t    | value | maximum 
---+--------+-------+---------
 1 | text1  |     1 |     299
 3 | text3  |     3 |     299
 5 | text5  |     5 |     299
 7 | text7  |     7 |     299
 1 | text11 |     1 |     299
 3 | text13 |     3 |     299
 5 | text15 |     5 |     299
 7 | text17 |     7 |     299
 1 | text1  |     1 |     299
 3 | text3  |     3 |     299
 5 | text5  |     5 |     299
 7 | text7  |     7 |     299
 1 | text11 |     1 |     299
 3 | text13 |     3 |     299
 5 | text15 |     5 |     299
 7 | text17 |     7 |     299
 0 | text0  |     0 |     299
 2 | text2  |     2 |     299
 4 | text4  |     4 |     299
 6 | text6  |     6 |     299
 8 | text8  |     8 |     299
 0 | text10 |     0 |     299
 2 | text12 |     2 |     299
 4 | text14 |     4 |     299
 6 | text16 |     6 |     299
 8 | text18 |     8 |     299
 0 | text0  |     0 |     299
 2 | text2  |     2 |     299
 4 | text4  |     4 |     299
 6 | text6  |     6 |     299
 8 | text8  |     8 |     299
 0 | text10 |     0 |     299
 2 | text12 |     2 |     299
 4 | text14 |     4 |     299
 6 | text16 |     6 |     299
 8 | text18 |     8 |     299
(36 rows)

select * from with_test1, (select max(value) as maximum from with_test2) as my_max
where value < (select max(i) from with_test1);
 i |   t    | value | maximum 
---+--------+-------+---------
 1 | text1  |     1 |     299
 3 | text3  |     3 |     299
 5 | text5  |     5 |     299
 7 | text7  |     7 |     299
 1 | text11 |     1 |     299
 3 | text13 |     3 |     299
 5 | text15 |     5 |     299
 7 | text17 |     7 |     299
 1 | text1  |     1 |     299
 3 | text3  |     3 |     299
 5 | text5  |     5 |     299
 7 | text7  |     7 |     299
 1 | text11 |     1 |     299
 3 | text13 |     3 |     299
 5 | text15 |     5 |     299
 7 | text17 |     7 |     299
 0 | text0  |     0 |     299
 2 | text2  |     2 |     299
 4 | text4  |     4 |     299
 6 | text6  |     6 |     299
 8 | text8  |     8 |     299
 0 | text10 |     0 |     299
 2 | text12 |     2 |     299
 4 | text14 |     4 |     299
 6 | text16 |     6 |     299
 8 | text18 |     8 |     299
 0 | text0  |     0 |     299
 2 | text2  |     2 |     299
 4 | text4  |     4 |     299
 6 | text6  |     6 |     299
 8 | text8  |     8 |     299
 0 | text10 |     0 |     299
 2 | text12 |     2 |     299
 4 | text14 |     4 |     299
 6 | text16 |     6 |     299
 8 | text18 |     8 |     299
(36 rows)

--end_equivalent
-- INSERT
insert into with_test2
with my_sum(i, total) as (select i, sum(value) from with_test1 group by i)
select i, i || '', total
from my_sum;
-- CREATE TABLE AS
drop table if exists with_test3;
NOTICE:  table "with_test3" does not exist, skipping
create table with_test3 as
with my_sum(i, total) as (select i, sum(value) from with_test1 group by i)
select *
from my_sum;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
-- view
drop view if exists my_view;
NOTICE:  view "my_view" does not exist, skipping
create view my_view (total) as
with my_sum(total) as (select sum(value) from with_test1)
select *
from my_sum;
SELECT pg_get_viewdef('my_view'::regclass);
                pg_get_viewdef                
----------------------------------------------
            FROM with_test1                  +
          SELECT sum(with_test1.value) AS sum+
         )                                   +
    FROM my_sum;
  SELECT my_sum.total                        +
  WITH my_sum(total) AS (                    +
(1 row)

SELECT pg_get_viewdef('my_view'::regclass, true);
                pg_get_viewdef                
----------------------------------------------
  WITH my_sum(total) AS (                    +
          SELECT sum(with_test1.value) AS sum+
            FROM with_test1                  +
         )                                   +
  SELECT my_sum.total                        +
    FROM my_sum;
(1 row)

drop view if exists my_view;
create view my_view(total) as
with my_sum(total) as (
     with my_group_sum(total) as (select sum(value) from with_test1 group by i)
     select sum(total) from my_group_sum)
select *
from my_sum;
SELECT pg_get_viewdef('my_view'::regclass);
                    pg_get_viewdef                    
------------------------------------------------------
  WITH my_sum(total) AS (                            +
          WITH my_group_sum(total) AS (              +
                  SELECT sum(with_test1.value) AS sum+
                    FROM with_test1                  +
                   GROUP BY with_test1.i             +
                 )                                   +
          SELECT sum(my_group_sum.total) AS sum      +
            FROM my_group_sum                        +
         )                                           +
  SELECT my_sum.total                                +
    FROM my_sum;
(1 row)

SELECT pg_get_viewdef('my_view'::regclass, true);
                    pg_get_viewdef                    
------------------------------------------------------
  WITH my_sum(total) AS (                            +
          WITH my_group_sum(total) AS (              +
                  SELECT sum(with_test1.value) AS sum+
                    FROM with_test1                  +
                   GROUP BY with_test1.i             +
                 )                                   +
          SELECT sum(my_group_sum.total) AS sum      +
            FROM my_group_sum                        +
         )                                           +
  SELECT my_sum.total                                +
    FROM my_sum;
(1 row)

drop view if exists my_view;
create view my_view(i, total) as (
    select i, sum(value) from with_test1 group by i);
with my_sum(total) as (select sum(total) from my_view)
select * from my_sum;
 total 
-------
  1350
(1 row)

-- WITH query not used in the main query
--begin_equivalent
with my_sum(total) as (select sum(value) from with_test1)
select count(*) from with_test2;
 count 
-------
  1010
(1 row)

select count(*) from with_test2;
 count 
-------
  1010
(1 row)

--end_equivalent
-- WITH used in CURSOR query
begin;
	declare c cursor for with my_sum(total) as (select sum(value) from with_test1 group by i) select * from my_sum order by 1;
	fetch 10 from c;
 total 
-------
    90
   100
   110
   120
   130
   140
   150
   160
   170
   180
(10 rows)

	close c;
end;
-- Returning
create temporary table y (i int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into y
with t as (select i from with_test1)
select i+20 from t returning *;
 i  
----
 20
 20
 20
 20
 20
 20
 20
 20
 20
 20
 21
 21
 21
 21
 21
 21
 21
 21
 21
 21
 22
 22
 22
 22
 22
 22
 22
 22
 22
 22
 23
 23
 23
 23
 23
 23
 23
 23
 23
 23
 24
 24
 24
 24
 24
 24
 24
 24
 24
 24
 25
 25
 25
 25
 25
 25
 25
 25
 25
 25
 26
 26
 26
 26
 26
 26
 26
 26
 26
 26
 27
 27
 27
 27
 27
 27
 27
 27
 27
 27
 28
 28
 28
 28
 28
 28
 28
 28
 28
 28
 29
 29
 29
 29
 29
 29
 29
 29
 29
 29
(100 rows)

select * from y;
 i  
----
 20
 20
 20
 20
 20
 20
 20
 20
 20
 20
 21
 21
 21
 21
 21
 21
 21
 21
 21
 21
 22
 22
 22
 22
 22
 22
 22
 22
 22
 22
 23
 23
 23
 23
 23
 23
 23
 23
 23
 23
 24
 24
 24
 24
 24
 24
 24
 24
 24
 24
 25
 25
 25
 25
 25
 25
 25
 25
 25
 25
 26
 26
 26
 26
 26
 26
 26
 26
 26
 26
 27
 27
 27
 27
 27
 27
 27
 27
 27
 27
 28
 28
 28
 28
 28
 28
 28
 28
 28
 28
 29
 29
 29
 29
 29
 29
 29
 29
 29
 29
(100 rows)

drop table y;
-- WITH used in SETOP
with my_sum(total) as (select sum(value) from with_test1)
select * from my_sum
union all
select * from my_sum;
 total 
-------
  1350
  1350
(2 rows)

-- ERROR cases
-- duplicate CTE name
with my_sum(total) as (select sum(value) from with_test1),
     my_sum(group_total) as (select sum(value) from with_test1 group by i)
select *
from my_sum;
ERROR:  WITH query name "my_sum" specified more than once
LINE 2:      my_sum(group_total) as (select sum(value) from with_tes...
             ^
-- INTO clause
with my_sum(total) as (select sum(value) from with_test1 into total_value)
select *
from my_sum;
ERROR:  syntax error at or near "into"
LINE 1: ..._sum(total) as (select sum(value) from with_test1 into total...
                                                             ^
-- name resolution
select * from with_test1, my_max
where value < (with my_max(maximum) as (select max(i) from with_test1)
               select * from my_max);
ERROR:  relation "my_max" does not exist
LINE 1: select * from with_test1, my_max
                                  ^
with my_sum(total) as (select sum(total) from my_group_sum),
     my_group_sum(i, total) as (select i, sum(total) from with_test1 group by i)
select *
from my_sum;
ERROR:  relation "my_group_sum" does not exist
LINE 1: with my_sum(total) as (select sum(total) from my_group_sum),
                                                      ^
DETAIL:  There is a WITH item named "my_group_sum", but it cannot be referenced from this part of the query.
HINT:  Re-order the WITH items to remove forward references.
-- two WITH clauses
with my_sum(total) as (select sum(total) from with_test1),
with my_group_sum(i, total) as (select i, sum(total) from with_test1 group by i)
select *
from my_sum;
ERROR:  syntax error at or near "with my_group_sum"
LINE 2: with my_group_sum(i, total) as (select i, sum(total) from wi...
        ^
-- Test behavior with an unknown-type literal in the WITH
WITH q AS (SELECT 'foo' AS x)
SELECT x, x IS OF (unknown) as is_unknown FROM q;
  x  | is_unknown 
-----+------------
 foo | t
(1 row)

with cte(foo) as ( select 42 ) select * from ((select foo from cte)) q;
 foo 
-----
  42
(1 row)

select ( with cte(foo) as ( values(i) )
         select (select foo from cte) )
from with_test1
order by 1 limit 10;
 foo 
-----
   0
   0
   0
   0
   0
   0
   0
   0
   0
   0
(10 rows)

select ( with cte(foo) as ( values(i) )
         values((select foo from cte)) )
from with_test1
order by 1 limit 10;
 column1 
---------
       0
       0
       0
       0
       0
       0
       0
       0
       0
       0
(10 rows)

-- WITH query using Window functions
--begin_equivalent
with my_rank as (select i, t, value, rank() over (order by value) from with_test1)
select my_rank.* from with_test2, my_rank
where with_test2.i = my_rank.i
order by my_rank.i, my_rank.t, my_rank.value limit 100; -- order 1,2,3
 i |   t    | value | rank 
---+--------+-------+------
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    20 |   71
(100 rows)

select my_rank.* from with_test2, (select i, t, value, rank() over (order by value) from with_test1) as my_rank
where with_test2.i = my_rank.i
order by my_rank.i, my_rank.t, my_rank.value limit 100; -- order 1,2,3
 i |   t    | value | rank 
---+--------+-------+------
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |     0 |    1
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    10 |   41
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text0  |    20 |   71
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |     0 |    1
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    10 |   41
 0 | text10 |    20 |   71
(100 rows)

--end_equivalent
-- WITH query and CSQ
--begin_equivalent
with my_group_sum(i, total) as (select i, sum(value) from with_test1 group by i)
select with_test2.* from with_test2
where value < any (select total from my_group_sum where my_group_sum.i = with_test2.i);
 i |    t    | value 
---+---------+-------
 1 | text1   |     1
 3 | text3   |     3
 5 | text5   |     5
 7 | text7   |     7
 9 | text9   |     9
 3 | text103 |   103
 5 | text105 |   105
 7 | text107 |   107
 9 | text109 |   109
 1 | text101 |     1
 3 | text103 |     3
 5 | text105 |     5
 7 | text107 |     7
 9 | text109 |     9
 3 | text3   |   103
 5 | text5   |   105
 7 | text7   |   107
 9 | text9   |   109
 1 | text1   |     1
 3 | text3   |     3
 5 | text5   |     5
 7 | text7   |     7
 9 | text9   |     9
 3 | text103 |   103
 5 | text105 |   105
 7 | text107 |   107
 9 | text109 |   109
 1 | text101 |     1
 3 | text103 |     3
 5 | text105 |     5
 7 | text107 |     7
 9 | text109 |     9
 0 | text0   |     0
 2 | text2   |     2
 4 | text4   |     4
 6 | text6   |     6
 8 | text8   |     8
 2 | text102 |   102
 4 | text104 |   104
 6 | text106 |   106
 8 | text108 |   108
 0 | text100 |     0
 2 | text102 |     2
 4 | text104 |     4
 6 | text106 |     6
 8 | text108 |     8
 2 | text2   |   102
 4 | text4   |   104
 6 | text6   |   106
 8 | text8   |   108
 0 | text0   |     0
 2 | text2   |     2
 4 | text4   |     4
 6 | text6   |     6
 8 | text8   |     8
 2 | text102 |   102
 4 | text104 |   104
 6 | text106 |   106
 8 | text108 |   108
 0 | text100 |     0
 2 | text102 |     2
 4 | text104 |     4
 6 | text106 |     6
 8 | text108 |     8
(64 rows)

select with_test2.* from with_test2
where value < any (select total from (select i, sum(value) as total from with_test1 group by i) as tmp where tmp.i = with_test2.i);
 i |    t    | value 
---+---------+-------
 1 | text1   |     1
 3 | text3   |     3
 5 | text5   |     5
 7 | text7   |     7
 9 | text9   |     9
 3 | text103 |   103
 5 | text105 |   105
 7 | text107 |   107
 9 | text109 |   109
 1 | text101 |     1
 3 | text103 |     3
 5 | text105 |     5
 7 | text107 |     7
 9 | text109 |     9
 3 | text3   |   103
 5 | text5   |   105
 7 | text7   |   107
 9 | text9   |   109
 1 | text1   |     1
 3 | text3   |     3
 5 | text5   |     5
 7 | text7   |     7
 9 | text9   |     9
 3 | text103 |   103
 5 | text105 |   105
 7 | text107 |   107
 9 | text109 |   109
 1 | text101 |     1
 3 | text103 |     3
 5 | text105 |     5
 7 | text107 |     7
 9 | text109 |     9
 0 | text0   |     0
 2 | text2   |     2
 4 | text4   |     4
 6 | text6   |     6
 8 | text8   |     8
 2 | text102 |   102
 4 | text104 |   104
 6 | text106 |   106
 8 | text108 |   108
 0 | text100 |     0
 2 | text102 |     2
 4 | text104 |     4
 6 | text106 |     6
 8 | text108 |     8
 2 | text2   |   102
 4 | text4   |   104
 6 | text6   |   106
 8 | text8   |   108
 0 | text0   |     0
 2 | text2   |     2
 4 | text4   |     4
 6 | text6   |     6
 8 | text8   |     8
 2 | text102 |   102
 4 | text104 |   104
 6 | text106 |   106
 8 | text108 |   108
 0 | text100 |     0
 2 | text102 |     2
 4 | text104 |     4
 6 | text106 |     6
 8 | text108 |     8
(64 rows)

--end_equivalent
--begin_equivalent
with my_group_sum(i, total) as (select i, sum(value) from with_test1 group by i)
select with_test2.* from with_test2, my_group_sum
where value < any (select total from my_group_sum where my_group_sum.i = with_test2.i)
and with_test2.i = my_group_sum.i;
 i |    t    | value 
---+---------+-------
 1 | text1   |     1
 3 | text3   |     3
 5 | text5   |     5
 7 | text7   |     7
 9 | text9   |     9
 3 | text103 |   103
 5 | text105 |   105
 7 | text107 |   107
 9 | text109 |   109
 1 | text101 |     1
 3 | text103 |     3
 5 | text105 |     5
 7 | text107 |     7
 9 | text109 |     9
 3 | text3   |   103
 5 | text5   |   105
 7 | text7   |   107
 9 | text9   |   109
 1 | text1   |     1
 3 | text3   |     3
 5 | text5   |     5
 7 | text7   |     7
 9 | text9   |     9
 3 | text103 |   103
 5 | text105 |   105
 7 | text107 |   107
 9 | text109 |   109
 1 | text101 |     1
 3 | text103 |     3
 5 | text105 |     5
 7 | text107 |     7
 9 | text109 |     9
 0 | text0   |     0
 2 | text2   |     2
 4 | text4   |     4
 6 | text6   |     6
 8 | text8   |     8
 2 | text102 |   102
 4 | text104 |   104
 6 | text106 |   106
 8 | text108 |   108
 0 | text100 |     0
 2 | text102 |     2
 4 | text104 |     4
 6 | text106 |     6
 8 | text108 |     8
 2 | text2   |   102
 4 | text4   |   104
 6 | text6   |   106
 8 | text8   |   108
 0 | text0   |     0
 2 | text2   |     2
 4 | text4   |     4
 6 | text6   |     6
 8 | text8   |     8
 2 | text102 |   102
 4 | text104 |   104
 6 | text106 |   106
 8 | text108 |   108
 0 | text100 |     0
 2 | text102 |     2
 4 | text104 |     4
 6 | text106 |     6
 8 | text108 |     8
(64 rows)

select with_test2.* from with_test2, (select i, sum(value) from with_test1 group by i) as my_group_sum
where value < any (select total from (select i, sum(value) as total from with_test1 group by i) as tmp where tmp.i = with_test2.i)
and with_test2.i = my_group_sum.i;
 i |    t    | value 
---+---------+-------
 4 | text104 |   104
 6 | text106 |     6
 6 | text106 |     6
 4 | text104 |   104
 8 | text8   |   108
 0 | text0   |     0
 4 | text4   |   104
 4 | text104 |     4
 0 | text100 |     0
 2 | text2   |   102
 8 | text108 |     8
 4 | text4   |     4
 6 | text6   |     6
 6 | text106 |   106
 2 | text102 |   102
 4 | text104 |     4
 8 | text8   |     8
 6 | text6   |   106
 2 | text102 |     2
 0 | text0   |     0
 8 | text8   |     8
 0 | text100 |     0
 6 | text6   |     6
 8 | text108 |   108
 6 | text106 |   106
 4 | text4   |     4
 2 | text2   |     2
 2 | text102 |   102
 8 | text108 |   108
 8 | text108 |     8
 2 | text2   |     2
 2 | text102 |     2
 7 | text7   |   107
 7 | text7   |     7
 5 | text105 |   105
 9 | text9   |     9
 9 | text109 |   109
 5 | text105 |   105
 1 | text1   |     1
 5 | text5   |   105
 5 | text105 |     5
 1 | text101 |     1
 3 | text3   |   103
 7 | text107 |   107
 5 | text5   |     5
 9 | text109 |     9
 3 | text103 |   103
 5 | text105 |     5
 3 | text103 |     3
 1 | text1   |     1
 1 | text101 |     1
 9 | text9   |     9
 7 | text107 |   107
 9 | text109 |     9
 5 | text5   |     5
 3 | text3   |     3
 7 | text107 |     7
 7 | text7   |     7
 3 | text103 |   103
 3 | text3   |     3
 7 | text107 |     7
 9 | text109 |   109
 3 | text103 |     3
 9 | text9   |   109
(64 rows)

--end_equivalent
--begin_equivalent
with my_group_sum(i, total) as (select i, sum(value) from with_test1 group by i)
select with_test2.* from with_test2
where value < all (select total from my_group_sum where my_group_sum.i = with_test2.i)
order by 1,2,3
limit 60; --order 1,2,3
 i |    t    | value 
---+---------+-------
 0 | text0   |     0
 0 | text0   |     0
 0 | text100 |     0
 0 | text100 |     0
 1 | text1   |     1
 1 | text1   |     1
 1 | text101 |     1
 1 | text101 |     1
 2 | text102 |     2
 2 | text102 |     2
 2 | text102 |   102
 2 | text102 |   102
 2 | text2   |     2
 2 | text2   |     2
 2 | text2   |   102
 3 | text103 |     3
 3 | text103 |     3
 3 | text103 |   103
 3 | text103 |   103
 3 | text3   |     3
 3 | text3   |     3
 3 | text3   |   103
 4 | text104 |     4
 4 | text104 |     4
 4 | text104 |   104
 4 | text104 |   104
 4 | text4   |     4
 4 | text4   |     4
 4 | text4   |   104
 5 | text105 |     5
 5 | text105 |     5
 5 | text105 |   105
 5 | text105 |   105
 5 | text5   |     5
 5 | text5   |     5
 5 | text5   |   105
 6 | text106 |     6
 6 | text106 |     6
 6 | text106 |   106
 6 | text106 |   106
 6 | text6   |     6
 6 | text6   |     6
 6 | text6   |   106
 7 | text107 |     7
 7 | text107 |     7
 7 | text107 |   107
 7 | text107 |   107
 7 | text7   |     7
 7 | text7   |     7
 7 | text7   |   107
 8 | text108 |     8
 8 | text108 |     8
 8 | text108 |   108
 8 | text108 |   108
 8 | text8   |     8
 8 | text8   |     8
 8 | text8   |   108
 9 | text109 |     9
 9 | text109 |     9
 9 | text109 |   109
(60 rows)

select with_test2.* from with_test2
where value < all (select total from (select i, sum(value) as total from with_test1 group by i) as tmp where tmp.i = with_test2.i)
order by 1,2,3
limit 60; --order 1,2,3
 i |    t    | value 
---+---------+-------
 0 | text0   |     0
 0 | text0   |     0
 0 | text100 |     0
 0 | text100 |     0
 1 | text1   |     1
 1 | text1   |     1
 1 | text101 |     1
 1 | text101 |     1
 2 | text102 |     2
 2 | text102 |     2
 2 | text102 |   102
 2 | text102 |   102
 2 | text2   |     2
 2 | text2   |     2
 2 | text2   |   102
 3 | text103 |     3
 3 | text103 |     3
 3 | text103 |   103
 3 | text103 |   103
 3 | text3   |     3
 3 | text3   |     3
 3 | text3   |   103
 4 | text104 |     4
 4 | text104 |     4
 4 | text104 |   104
 4 | text104 |   104
 4 | text4   |     4
 4 | text4   |     4
 4 | text4   |   104
 5 | text105 |     5
 5 | text105 |     5
 5 | text105 |   105
 5 | text105 |   105
 5 | text5   |     5
 5 | text5   |     5
 5 | text5   |   105
 6 | text106 |     6
 6 | text106 |     6
 6 | text106 |   106
 6 | text106 |   106
 6 | text6   |     6
 6 | text6   |     6
 6 | text6   |   106
 7 | text107 |     7
 7 | text107 |     7
 7 | text107 |   107
 7 | text107 |   107
 7 | text7   |     7
 7 | text7   |     7
 7 | text7   |   107
 8 | text108 |     8
 8 | text108 |     8
 8 | text108 |   108
 8 | text108 |   108
 8 | text8   |     8
 8 | text8   |     8
 8 | text8   |   108
 9 | text109 |     9
 9 | text109 |     9
 9 | text109 |   109
(60 rows)

--end_equivalent
drop table if exists d;
drop table if exists b;
NOTICE:  table "b" does not exist, skipping
create table with_b (i integer) distributed by (i);
insert into with_b values (1), (2);
--begin_equivalent
with b1 as (select * from with_b) select * from (select * from b1 where b1.i =1) AS FOO, b1 FOO2;
 i | i 
---+---
 1 | 1
 1 | 2
(2 rows)

select * from (select * from (select * from with_b) as b1 where b1.i = 1) AS FOO, (select * from with_b) as foo2;
 i | i 
---+---
 1 | 1
 1 | 2
(2 rows)

--end_equivalent
-- qual push down test
explain (costs off) with t as (select * from with_test1) select * from t where i = 10;
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on with_test1
         Filter: (i = 10)
(3 rows)

-- Test to validate an old bug which caused incorrect results when a subquery
-- in the WITH clause appears under a nested-loop join in the query plan when
-- gp_cte_sharing was set to off. (MPP-17848)
CREATE TABLE x (a integer) DISTRIBUTED BY (a);
insert into x values(1), (2);
CREATE TABLE y (m integer NOT NULL, n smallint) DISTRIBUTED BY (m);
insert into y values(10, 1);
insert into y values(20, 1);
with yy as (
   select m
   from y,
        (select 1 as p) iv
   where n = iv.p
)
select * from x, yy;
 a | m  
---+----
 1 | 10
 1 | 20
 2 | 10
 2 | 20
(4 rows)

-- Check that WITH query is run to completion even if outer query isn't.
-- This is a test which exists in the upstream 'with' test suite in a section
-- which is currently under an ignore block. It has been copied here to avoid
-- merge conflicts since enabling it in the upstream test suite would require
-- altering the test output (as it depends on earlier tests which are failing
-- in GPDB currently).
DELETE FROM y;
INSERT INTO y SELECT generate_series(1,15) m;
WITH t AS (
    UPDATE y SET m = m * 100 RETURNING *
)
SELECT m BETWEEN 100 AND 1500 FROM t LIMIT 1;
 ?column? 
----------
 t
(1 row)

SELECT * FROM y;
  m   | n 
------+---
  600 |  
  900 |  
 1200 |  
  300 |  
 1000 |  
  400 |  
  700 |  
  800 |  
  100 |  
 1300 |  
 1400 |  
 1500 |  
  200 |  
  500 |  
 1100 |  
(15 rows)

-- Nested RECURSIVE queries with double self-referential joins are planned by
-- joining two WorkTableScans, which GPDB cannot do yet. Ensure that we error
-- out with a descriptive message.
WITH RECURSIVE r1 AS (
	SELECT 1 AS a
	UNION ALL
	(
		WITH RECURSIVE r2 AS (
			SELECT 2 AS b
			UNION ALL
			SELECT b FROM r1, r2
		)
		SELECT b FROM r2
	)
)
SELECT * FROM r1 LIMIT 1;
ERROR:  joining nested RECURSIVE clauses is not supported
-- GPDB
-- Greenplum does not support window functions in recursive part's target list
-- See issue https://github.com/greenplum-db/gpdb/issues/13299 for details.
-- Previously the following SQL will PANIC or Assert Fail if compiled with assert.
create table t_window_ordered_set_agg_rte(a bigint, b bigint, c bigint);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into t_window_ordered_set_agg_rte select i,i,i from generate_series(1, 10)i;
-- should error out during parse-analyze
with recursive rcte(x,y) as
(
  select a, b from t_window_ordered_set_agg_rte
  union all
  select (first_value(c) over (partition by b))::int, a+x
  from rcte,
       t_window_ordered_set_agg_rte as t
  where t.b = x
)
select * from rcte limit 10;
ERROR:  window functions in the target list of a recursive query is not supported in Greenplum
LINE 5:   select (first_value(c) over (partition by b))::int, a+x
                  ^
-- should error out during parse-analyze
with recursive rcte(x,y) as
(
  select a, b from t_window_ordered_set_agg_rte
  union all
  select first_value(c) over (partition by b), a+x
  from rcte,
       t_window_ordered_set_agg_rte as t
  where t.b = x
)
select * from rcte limit 10;
ERROR:  window functions in the target list of a recursive query is not supported in Greenplum
LINE 5:   select first_value(c) over (partition by b), a+x
                 ^
-- ensure orca doesn't fail (on build with asserts) when one cte on the coordinator has the correct flow and another doesn't
CREATE TABLE d (a int, b int, c int) DISTRIBUTED BY (a);
CREATE TABLE r (a int, b int, c char(255)) DISTRIBUTED REPLICATED;
INSERT INTO d SELECT 1, generate_series(1,10), 1;
INSERT INTO r SELECT 1, 2, generate_series(1,100);
SET gp_cte_sharing TO on;
EXPLAIN (ANALYZE off, COSTS off, VERBOSE off)
WITH e AS (
    SELECT DISTINCT b FROM d
), h AS (
    SELECT a FROM d JOIN e f USING (b) JOIN e USING (b)
) SELECT * FROM r JOIN h USING (a) JOIN h i USING (a);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Sequence
   ->  Shared Scan (share slice:id 0:0)
         ->  Materialize
               ->  Gather Motion 3:1  (slice7; segments: 3)
                     ->  GroupAggregate
                           Group Key: d_1.b
                           ->  Sort
                                 Sort Key: d_1.b
                                 ->  Redistribute Motion 3:3  (slice6; segments: 3)
                                       Hash Key: d_1.b
                                       ->  Seq Scan on d d_1
   ->  Sequence
         ->  Shared Scan (share slice:id 0:1)
               ->  Materialize
                     ->  Gather Motion 3:1  (slice5; segments: 3)
                           ->  Hash Join
                                 Hash Cond: (share0_ref3.b = d.b)
                                 ->  Redistribute Motion 1:3  (slice2)
                                       Hash Key: share0_ref3.b
                                       ->  Shared Scan (share slice:id 2:0)
                                 ->  Hash
                                       ->  Hash Join
                                             Hash Cond: (share0_ref2.b = d.b)
                                             ->  Redistribute Motion 1:3  (slice3)
                                                   Hash Key: share0_ref2.b
                                                   ->  Shared Scan (share slice:id 3:0)
                                             ->  Hash
                                                   ->  Redistribute Motion 3:3  (slice4; segments: 3)
                                                         Hash Key: d.b
                                                         ->  Seq Scan on d
         ->  Hash Join
               Hash Cond: (r.a = share1_ref3.a)
               ->  Gather Motion 1:1  (slice1; segments: 1)
                     ->  Seq Scan on r
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (share1_ref3.a = share1_ref2.a)
                           ->  Shared Scan (share slice:id 0:1)
                           ->  Hash
                                 ->  Shared Scan (share slice:id 0:1)
 Optimizer: Pivotal Optimizer (GPORCA)
(41 rows)

DROP TABLE d;
DROP TABLE r;
-- Test planner not pushing down quals to non-SELECT queries inside CTE. There
-- can be a DML operation, and it's incorrect to push down upper quals to it.
--start_ignore
drop table if exists with_dml;
NOTICE:  table "with_dml" does not exist, skipping
--end_ignore
create table with_dml (i int, j int) distributed by (i);
explain (costs off)
with cte as (
    insert into with_dml select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte where i > 2;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Aggregate
   ->  Gather Motion 3:1  (slice2; segments: 3)
         ->  Aggregate
               ->  Subquery Scan on cte
                     Filter: (cte.i > 2)
                     ->  Insert on with_dml
                           ->  Redistribute Motion 1:3  (slice1; segments: 1)
                                 Hash Key: i.i
                                 ->  Function Scan on generate_series i
 Optimizer: Postgres query optimizer
(10 rows)

with cte as (
    insert into with_dml select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte where i > 2;
 count 
-------
     3
(1 row)

select count(*) c from with_dml;
 c 
---
 5
(1 row)

-- Test one cannot use DML CTE if multiple CTE references found.
-- Otherwise it will cause duplicated DML operations or planner errors.
explain (costs off)
with cte as (
    insert into with_dml select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte where i < (select avg(i) from cte);
ERROR:  Too much references to non-SELECT CTE (allpaths.c:2043)
explain (costs off)
with cte as (
    update with_dml set j = j + 1
    returning i
) select count(*) from cte where i < (select avg(i) from cte);
ERROR:  Too much references to non-SELECT CTE (allpaths.c:2043)
explain (costs off)
with cte as (
    delete from with_dml where i > 0
    returning i
) select count(*) from cte where i < (select avg(i) from cte);
ERROR:  Too much references to non-SELECT CTE (allpaths.c:2043)
-- Greenplum fails to execute SELECT INTO and CREATE TABLE AS statements, whose
-- queries contain modifying CTEs, because Greenplum cannot have two writer
-- segworker groups, and during execution an error is thrown. Showing
-- the error during planning stage would be more effective, therefore this test
-- checks this behaviour.
--start_ignore
drop table if exists t_new;
NOTICE:  table "t_new" does not exist, skipping
--end_ignore
explain (costs off)
with cte as
(insert into with_dml select i, i * 100 from generate_series(1, 5) i returning *)
select into t_new from cte;
ERROR:  cannot create plan with several writing gangs
explain (costs off)
with cte as
(update with_dml set j = j + 1 returning *)
select into t_new from cte;
ERROR:  cannot create plan with several writing gangs
explain (costs off)
with cte as
(delete from with_dml where i > 0 returning *)
select into t_new from cte;
ERROR:  cannot create plan with several writing gangs
explain (costs off)
create table t_new as (with cte as
(insert into with_dml select i, i * 100 from generate_series(1, 5) i returning *)
select * from cte);
ERROR:  cannot create plan with several writing gangs
explain (costs off)
create table t_new as (with cte as
(update with_dml set j = j + 1 returning *)
select * from cte);
ERROR:  cannot create plan with several writing gangs
explain (costs off)
create table t_new as (with cte as
(delete from with_dml where i > 0 returning *)
select * from cte);
ERROR:  cannot create plan with several writing gangs
drop table with_dml;
-- Test various SELECT statements from CTE with
-- modifying DML operations over replicated tables
--start_ignore
drop table if exists with_dml_dr;
NOTICE:  table "with_dml_dr" does not exist, skipping
--end_ignore
create table with_dml_dr(i int, j int) distributed replicated;
-- Test plain SELECT from CTE with modifying DML queries on replicated table.
-- Explicit Gather Motion should present at the top of the plan.
explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte;
                      QUERY PLAN                      
------------------------------------------------------
 Explicit Gather Motion 3:1  (slice1; segments: 3)
   ->  Aggregate
         ->  Insert on with_dml_dr
               ->  Function Scan on generate_series i
 Optimizer: Postgres query optimizer
(5 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte;
 count 
-------
     5
(1 row)

explain (costs off)
with cte as (
    update with_dml_dr
    set j = j + 1 where i <= 5
    returning j
) select count(*) from cte;
                    QUERY PLAN                     
---------------------------------------------------
 Explicit Gather Motion 3:1  (slice1; segments: 3)
   ->  Aggregate
         ->  Update on with_dml_dr
               ->  Seq Scan on with_dml_dr
                     Filter: (i <= 5)
 Optimizer: Postgres query optimizer
(6 rows)

with cte as (
    update with_dml_dr
    set j = j + 1 where i <= 5
    returning j
) select count(*) from cte;
 count 
-------
     5
(1 row)

explain (costs off)
with cte as (
    delete from with_dml_dr where i > 0
    returning i
) select count(*) from cte;
                    QUERY PLAN                     
---------------------------------------------------
 Explicit Gather Motion 3:1  (slice1; segments: 3)
   ->  Aggregate
         ->  Delete on with_dml_dr
               ->  Seq Scan on with_dml_dr
                     Filter: (i > 0)
 Optimizer: Postgres query optimizer
(6 rows)

with cte as (
    delete from with_dml_dr where i > 0
    returning i
) select count(*) from cte;
 count 
-------
     5
(1 row)

-- Test ORDER BY clause is applied correctly to the result of modifying
-- CTE over replicated table.
explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select * from cte order by i;
                      QUERY PLAN                      
------------------------------------------------------
 Explicit Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: with_dml_dr.i
   ->  Sort
         Sort Key: with_dml_dr.i
         ->  Insert on with_dml_dr
               ->  Function Scan on generate_series i
 Optimizer: Postgres query optimizer
(7 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select * from cte order by i;
 i 
---
 1
 2
 3
 4
 5
(5 rows)

-- Test join operations between CTE conaining various modifying DML operations
-- over replicated table and other tables. Ensure that CdbLocusType_Replicated
-- is compatible with other type of locuses during joins.
-- Test join CdbLocusType_Replicated with CdbLocusType_SegmentGeneral.
--start_ignore
drop table if exists t_repl;
NOTICE:  table "t_repl" does not exist, skipping
--end_ignore
create table t_repl (i int, j int) distributed replicated;
insert into t_repl values (1, 1), (2, 2), (3, 3);
explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join t_repl using (i);
                         QUERY PLAN                         
------------------------------------------------------------
 Explicit Gather Motion 3:1  (slice1; segments: 3)
   ->  Aggregate
         ->  Hash Join
               Hash Cond: (with_dml_dr.i = t_repl.i)
               ->  Insert on with_dml_dr
                     ->  Function Scan on generate_series i
               ->  Hash
                     ->  Seq Scan on t_repl
 Optimizer: Postgres query optimizer
(9 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join t_repl using (i);
 count 
-------
     3
(1 row)

-- Test join CdbLocusType_Replicated with CdbLocusType_SegmentGeneral
-- in case when relations are propagated on different number of segments.
--start_ignore
drop table if exists with_dml_dr_seg2;
NOTICE:  table "with_dml_dr_seg2" does not exist, skipping
--end_ignore
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table with_dml_dr_seg2 (i int, j int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- SegmentGeneral's number of segments is larger than Replicated's,
-- the join is performed at number of segments of Replicated locus.
explain (costs off)
with cte as (
    insert into with_dml_dr_seg2
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join t_repl using (i);
                         QUERY PLAN                         
------------------------------------------------------------
 Explicit Gather Motion 2:1  (slice1; segments: 2)
   ->  Aggregate
         ->  Hash Join
               Hash Cond: (with_dml_dr_seg2.i = t_repl.i)
               ->  Insert on with_dml_dr_seg2
                     ->  Function Scan on generate_series i
               ->  Hash
                     ->  Seq Scan on t_repl
 Optimizer: Postgres query optimizer
(9 rows)

with cte as (
    insert into with_dml_dr_seg2
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join t_repl using (i);
 count 
-------
     3
(1 row)

-- SegmentGeneral's number of segments is less than Replicated's,
-- the join is performed at SingleQE.
explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join with_dml_dr_seg2 using (i);
                             QUERY PLAN                              
---------------------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (with_dml_dr_seg2.i = with_dml_dr.i)
         ->  Gather Motion 1:1  (slice1; segments: 1)
               ->  Seq Scan on with_dml_dr_seg2
         ->  Hash
               ->  Explicit Gather Motion 3:1  (slice2; segments: 3)
                     ->  Insert on with_dml_dr
                           ->  Function Scan on generate_series i
 Optimizer: Postgres query optimizer
(10 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join with_dml_dr_seg2 using (i);
 count 
-------
     5
(1 row)

drop table with_dml_dr_seg2;
drop table t_repl;
-- Test join CdbLocusType_Replicated with CdbLocusType_SingleQE.
explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte left join
  (select random() * 0 v from generate_series(1,5)) x on cte.i = x.v;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Aggregate
   ->  Hash Left Join
         Hash Cond: ((with_dml_dr.i)::double precision = ((random() * '0'::double precision)))
         ->  Explicit Gather Motion 3:1  (slice1; segments: 3)
               ->  Insert on with_dml_dr
                     ->  Function Scan on generate_series i
         ->  Hash
               ->  Function Scan on generate_series
 Optimizer: Postgres query optimizer
(9 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte left join
  (select random() * 0 v from generate_series(1,5)) x on cte.i = x.v;
 count 
-------
     5
(1 row)

-- Test join CdbLocusType_Replicated with CdbLocusType_Entry.
explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(-5,-1) i
    returning i
) select count(*) from cte left join gp_segment_configuration on cte.i = port;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Aggregate
   ->  Hash Left Join
         Hash Cond: (with_dml_dr.i = gp_segment_configuration.port)
         ->  Explicit Gather Motion 3:1  (slice1; segments: 3)
               ->  Insert on with_dml_dr
                     ->  Function Scan on generate_series i
         ->  Hash
               ->  Seq Scan on gp_segment_configuration
 Optimizer: Postgres query optimizer
(9 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(-5,-1) i
    returning i
) select count(*) from cte left join gp_segment_configuration on cte.i = port;
 count 
-------
     5
(1 row)

-- Test join CdbLocusType_Replicated with CdbLocusType_General.
explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i)
select count(*) from cte join
(select a from generate_series(1,5) a) x on cte.i = x.a;
                         QUERY PLAN                         
------------------------------------------------------------
 Explicit Gather Motion 3:1  (slice1; segments: 3)
   ->  Aggregate
         ->  Hash Join
               Hash Cond: (with_dml_dr.i = a.a)
               ->  Insert on with_dml_dr
                     ->  Function Scan on generate_series i
               ->  Hash
                     ->  Function Scan on generate_series a
 Optimizer: Postgres query optimizer
(9 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i)
select count(*) from cte join
(select a from generate_series(1,5) a) x on cte.i = x.a;
 count 
-------
     5
(1 row)

-- Test join CdbLocusType_Replicated with CdbLocusType_Hashed
-- and CdbLocusType_Strewn.
--start_ignore
drop table if exists t_hashed;
NOTICE:  table "t_hashed" does not exist, skipping
drop table if exists t_strewn;
NOTICE:  table "t_strewn" does not exist, skipping
--end_ignore
create table t_hashed (i int, j int) distributed by (i);
create table t_strewn (i int, j int) distributed randomly;
insert into t_hashed select i, i * 2 from generate_series(1, 10) i;
insert into t_strewn select i, i * 2 from generate_series(1, 10) i;
explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join t_hashed on cte.i = t_hashed.i;
                            QUERY PLAN                            
------------------------------------------------------------------
 Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Aggregate
               ->  Hash Join
                     Hash Cond: (with_dml_dr.i = t_hashed.i)
                     ->  Insert on with_dml_dr
                           ->  Function Scan on generate_series i
                     ->  Hash
                           ->  Seq Scan on t_hashed
 Optimizer: Postgres query optimizer
(10 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join t_hashed on cte.i = t_hashed.i;
 count 
-------
     5
(1 row)

explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte left join t_hashed on cte.i = t_hashed.i;
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate
   ->  Hash Left Join
         Hash Cond: (with_dml_dr.i = t_hashed.i)
         ->  Explicit Gather Motion 3:1  (slice1; segments: 3)
               ->  Insert on with_dml_dr
                     ->  Function Scan on generate_series i
         ->  Hash
               ->  Gather Motion 3:1  (slice2; segments: 3)
                     ->  Seq Scan on t_hashed
 Optimizer: Postgres query optimizer
(10 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte left join t_hashed on cte.i = t_hashed.i;
 count 
-------
     5
(1 row)

explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join t_strewn on cte.i = t_strewn.i;
                            QUERY PLAN                            
------------------------------------------------------------------
 Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Aggregate
               ->  Hash Join
                     Hash Cond: (with_dml_dr.i = t_strewn.i)
                     ->  Insert on with_dml_dr
                           ->  Function Scan on generate_series i
                     ->  Hash
                           ->  Seq Scan on t_strewn
 Optimizer: Postgres query optimizer
(10 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join t_strewn on cte.i = t_strewn.i;
 count 
-------
     5
(1 row)

explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte left join t_strewn on cte.i = t_strewn.i;
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate
   ->  Hash Left Join
         Hash Cond: (with_dml_dr.i = t_strewn.i)
         ->  Explicit Gather Motion 3:1  (slice1; segments: 3)
               ->  Insert on with_dml_dr
                     ->  Function Scan on generate_series i
         ->  Hash
               ->  Gather Motion 3:1  (slice2; segments: 3)
                     ->  Seq Scan on t_strewn
 Optimizer: Postgres query optimizer
(10 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte left join t_strewn on cte.i = t_strewn.i;
 count 
-------
     5
(1 row)

drop table t_strewn;
drop table t_hashed;
-- Test join CdbLocusType_Replicated with CdbLocusType_Hashed and
-- CdbLocusType_Strewn in case when relations are propagated on
-- different number of segments.
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table t_hashed_seg2 (i int, j int) distributed by (i);
create table t_strewn_seg2 (i int, j int) distributed randomly;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

insert into t_hashed_seg2 select i, i * 2 from generate_series(1, 10) i;
insert into t_strewn_seg2 select i, i * 2 from generate_series(1, 10) i;
explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join t_hashed_seg2 on cte.i = t_hashed_seg2.i;
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (with_dml_dr.i = t_hashed_seg2.i)
         ->  Explicit Gather Motion 3:1  (slice1; segments: 3)
               ->  Insert on with_dml_dr
                     ->  Function Scan on generate_series i
         ->  Hash
               ->  Gather Motion 2:1  (slice2; segments: 2)
                     ->  Seq Scan on t_hashed_seg2
 Optimizer: Postgres query optimizer
(10 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join t_hashed_seg2 on cte.i = t_hashed_seg2.i;
 count 
-------
     5
(1 row)

explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join t_strewn_seg2 on cte.i = t_strewn_seg2.i;
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (with_dml_dr.i = t_strewn_seg2.i)
         ->  Explicit Gather Motion 3:1  (slice1; segments: 3)
               ->  Insert on with_dml_dr
                     ->  Function Scan on generate_series i
         ->  Hash
               ->  Gather Motion 2:1  (slice2; segments: 2)
                     ->  Seq Scan on t_strewn_seg2
 Optimizer: Postgres query optimizer
(10 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte join t_strewn_seg2 on cte.i = t_strewn_seg2.i;
 count 
-------
     5
(1 row)

drop table t_strewn_seg2;
drop table t_hashed_seg2;
-- Test join CdbLocusType_Replicated with CdbLocusType_Replicated.
-- Join can be performed correctly only when CTE is shared.
set gp_cte_sharing = 1;
explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte a join cte b using (i);
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Explicit Gather Motion 3:1  (slice1; segments: 3)
   ->  Aggregate
         ->  Hash Join
               Hash Cond: (share0_ref2.i = share0_ref1.i)
               ->  Shared Scan (share slice:id 1:0)
               ->  Hash
                     ->  Shared Scan (share slice:id 1:0)
                           ->  Materialize
                                 ->  Insert on with_dml_dr
                                       ->  Function Scan on generate_series i
 Optimizer: Postgres query optimizer
(11 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i
) select count(*) from cte a join cte b using (i);
 count 
-------
     5
(1 row)

reset gp_cte_sharing;
-- Test prohibition of volatile functions applied to the
-- locus Replicated. The appropriate error should be thrown.
--start_ignore
drop table if exists t_repl;
NOTICE:  table "t_repl" does not exist, skipping
--end_ignore
create table t_repl (i int, j int) distributed replicated;
-- Prohibit volatile qualifications.
explain (costs off, verbose)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i, j
) select * from cte where cte.j > random();
ERROR:  could not devise a plan (cdbpath.c:2139)
-- Prohibit volatile returning list
explain (costs off, verbose)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i, j * random()
) select * from cte;
ERROR:  could not devise a plan (planner.c:919)
-- Prohibit volatile targetlist.
explain (costs off, verbose)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i, j
) select i, j * random() from cte;
ERROR:  could not devise a plan (planner.c:960)
-- Prohibit volatile having qualifications.
explain (costs off, verbose)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i, j
) select i, sum(j) from cte group by i having sum(j) > random();
ERROR:  could not devise a plan (planner.c:960)
-- Prohibit volatile join qualifications.
explain (costs off, verbose)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,5) i
    returning i, j
) select * from cte join t_repl on cte.i = t_repl.j * random();
ERROR:  could not devise a plan (cdbpath.c:2139)
drop table t_repl;
-- Test that node with locus Replicated is not boradcasted inside
-- a correlated/uncorrlated SubPlan. In case of different number of
-- segments between replicated node inside the SubPlan and main plan
-- the proper error should be thrown.
--start_ignore
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
drop table if exists with_dml_dr_seg2;
NOTICE:  table "with_dml_dr_seg2" does not exist, skipping
--end_ignore
create table t1 (i int, j int) distributed by (i);
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table with_dml_dr_seg2 (i int, j int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

insert into t1 select i, i from generate_series(1, 6) i;
-- Case when number of segments is equal, no Broadcast at the top of CTE plan.
explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,6) i
    returning i, j
) select * from t1
where t1.i in (select i from cte)
order by 1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: t1.i
   ->  Sort
         Sort Key: t1.i
         ->  Seq Scan on t1
               Filter: (hashed SubPlan 1)
               SubPlan 1  (slice1; segments: 3)
                 ->  Materialize
                       ->  Subquery Scan on cte
                             ->  Insert on with_dml_dr
                                   ->  Function Scan on generate_series i
 Optimizer: Postgres query optimizer
(12 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,6) i
    returning i, j
) select * from t1
where t1.i in (select i from cte)
order by 1;
 i | j 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
 5 | 5
 6 | 6
(6 rows)

explain (costs off)
with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,6) i
    returning i, j
) select * from t1
where t1.i in (select i from cte where cte.i = t1.j)
order by 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: t1.i
   ->  Sort
         Sort Key: t1.i
         ->  Seq Scan on t1
               Filter: (SubPlan 1)
               SubPlan 1  (slice1; segments: 3)
                 ->  Result
                       Filter: (cte.i = t1.j)
                       ->  Materialize
                             ->  Subquery Scan on cte
                                   ->  Insert on with_dml_dr
                                         ->  Function Scan on generate_series i
 Optimizer: Postgres query optimizer
(14 rows)

with cte as (
    insert into with_dml_dr
    select i, i * 100 from generate_series(1,6) i
    returning i, j
) select * from t1
where t1.i in (select i from cte where cte.i = t1.j)
order by 1;
 i | j 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
 5 | 5
 6 | 6
(6 rows)

-- Case with unequal number of segments between replicated node inside the
-- SubPlan and main plan, the error should be thrown.
explain (costs off)
with cte as (
    insert into with_dml_dr_seg2
    select i, i * 100 from generate_series(1,6) i
    returning i, j
) select * from t1
where t1.i in (select i from cte)
order by 1;
ERROR:  could not parallelize SubPlan (cdbllize.c:775)
with cte as (
    insert into with_dml_dr_seg2
    select i, i * 100 from generate_series(1,6) i
    returning i, j
) select * from t1
where t1.i in (select i from cte)
order by 1;
ERROR:  could not parallelize SubPlan (cdbllize.c:775)
explain (costs off)
with cte as (
    insert into with_dml_dr_seg2
    select i, i * 100 from generate_series(1,6) i
    returning i, j
) select * from t1
where t1.i in (select i from cte where cte.i = t1.j)
order by 1;
ERROR:  could not parallelize SubPlan (cdbllize.c:598)
with cte as (
    insert into with_dml_dr_seg2
    select i, i * 100 from generate_series(1,6) i
    returning i, j
) select * from t1
where t1.i in (select i from cte where cte.i = t1.j)
order by 1;
ERROR:  could not parallelize SubPlan (cdbllize.c:598)
drop table t1;
-- Test UNION ALL command when combining SegmentGeneral locus and Replicated.
--start_ignore
drop table if exists t_repl;
NOTICE:  table "t_repl" does not exist, skipping
drop table if exists t_repl_seg2;
NOTICE:  table "t_repl_seg2" does not exist, skipping
--end_ignore
create table t_repl (i int, j int) distributed replicated;
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table t_repl_seg2 (i int, j int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

insert into t_repl values (2, 2);
insert into t_repl_seg2 values (2, 2);
explain (costs off)
with cte as (
    insert into with_dml_dr
    values (1,1)
    returning i, j
) select * from cte union all select * from t_repl
order by 1;
                    QUERY PLAN                     
---------------------------------------------------
 Explicit Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: with_dml_dr.i
   ->  Sort
         Sort Key: with_dml_dr.i
         ->  Append
               ->  Insert on with_dml_dr
                     ->  Result
               ->  Seq Scan on t_repl
 Optimizer: Postgres query optimizer
(9 rows)

with cte as (
    insert into with_dml_dr
    values (1,1)
    returning i, j
) select * from cte union all select * from t_repl
order by 1;
 i | j 
---+---
 1 | 1
 2 | 2
(2 rows)

-- Case when SegmentGeneral is originally propagated at less number
-- of segments.
explain (costs off)
with cte as (
    insert into with_dml_dr
    values (1,1)
    returning i, j
) select * from cte union all select * from t_repl_seg2
order by 1;
                          QUERY PLAN                           
---------------------------------------------------------------
 Explicit Gather Motion 3:1  (slice2; segments: 3)
   Merge Key: with_dml_dr.i
   ->  Sort
         Sort Key: with_dml_dr.i
         ->  Append
               ->  Insert on with_dml_dr
                     ->  Result
               ->  Broadcast Motion 1:3  (slice1; segments: 1)
                     ->  Seq Scan on t_repl_seg2
 Optimizer: Postgres query optimizer
(10 rows)

with cte as (
    insert into with_dml_dr
    values (1,1)
    returning i, j
) select * from cte union all select * from t_repl_seg2
order by 1;
 i | j 
---+---
 1 | 1
 2 | 2
(2 rows)

-- Case when final number of segments is aligned to Replicated subplan.
explain (costs off)
with cte as (
    insert into with_dml_dr_seg2
    values (1,1)
    returning i, j
) select * from cte union all select * from t_repl
order by 1;
                    QUERY PLAN                     
---------------------------------------------------
 Explicit Gather Motion 2:1  (slice1; segments: 2)
   Merge Key: with_dml_dr_seg2.i
   ->  Sort
         Sort Key: with_dml_dr_seg2.i
         ->  Append
               ->  Insert on with_dml_dr_seg2
                     ->  Result
               ->  Seq Scan on t_repl
 Optimizer: Postgres query optimizer
(9 rows)

with cte as (
    insert into with_dml_dr_seg2
    values (1,1)
    returning i, j
) select * from cte union all select * from t_repl
order by 1;
 i | j 
---+---
 1 | 1
 2 | 2
(2 rows)

drop table t_repl_seg2;
drop table t_repl;
drop table with_dml_dr_seg2;
drop table with_dml_dr;
